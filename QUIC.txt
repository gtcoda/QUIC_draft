quic: базирующийся на UDP мультиплексный и безопасный транспортный протокол.

Анотация
Документ определяющий ядро транспортного протокола QUIC. Сопутствующий документ описывает QUIC детекцию потерь пакетов и контроль переполнения и использования обмена ключей TLS.

Введение
QUIC мультиплексируемый и безопасный транспортный протокол общего назначения и обеспечивает:
мультиплексирование потоков
управление потоком на уровне соединения
малая задержка на установку соединения
миграция соединения и устойчивость к NAT пересоединениям
аутентификация и шифрования заголовков и полезной нагрузки

Структура документа
Документ описывает ядро протокола QUIC и состоит из следующих частей.
Потоки как базовые абстракции предоставляемые QUIC:
	Раздел 2 описывает основные понятия связаные с потоками.
	Раздел 3 предоставляет базовую модель состояний потоков.
	Раздел 4 основные операции контроля потока.
Соединения - контекст, в котором взаимодействую конечные точки QUIC.
	Раздел 5 описывает основные понятия связаные с соединениями.
	Раздел 6 описывает версии согласования.
	Раздел 7 детальный процесс установки соединения.
	Раздел 8 особености критических механизмов предотвращиения отказов в обслуживании.
	Раздел 9 описывает каким образом конечные точки мигрирую соединения в новом сетевом окружении.
	Раздел 10 список опций для завершения и открытия соединения.
	Раздел 11 предоставляет основное руководство для обраблотки ошибок.
Пакеты и кадры основные еденицы используемы в соединениях QUIC.
	Раздел 12 описывает понятия связаные с пакетами и фреймами.
	Раздел 13 определяет модель для передачи, ретрянсляции и подтверждения данных.
	Раздел 14 спецификация правил для управления размером пакета.
Детальная расшифровка элементов протокола QUIC, описывает:
	Раздел 15 версии.
	Раздел 16 целочисленное кодирование.
	Раздел 17 заголовки пакета.
	Раздел 18 транспортные параметры.
	Раздел 19 кадры.
	Раздел 20 ошибки.

Дополнительные документы описывают детектирование потери пакетов и управления перегрузкой (QUIC-RECOVERY) и использование ЕДЫ для обмена ключами (QUIC-TLS).

1.2. Термины и определения.

Обычно используемые термины в документе описаны ниже.

QUIC: Транспортный протокол описаный в документе. QUIC это название, a не акроним.
Пакет QUIC: Полноценно обрабатываемая единица QUIC инкапсулированная в UDP датаграму. Множество пакетов QUIC могут быть инкапсулированы в одну UDP датаграму.
Конечная точка: субьект, который может участвовать в установлении QUIC соединения, приеме и обработки пакетов. Существуют только два вида конечных точек QUIC: клиент и сервер.
Клиент: конечная точка инициализирующая соединение.
Сервер: конечная точка принимающая входящее QUIC соединение.
ID соединения: непрозрачный идентификатор используемый для идентификации QUIC соединенияв конечной точке. Каждая конечная точка устанавливает значения для своего партнера и включает его в пакет отправляемый к конечной точке.
Поток: однонаправленный или двунаправденный канал для обмена байтами в QUIC соединении. QUIC соединение несет множество одновленыенных потоков.
Приложение: объект использующий QUIC для передачи и приема данных.

1.3 national conventions
Диаграммы пакетов и фреймов в этом документеиспользуют формат описаный в Секции 3.1 RFC2360, с следованием дополнительных соглашений:
[x]: указанный х опционален.
х (А): указанный х длинной А бит.
х (А/В/С): указанный х длинной А, В или С бит.
х (i): указанный х длинной переменное количество бит, расшифровка в Секции 16.
х (*): указанный х длинной переменное число бит.

2. Потоки
Потоки в QUIC предоставляют легкие, ориентированные на упорядоченый поток байт абстранции для приложений. Потоки могут быть однонаправленные и двунаправленные. Альтернативное представлений однонаправленных потоков в QUIC есть "сообщение" практически неограниченной длинны.
Потоки могут быть созданы для передачи даннных. Остальные процессы связанные с управлением потоком - окончание, отмена и управление потоком - разработаны с целью уменьшения накладных расходов. Для примера, одиночный потоковый фрейм  может быть открыт, передать данные и закрыть поток. Потоки могут быть долгоживущими и могут длинтся все время соединения.
Потоки могут создавать все конечные точки, могут однновременно передавать данные с другими потоками и могут быть отменены. QUIC не обеспечивает порядок байт между разными потоками.
QUIC допускает одновременно произвольное число потоков и передавать произвольное количество данных в любом потоке, с учетом ограничей накладываемых управление потоком(смотри Секцию 4).

2.1 Типы потоков и идентификаторов.
Потоки могут быть однонаправленными и двунаправленными. Однонаправленный поток передает данные только в одном направлении: от инициатора потока к получателю. Двунаправленный поток может передавать данные в обоих направлениях.
Потоки идентифицируются в соединении с помощью цифрового значения, называемым ID потока. ID потока это 62-х битное целое (от 0 до 2^62-1) иникальное для всех потоков данного соединения. ID потока записывается в целое переменой длинны(Раздел 16). Конечная точка QUIC не имеет права переиспользовать ID потока в соединении.
Первый значащий бит (0х1) в ID потока идентифицирует инициатора потока. Инициируемый клиентом поток имеет четный номер(бит установлен в 0), а инициируемый сервером нечетный(бит установлен в 1).
Второй значащий бит (0х2) в ID потока отличает двунаправленный поток(бит установлен в 0) от однонаправленного (бит установлен в 1).
Два первых значащих бита в ID потока идентифицируют поток как один из четырех типов представленных в таблице 1

Биты	Тип потокам
0х0		Инициализировано клиентом, Двунаправленный
0х1		Инициализированный сервером, Двунаправленный
0х2		Инициализированный клиентом, Однонаправленный
0х3		Инициализированный сервером, Однонаправленный

Внутри каждого типа, потоки создаются с числовым увеличением ID потока. ID потока, используемый не по порядку, приводит к тому, что будут открыты все потоки с меньшими порядковыми номерами.
Первый двунаправленный поток открываемый клиентом имеет ID потока 0.

2.2 Отправка и прием данных.
Фрейм потока(Раздел 19.8) инкапсулирует данные отправленные приложением. Конечная точка использует ID потока и поле смещения в фрейме для размещения данных.
Конечная точка может быть в состоянии доставить данные приложению в порядке потока байтов. Доставка потока байтов требует от конечной точки буферизировать любые данные полученые не по порядку, до достижения лимита управления потока.
QUIC не делает никаких специальных указаний для доставки потоком данных не по порядку. Тем не менее, реализация может предлагать возможность доставки приложению данных пришедших не по порядку.
Конечная точка может получать данные для потока с одинаковым смещением несколько раз. Данные которые были уже получены отбрасываются. Данные с данным смещением не могут быть изменены, если они были отправлены несколько раз. Конечная точка может воспринимать получение разных данных с одинаковым смещением в одном потоке как ошибку соединения типа PROTOCOL_VIOLATION.
Потоки - абстракция упорядоченого потока байтов, с не видимой структурой для QUIC. Фрейм потока не сохраняет границы данных при передаче, ретрансляции потеряного пакета и доставки до приложения на стороне приемника.
Конечная точка не может отправить данные в поток без обеспечения в пределах лимита управления потоком установленым второй стороной. Управление потоком детально описывается в Секции 4.

2.3 Приоритизация потоков.
Мультиплексирование потоков может оказать существенное влияние на производительность приложений, если ресурсы, выделеные потокам, имеют правильный приоритет.
QUIC не предоставляет механизм для обмена информацией о приоритетах. Вместо этого, полагается на получение информации о приоритетах от приложения использующего QUIC.
Рализация QUIC ДОЛЖНА предоставлять пути которые позволят приложению узнать относительные приоритеты потоков. При решении каким потокам выделять ресурсы, реализация ДОЛЖНА использовать информацию предоставленую приложением.

3. Состояние потоков.
Эта Раздел описывает потоки в терминах компонентов приема и передачи. Описываются два конечных автомата: один для описания передающмх потоков конечной точки(Раздел 3.1), другой для принимающих потоков конечной точки(Раздел 3.2).
Однонаправленные потоки используют соответствующий конечный автомат. Двунапрвленные потоки используют оба конечных автомата. По большей части использование этих конечных автоматов одинаковое является ли поток однонаправленным или двунаправленным. Условия для открытия двунаправленного потока немного сложнее, потому что, отправляющая и принимающая сторона открывают поток в двух направлениях.
Конечная точка ДОЛЖНА открывать потоки того же типа в порядке ввозрастания ID потока.
Замечание: Эти состояния являются во многом информативными. Этот документ использует состояния потока для описания правил отправки разных типов кадров, и реакции на получение разных типов кадров. Хотя конечный автомат реализовывать QUIC, эти состояния не должны стеснять реализацию.Реализация может обьявлять различные конечные автоматы до тех пор, пока его поведение соответсвует реализации, реализующей эти состояния.

3.1 Состояния потока передачи.
На Рисунке 1 показаны состояния передающей части потока отправляющей данные узлу.
 o
          | Create Stream (Sending)
          | Peer Creates Bidirectional Stream
          v
      +-------+
      | Ready | Send RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Send STREAM /             |
          |      STREAM_DATA_BLOCKED  |
          |                           |
          | Peer Creates              |
          |      Bidirectional Stream |
          v                           |
      +-------+                       |
      | Send  | Send RESET_STREAM     |
      |       |---------------------->|
      +-------+                       |
          |                           |
          | Send STREAM + FIN         |
          v                           v
      +-------+                   +-------+
      | Data  | Send RESET_STREAM | Reset |
      | Sent  |------------------>| Sent  |
      +-------+                   +-------+
          |                           |
          | Recv All ACKs             | Recv ACK
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Recvd |                   | Recvd |
      +-------+                   +-------+

               Рисунок 1: Состояния передающей части потоков.

Передающая часть потока конечной точки начинает (тип 0 и 2 для клиента, 1 и 3 для сервера) с открывается приложением. Состояние "Ready" представляет собой вновт созданный поток в состоянии принять данные от приложения. Данные потока могут быть помещены в буфер пля подготовки к отправлению.
Передав первым кадры STREAM и STREAM_DATA_BLOCKED передающая часть потока входит в состояние "Send". Реализация может отложить выделение ID потока, пока не отправит первый кадр STREAM и войти в это состояние, что позволит лучше использовать приоритезащию потоков.
Передающая часть двунаправленного потока инициированная удаленным узлом(тип 0 для сервера, тип 1 для клиента) входит в состояние "Ready" и немедленно переходит в состояние "Send" если принимающая часть переходит в состояние "Recv" (Раздел 3.2)
В состоянии "Send" конечная точка  передает - и ретранслирует если необходимо, - в потоке кадр STREAM. Конечная точка соблюдает лимитыы управления потоком установленые удаленным участниуком, и продолжает принимать м обрабатывать кадры MAX_STREAM_DATA. Конечная точка в состоянии "Send" генерирует кадры STREAM_DATA_BLOCKED, если лимины управления потоком блокируют передачу потока или соединения (Раздел 4.1).
После того, как приложение указало, что все данные потока были переданы и отправлен кадр STRERAM содержащий бит FIN, передающая часть потока переходит в состояние "Data Send". В этом состоянии, конечная точка только повторяет передачу данных если необходимо. Конечная точка не нуждается в проверке лимитов управления потоком или отправки кадров STREAM_DATA_BLOCKED для потока в этом состоянии. Кадры MAX_STREAM_DATA могут приниматься до тех пор пока удаленный участник не примет конец смещения потока. Конечная точка может безопасно игнорировать все MAX_STREAM_DATA кадры полученые от удаленного участника для потока в этом состоянии.
Когда все данные потока успешно подтвердятся, передающая часть потока переходит в состояние "Data Recvd", которое является конечным состоянием.
Для любого состояния "Ready","Send" и "Data Send", приложение может послать сигная с требованием закончить передачи данных. Конечная точка также может принять кадр STOP_SENDING от удаленного участника. В любом случае, конечная точка передает кадр RESET_STREAM, что приводит поток к переходу в сотояние "Reset Send"
Конечная точка МОЖЕТ послать RESET_STREAM в качестве первого кадра упоминаемого в потоке; в этом случае передающая часть открывает поток и немедленно переходит в состояние "Reset Sent".
Когда пакет включает RESET_STREAM успешно подтверждены, передающая часть потока переходит в состояние "Reset Recvd", кторое является конечным состоянием.

3.2 Состояние потока приема
Рисунок 2 показывает состояния для принимающей части потока от удаленного узла. Принимающая часть отражает только некоторые состояния передающей части удаленного узла. Принимающая часть не отслеживает состояние отправителя которые нельзя наблюдать, такие как состояние "Ready". Вместо этого, принимающая часть отслеживает доставку данных приложению, некоторые из которых не могут быть отслежены отправителем.

          o
          | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM
          | Create Bidirectional Stream (Sending)
          | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)
          | Create Higher-Numbered Stream
          v
      +-------+
      | Recv  | Recv RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Recv STREAM + FIN         |
          v                           |
      +-------+                       |
      | Size  | Recv RESET_STREAM     |
      | Known |---------------------->|
      +-------+                       |
          |                           |
          | Recv All Data             |
          v                           v
      +-------+ Recv RESET_STREAM +-------+
      | Data  |--- (optional) --->| Reset |
      | Recvd |  Recv All Data    | Recvd |
      +-------+<-- (optional) ----+-------+
          |                           |
          | App Read All Data         | App Read RST
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Read  |                   | Read  |
      +-------+                   +-------+

              Рисунок 2: Состояния принимающей частии потокам

Принимающая часть потока инициируемая удаленным узлом (ти 1 и 3 для клиента, 0 и 2 для сервера), создается при получении первого STREAM, STREAM_DATA_BLOCKED или RESET_STREAM. Для двунаправленного потока, инициируемого удаленным узлом, получение кадра MAX_STREAM_DATA или STOP_SENDING также инициирует создание принимающей части. Начальное состояние принимающей части "Recv".
Принимающая часть потока переходит в состояние "Recv" когда отправляющая часть двунаправленного потока, инициируемого конечной точкой (тип 0 для клиента и 1 для сервера), переходит в состояние "Ready".
Конечная точка открывает двунаправленные поток, когда от удаленного узла получен кадр MAX_STREAM_DATA или STOP_SENDING. Получение кадра MAX_STREAM_DATA для неоткрытого потока указывает, что удаленный узел открылл поток и предоставил лимит управления потоком. Получение кадра STOP_SENDING для неоткрытого потока указывает, что удаленный узел больше не желает получать данные в этом потоке. Любой кадр может прибыть до кадра STREAM или STREAM_DATA_BLOCKED, если пакеты потеряны или переупорядочены.
Перед созданием потока ДОЛЖНЫ быть созданы все потоки этого типа с меньшими номерами идентификаторов потоков. Это грантирует, что создание потоков согласованы на обеих конечных точках.
В состоянии "Recv" конечная точка получает кадры STREAM и STREAM_DATA_BLOCKED. Поступающие данные буферизируются и могут быть собраны в правильном порядке для доставки в приложение. Когда данные успользуются приложением и освобождается буферное пространство, конечная точка отправляет MAX_STREAM_DATA, чтобы удаленный узел мог отправлять больше данных.
Когда получен кадр STREAM с битом FIN, то становится известен конечный размер потока (Раздел 4.4). Принимающая часть переходт в состояние "Size Known". В этом состоянии конечной точке не нужно отправлять кадры MAX_STREAM_DATA, jyfона только получает любые переданные в потоке данные.
Как только все данные потока получены, принимающая часть переходит в состояние "Data Recv". Это может произойти при получении того же кадра "STREAM", что вызывает переход в состояние "Size Known". После получения всех данных любые кадры STREAM или STREAM_DATA_BLOCKED для этого потока могут быть отбрашены.
Состояние "Data Recvd" сохраняется до тех пор, пока дыннфе не будут доставлены приложению. Как только данные потока доставлены приложению, поток переходит в конечное состояние "Data Read".
При получении кадра RESET_STREAM в состояниях "Recv" или "Size Known" поток переходит в "Reset Recvd". Это может привести к прерыванию доставки данных в приложение.
Возможно, что все данные потокабудут получены, когда поступил RESET_STREAM(то есть в состоянии "Data Recvd"). Аналогично, оставшиеся данные могут поступить после получения кадра RESET_STREAM(в состоянии Reset Recvd). Выбор как поступить в данной ситуации отдается на усмотрение реализации.
Отправка RESET_STREAM означает, что конечная точка не в состоянии гарантировать доставку данных; однако не требуется что бы данные потока не доставлялись, если получено RESET_STREAM. Реализация МОЖЕТ прервать доставку данных, отбросить все неиспользуемые данные и сигнализировать о получении RESET_STREAM. Сигнал RESET_STREAM может быть подавден или скрыт, есливсе данные потока полностью получены и буферизированы для чтения приложением. Если сигнал RESET_STREAM подавлен, принимающая часть потока остается в состоянии "Data Recvd".
Как только приложение получает сигнал о сбросе потока, принимающая часть переходит в конечное состояние "Reset Read".

3.3 Разрешенные типы кадров.
Отправитель потока отправляет три типа кадров, что влияют на состояние потока отправителя или получателя: STREAM(Раздел 19.8), STREAM_DATA_BLOCKED( Раздел 19.13) и RESET_STREAM(Раздел 19.4).
Отправитель НЕ ДОЛЖЕН отправлять все эти кадры в конечном состоянии("Data Recvd" или "Reset Recvd"). Отправитель НЕ ДОЛЖЕН отправлять STREAM или STREAM_DATA_BLOCKED после отправки RESET_STREAM; то есть, в конечных состояниях или в состоянии "Reset Sent". Получатель может принять любой из трех кадров в любом состоянии, из-за возможности задержки доставки пакетов несущих их.
Получатель отправляет кадры MAX_STREAM_DATA(Раздел 19.10) и STOP_SENDING(Раздел 19.5).
Получатель отправляет MAX_STREAM_DATA только в состоянии "Recv". Получатель может отправить STOP_SENDING в любом состоянии, если не получено RESET_STREAM; то есть в состоянии отличном от "Reset Recvd" или "RESET Read". Однако не имеет значения отправка STOP_SENDING в состоянии "Data Recvd", поскольку все данные потока были получены. Оправитель может принять любой из двух кадров в любом состоянии, из-за отложеной доставки пакетов.

3.4 Состояния двунаправленного потока.
Двунаправленный поток состоит из отпраляющей и принимаюзей части. Реализация может представлять состояния двунаправленного потока как состоящее из состояний отпраляюшей и принимающей части. Простоя модель представляет поток как "open" когда отправляющая и принимающая часть находятся не в конечном состоянии и "closed" когда отправитель и получатель потока находятся в конечном состоянии.
Таблица 2 показывает полную карту состояний двунаправленного потока неполно соответствующею состояниям потока HTTP/2[HTTP2]. Здесь показаны обьединенные состояния отправителя и получателясостоящие из обьединенных состояний. Эта запись одно из возможных отображений; оно требует подтверждение данных до перехода в состоние "closed" или "half-closed".

   +-----------------------+---------------------+---------------------+
   | Sending Part          | Receiving Part      | Composite State     |
   +-----------------------+---------------------+---------------------+
   | No Stream/Ready       | No Stream/Recv *1   | idle                |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Recv/Size Known     | open                |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Data Recvd/Data     | half-closed         |
   |                       | Read                | (remote)            |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Reset Recvd/Reset   | half-closed         |
   |                       | Read                | (remote)            |
   |                       |                     |                     |
   | Data Recvd            | Recv/Size Known     | half-closed (local) |
   |                       |                     |                     |
   | Reset Sent/Reset      | Recv/Size Known     | half-closed (local) |
   | Recvd                 |                     |                     |
   |                       |                     |                     |
   | Reset Sent/Reset      | Data Recvd/Data     | closed              |
   | Recvd                 | Read                |                     |
   |                       |                     |                     |
   | Reset Sent/Reset      | Reset Recvd/Reset   | closed              |
   | Recvd                 | Read                |                     |
   |                       |                     |                     |
   | Data Recvd            | Data Recvd/Data     | closed              |
   |                       | Read                |                     |
   |                       |                     |                     |
   | Data Recvd            | Reset Recvd/Reset   | closed              |
   |                       | Read                |                     |
   +-----------------------+---------------------+---------------------+ 
	Таблица 2: Возможное отображение состояний потока на HTTP/2
   
3.5 Запросы на переход состояний.

Если конечная точка больше не заинтересована в данных которая получает, она МОЖЕТ послать кадр STOP_SENDING для закрытия потока. Обычно это означает, что принимающее приложение больше не читает даннные получаемые в потоке, но не гарантируется, что входящие данные будут игнорироваться.
Кадры STREAM полученые после отправки STOP_SENDING, по прежнему учитываются для соединения и управления потоком, даже если они могут быть отброшены при получении.
Кадр STOP_SENDING запрашивает, что бы принимающая конечная точка отправила кадр RESET_STREAM. Конечная точка принявшая STOP_SENDING, ДОЛЖНА отправить кадр RESET_STREAM, если поток находится в состоянии "Ready" или "Send". Если поток находится в "Data Sent" и все оставшиеся данные обьявляются потеряными, конечной точке СЛЕДУЕТ отправить RESET_STREAM вместо повторной передачи.
Конечной точке СЛЕДУЕТ скопировать код ошибки из кадра STOP_SENDING в кадр RESET_STREAM который она отправляет, но МОЖЕТ использовать любой код ошибки приложения. Конечная точка отправляющая STOP_SENDING МОЖЕТ игнорировать код ошибки содержащийся в любом полученом кадре RESET_STREAM.
Если кадр STOP_SENDING получен в потоке находящимся в состоянии "Data Sent", конечная точка желающая прекратить повторную передачу ранее отправленных кадров STREAM, ДОЛЖНА сначала отправить RESET_STREAM.
STOP_SENDING СЛЕДУЕТ отправлять только для потоков, в состоянии не reset. STOP_SENDING наиболее полезен для потоков в состоянии "Recv" или "Size Known".
Ожидается, что конечная точка отправит еще один STOP_SENDING  если предыдущий пакет содержащий STOP_SENDING был утерян. Однако, как только получены все данные потока или кадр RESET_STREAM, то есть поток находится в состоянии отличном от "Recv" или "Size Known", отправка кадра STOP_SENDING не требуется.
Конечная точка желающая завершить оба направления двунаправленного потока, может завершить одно напрвление отправив RESET_STREAM, и стимулировать быстрое завершение другого направления отправив STOP_SENDING.

4 Контроль потока.
Необходимо ограничивать обьем данных, которое может буфферизировать получяатель, чтобы не дать быстрому отправителю перегрузить медленного получателя или чтобы злонамеренный отправитель не занял большой обьем памяти у получателя. Чтобы позволить получателю ограничить выделение памяти и оказывать давление на отправителя, потоки контролируются как индивидуально так и в совокупности. Получатель QUIC контролирует какой обьем данных может передать отправитель, как описано в Разделе 4.1 и Разделе 4.2.
Аналогично, что бы ограничить параллелизм внутри соединения, конечная точка QUIC контролирует максиматьное число потоков которое может нициировать удаленный узел, как описано в Разделе 4.5.
Жданные отправляемые в кадрах CRYPTO, не подчиняются контролю потока, как данные потока. QUIC полагается на реализацию криптографического протокола, чтобы избежать чрезмерной буферизации данных.(см. [QUIC-TLS]). Реализация ДОЛЖНА предоставить интерфейс для QUIC, сообщающий о его пределах буфферизации, что бы избежать чрезмерной буферизации на нескольких уровнях.

4.1 Управление потоком данных.
QUIC использует схему управления потоком на основе кредитов, аналогичную схеме HTTP\2, где получатель обьявляет количество байтов которое он готов принять в данном потоке и для всего соединения. Это приводит к двум уровням управления потоком в QUIC:
	Управление потоком, предотвращающее использование удним потоком всего буфера приема соединения, путем ограничения обьема данных, которое может быть отпраленно в любом соединении.
	Управление соединением, которое не позволит отправителям превысить емкость буфера получателя для соединения, путем ограничения общего количества байт отправляемых в кажрах STREAM всех потоков.
Получатель установливает начальные лимиты для всех потоков, отправляя параметры во время квитирования (Раздел 7.3). Получатель отправляет отправителю кадры MAX_STREAM_DATA (Раздел 19.10) или MAX_DATA (Раздел 19.9) для установки дополнительных лимитов.
Получатель обьявляет лимит для потока, отправляя кадр MAX_STREAM_DATA с соответствующим образом установленым полем идентификатора потока. Кадр MAX_STREAM_DATA указывает максимальное абсолютное байтовое смещение потока. Приемник используя текущее смещение, определить обьявленный лимит управление потоком. Получатель МОЖЕТ отправалять кадры MAX_STREAM_DATA в нескольких пакетах, чтобы удостоверится, что отправитель получит обновление лимита управления потоком, доже если один из пакетов утерян.
Получатель обьявлет лимит для сединения, отправляя кадр MAX_DATA, который указывает максимум суммы абсолютных смещений всех байтов всех потоков. Приемник сохраняет накопленную сумму байт, полученых во всех потоках, используя ее для проверки нарушения управления потоком. Получатель может использовать сумму байт, полученую во всех потоках, для определения и обьявления максимального предела данных.
Получатель может обьявить большее смещение отправля кадры MAX_STREAM_DATA или MAX_DATA. КАК только получатель обьявил смещение, он МОЖЕТ отправить кадр с меньщим смещением, но это не имеет эффекта.
Получатель ДОЛЖЕН закрыть поток с ошибкой FLOW_CONTROL_ERROR (Раздел 11), если отправитель нарушает лимиты соединения или потока.
Отправитель ДОЛЖЕН игнорировать любые кадры MAX_DATA или MAX_STREAM_DATA которые не увеличивают лимиты управления потоком.
Если отправителю не хватает лимита управления потоком, он не может передавать новые данные и считается заблокированным. Отправителю СЛЕДУЕТ отправить кадр STREAM_DATA_BLOCKED или DATA_BLOCKED, чтобы указать, что у него есть данные для отправки, но он заблокирован ограничениями управления потоком. Ожидается, что эти кадры в обычных случаях будут отправляться нечасто, но они полезны для целей мониторинга и отладки.
Отправителю не следует отправлять несколько кадров STREAM_DATA_BLOCKED или DATA_BLOCKED для одного и того же лимита данных, только если кадр не будет определен как потерянный. Еще один кадр STREAM_DATA_BLOCKED или DATA_BLOCKED может быть отправлен после увеличения лимита данных.

4.2 Увеличение лимита управления потоком.
Этот документ оставляет на усмотрение реализации когда и сколько байт обьявлять в кадрах MAX_STREAM_DATA или MAX_DATA, но предлагает несколько соображений. Эти кадры привносят издержки в соединение. Поэтому нежелательна частая отправка кадров с небольшими изменениями. В то же время необходимы большие приращения лимитов, чтобы избежать блокировок, если обновление выполняется редко, что в сою очередь требует наличия больших ресурсов у получателя. Таким образом, следует искать компромисс между выделение русурсов и накладными расходами при определении лимита управлея потоком.
Приемник может использовать автоматический механизм настройки частоты и размера обьявленного добаваления лимита на основе оценки времени круговой задержки и скорости, ч какой принимающее приложение потребляет данные, аналогично обычным реализациям TCP. В качестве оптимизации, отправка кадров связаных с управление потоком, осуществляется только тогда, когда есть другие кадры для отправки или когда удаленный узел заблокирован. Это гарантирует, что управление потоком не вызовет отправку дополнительных пакетов.
Если отправителю не хватает лимита управления потоком, он не сможет передавать новые данные и считается заблокированным. Обычно считается, что отправитель не должен блокироваться. Чтобы избежать блокировки отправителя и учесть возможность потери кадров, получатель должен отправить кадр MAX_DATA или MAX_STREAM_DATA минимум за два RTT, до ожидаемого момента блокировки.
Получатель НЕ ДОЛЖЕН дожидаться STREAM_DATA_BLOCKED или DATA_BLOCKED перед отправкой MAX_STREAM_DATA или MAX_DATA, так как это означает, что отправитель будет заблокирован, по крайней мере на один цикл RTT, и возможно на более длительный срок, если партнер решит не отправлять STREAM_DATA_BLOCKED или DATA_BLOCKED.

4.3 Обработка отмены потока.
Конечные точки должны в конечном итоге договорится о сумме лимитов, который будет использоваться, чтобы избежать превышения лимитов или взаимоблокировки.
После получения RESET_STREAM конечная точка завершает работу для соответствующего потока и игнорирует другие даннные поступающе в этот поток. Без смещения включенного в RESET_STREAM, количество байт которое учитывается при управлении потоком может не совпадать.
Чтобы устранить эту проблему кадр RESET_STREAM(Раздел 19.4) включает в себя окончательный размер данных передаваемый в потоке. Получив кадр RESET_STREAM получатель точно знает сколько байт было отправленно в этом потоке до кадра RESET_STREAM. Получатель ДОЛЖЕН использовать окончательный размер потока, для учета всех отправленных байт, в управлении потоком уровня соединения. 
RESET_STREAM завершает одно направление потока. Для двунаправленного потока RESET_STREAM не влияет на поток в противоположном направлении. Обе конечные точки ДОЛЖНЫ поддерживать состояние управления потоком для потока в незавершенном направлении, пока это направление не завершится или одна из конечных точек не отправит кадр CONNECTION_CLOSE.

4.4 Окончательный размер потока.
Окончательный размер это сумма лимита управления потоком.  Если предположить, что каждый байт в потоке был отправлен один раз, то окончательный размер равер количеству отправленных байт. В более общем случае, ky равен на еденицу больше, чем смещение последнего байта отправленного в потоке или ноль, если не было ни одного байта.
Для потока в состоянии RESET окончательный размер явно берется из кадра RESET_STREAM. В противном случае окончательный размер этовсещение плюс длинна кадра STREAM с флагом FIN, или 0 в случае входящих однонаправленных потоков.
Конечная точка будет знать окончательный размер потока, когда принимающая часть перейдет в состояние "Size Known" или "Reset Recvd" (Раздел 3).
Конечная точка НЕ ДОЛЖНА отправлять даннные в поток за пределами конечного размера.
Как только окончательный размер потока известен, он не может изменится. Если получен кадр RESET_STREAM или STREAM, указывающий на изменение конечного размера, конечная точка ДОЛЖНА ответить ошибкой FINAL_SIZE_ERROR (Раздел 11). Получателю СЛЕДУЕТ обработотать получение данных окончательного размера или за его пределами как ошибку FINAL_SIZE_ERROR даже после закрытия потока. Генерирование этих ошибок не является обязательным, только потому, что требуются ресурсы, чтобы конечная точка должна поддерживать состояние финального размера для закрытых потоков.

4.5 Контроль согласованости.
Конечная точка ограничивает общее количество входящих потоков, которое может открыть удаленный узел. Открыты могут быть только потоки с идентификатором меньше чем (max_stream * 4 + initial_stream_id_for_type)(Таблица 5). Начальные ограничения устанавливаются транспортными параметрами (Раздел 18.1), а затем обьявляются с использованием кадров MAX_STREAMS(раздел 19.11). Отдельные ограничения для однонаправленных и двунаправленных потоков.
Если транспортный параметр max_stream или кадр MAX_STREAMS получен со значением превышающем 2^60, что является максимальным идентификатором, который может быть выражен целым числом переменной длинны. (Раздел 16). Если такой идентификатор получен соединение ДОЛЖНО быть немедленно закрыто с ошибкой STREAM_LIMIT_ERROR (Раздел 10.3)
Конечные точки НЕ ДОЛЖНЫ превышать ограничения установленные удаленными узлами. Конечная точка получившая кадр с идентификатором потока превышающем установленный ею лимит, ДОЛЖНА трактовать это как ошибку соединения типа STREAM_LIMIT_ERROR (Раздел 11).
Как только получатель обьявляет ограничение потока с помощью кадра MAX_STREAMS, обьявление немьшего ограничения не имеет никакого эффекта. Приемник ДОЛЖЕН игнорировать любой кадр  MAX_STREAMS, который не увеличивает лимит.
Этот документ оставляет выбор реализации когда и сколько открывать потоков через MAX_STREAMS. Реализация может увеличивать предел по мере того, как потоки закрываются, чтобы количество потоков для удаленного узд\ла было примерно одинаковым.
Конечная точка, которая не может открыть новый поток из-за ограничения, ДОЛЖНА отправить кадр STREAMS_BLOCKED (Раздел 19.14) Этот сигнал считается полезным для отладки. Конечная точка НЕ ДОЛЖНА ждать получения этого сигнал, прежде чем увеличить лимит. Посколько это означает, что удаленный узел будет заблокирован, по крайней мере на один цикл RTT, и возможно на более длительный срок, если удаленный узел решит не отправлять кадр STREAMS_BLOCKED.

5. Соединения
QUIC соединение сочетает согласование версии с криптографическим и транспортным рукопожатием для уменьшение задержки установки соединения, как описанов Разделе 7. После установления соединения конечная точка может менять IP или порт, как описано в разделе 9. Соединение может быть прервано любой конечной точкой, как описано в разделе 10.

5.1 ID соединения.
Каждое соединение обладает набором идентификаторов, или ID соединения, аждый из которых может идентифицировать соединение. Идентификаторы независимо выбираются двумя конечными точками, каждая конечная точка выбирает идентификаторы соединения которые использует удаленный узел.
Основная функция ID соединения заключается в обеспечении того, чтобы изменение на более низких уровнях протокола(UDP, IP) не приводили к доставке пакетов соединения QUIC в неправильную конечную точку. Каждая конечная точка выбирает идентификаторы соединения, используя метод специфичный для реализации, который позволит маршрутизировать пакеты с этим идентификатор обратно к конечной точке и идентифицировать конечную точку при получении.
ID соединения НЕ ДОЛЖНЫ содержать информацию, котрая может использоваться внешним наблюдателем для сопоставления их с другими ID соединения этого же соединения. В качестве тривиального примера, один и то же ID НЕ ДОЛЖЕН выдаваться более одного раза длля одного и того же соединения.
Пакеты с длинными заголовками включают поля "Sourse Connection ID" и "Destination Connection ID". Эти поля используюся для установки идентификаторов новых соединений, см Раздел 7.2.
Пакеты с короткими заголовками(Раздел 17.3) включают только "Destination Connection ID" и явно опискают длинну. Ожидается, что длинна поля "Destination Connection ID" известна конечным точкам. Конечные точки, использующие балансировщик нагрузки маршрутизирующий на основе ID соединения, могут согласовать с балансировщиком фиксированую длинну идентификатора, или согласовать схему кодирования.
В пакете Согласования (Раздел 17.2.1), повторяются идентификаторы соединения выбранные клиентом, чтобы гарантировать правильность маршрутизации к клиенту и позволет ему проверить, что данный пакет является ответом на начальный пакет.
ID соединения нулевой длинны МОЖЕТ использоваться, когда ID соединения не нужен для маршрутизации, а набор адрес/порт пакета достаточно для идентификации. Конечная точка, чей удаленный узел выбрал ID нулевой длинны, ДОЛЖНА продолжать использовать такой ID в течении всего времени существования соединения, и НЕ ДОЛЖНА отправлять пакеты с любого другого локального адреса.
Когда конечная точка запросила ID ненулевой длинны, она должна убедится, что удаленный узел имеет запас идентификаторов соединения, из которого можно выбрать пакеты для отправки конечной точке. Эти ID предоставляются конечной точкой с использованием кадра NEW_CONNECTION_ID (Раздел 19.15)

5.1.1 Выдача идентификаторов соединений.
Каждый ID имеет свезяный порядковый номер помогающий в дедупликации сообщений. Начальный ID, выданный конечной точкой, отправляется в поле Sourse Connection ID длинного заголовка пакета (Раздел 17.2) во врмя квитирования. Порядковый номер исходного идентификатора равен 0. Если передан транспортный параметр preferred_address, порядкой номер предоставляемого идентификатора равен 1.
Дополнительные идентификаторы передаются удаленному узлу с помощью кадров NEW_CONNECTION_ID (Раздел 19.15). Порядковый номер каждлого вновь выданного соединения ДОЛЖЕН увеличиваться на 1. ID, произвольно выбранный клиентом в исходном пакете, и любой идентификатор предоставленный пакетом Retry, не являютя назначеными порядковыми номерами, только если сервер не решит сохранить их в качестве своего начального ID.
Когда конечная точка выдала ID, она ДОЛЖНА принимать все пакеты с этим ID на все время соединения или до тех пор, пока удаленный узел не сделает этот ID недействительным по средствам кадра RETIRE_CONNECTION_ID (Раздел 19.16).
Конечной точке СЛЕДУЕТ гарантировать, что удаленный узел имеет достаточное количество доступных и неиспользованныз ID. Конечные точки хранят полкченные идентификаторы для будущего использования и обьявляют номера ID которые они готовы хранить с помощью транспортного параметра active_connection_id_limit. Конечной точке НЕ СЛЕДУЕТ представлять больше ID чем ограничение удаленного узла.
Конечной точке СЛЕДУЕТ предоставить новый идентификатор соединения, когда она получает пакет с ранее неиспользуемым ID или когда удаленный узел удаляет его, если только предоставление нового ID не превысит лимит установленный удаленным узлом. Конечная точка МОЖЕТ ограничить частоту и общее количество ID, cjolfdftvs[ для каждого соединения, чтобы избежать риска исчерпания идентификаторов соединения (Раздел 10.4.2)
Конечная точка, инициирующая миграцию и требующая идентификаторов ненулевой длинны, ДОЛЖНА гарантировать, что пул ID доступных удаленному узлу, позволит использовать новый ID при миграции, в противном случае, при исчерпании пула, соединение будет закрыто.

5.1.2 Использование и удаление идентификаторов соединения.
Конечная точка может изменить ID соединения, который она использует для удаленного узла, в любой момент соединения. Конечная точка использует ID в ответ на миграцию удаленного узла. (Раздел 9.5).
Конечная точка поддерживает набор идентификаторов, полученых от удаленного узла, любой из которых может использоваться при отправке пакетов. Когда конечная точка желает удалить идентификатор из списка используемых, она отправляет кадр RETIRE_CONNECTION_ID. Отправка кадра RETIRE_CONNECTION_ID указывает, что ID соединения больше не будет использоваться, и запрашивает, чтобы удаленный узел заменил его новым используя NEW_CONNECTION_ID.
Из обсуждения в Разделе 9.5, каждый идентификатор ДОЛЖЕН использоваться в пакетах, отправляемых ьлдбко с одного локального адреса. Конеченой точке, которая мигрирует с локального адреса, СЛЕДУЕТ удалить идентификаторы, используемые для этого адреса, если она не планирует больше использовать этот адрес.
Конечная точка может запросить удаленный узел удалить ID соединения отправлением кадра NEW_CONNECTION_ID с увеличением поля "Retire Prior To". После получения удаленный узел ДОЛЖЕН удалить соответствующие идентификаторы соединения и своевременно отправить соответствующие карды RETIRE_CONNECTION_ID. Невыполнение этого требования может привести к задержкам, потерям пакетов или к тому, что исходная конечная точка отправит сброс в ответ на идентификатор, который она не может правильно маршрутизировать.
Конечная точка МОЖЕТ отбросить ID, для которого запрошено удаление, по истечению не менее 3 PTO с момента получения подтверждения для кадра NEW_CONNECTION_ID, запросившего такое удаление. Последующие входящие пакеты использующие этот ID, могут вызвать токеном сброса.

5.2 Сопоставленение пакетов с соединением
Входящие пакеты классифицируются при получении. Пакеты могут быть связаны с существующим соединением или, дя серверов, потенциально создавать новое соединение.
Хосты пытаются связать пакеты с существующим соединением. Если пакет имеет Destination Connection ID, соответствующий существующему соединению, QUIC обрабатывает этот пакет соответствующим образом. Обратите внимание, что с соединением может быть связано больше одного соединения, см Раздел 5.1.
Если Destination Connection ID имеет нулевую длину и пакет соответствует набору адрес\порт соединения, для которого хосту не требовалось ID, QUIC обработает пакет как часть этого соединения. Конечные точки ДОЛЖНЫ либо отклонять попытки соединения, которые используют те же адреса, что и существующие соединения, либо использовать Destination Connection ID ненулевой длинны, чтобы пакеты могли быть правильно отнесены к соединениям.
Конечные точки могут отправлять сброс без сохранения состояния (Раздел 10.4) для любых пакетов, которые нельзя отнести к сузествующему соединению. Сброс без сохранения состояния позволяет удаленному узлу быстрее определить, что соединение становится непригодным для использования.
Пакеты, которые соответствуют существующему состоянию, отбрасываются, если эти пакеты не соответствуют состоянию этого соединения. Например, пакеты отбрасываются, если они указывают версию протокола, отличную от версии соединения. Или если расшифровка пакета не удалась, несмотря на наличие ожидаемых ключей.
Неверные пакеты без шифрования, такие как Initial, Retry или Version Negitiation, МОГУТ быть отброшены. Конечная точка ДОЛЖНА генерировать ошибку соединения, если она фиксирует изменение состояния до обнаружения ошибки.

5.2.1 Обработка пакетов клиентом
Правильные пакеты, отправляемые клиентом, всегда содержат Destination Connection ID который соответствует значению выбранному клиентом. Клиенты, которые выбирают получение ID нулевой длинны, могут использовать набор адрес\порт для идентификации соединения. Пакеты которые не сответствуют существующему соединению отбрасываются.
Из-за переупорядосивания или потери пакеток клиент может получить пакеты зашифрованные с помощью ключа, который он еще не вычислил. Клиент МОЖЕТ отбросить эти пакеты или МОЖЕТ буфферизировать их в ожидании более позних пакетов позволяющих вычислить ключ.
Если клиент получает пакет с неподдерживаемой версией он ДОЛЖЕН отбросить пакет.

5.2.2 Обработка пакетов сервером
Если сервер получает пакет неподдерживаемой версии, но пакет достаточен для того, чтобы инициализировать новое соединение для любой версии поддерживаемой сервером, он ДОЛЖЕН отправить пакет согласования версии, как описано в разделе 6.1. Серверы МОГУТ контролировать эти пакеты, чтобы избежить пакетных штормов. В противном слечае серверы ДОЛЖНЫ отбрасывать пакеты, которые указывают неподдерживаемые версии.
Первый пакет неподдерживаемой версии может использовать различную семантику и кодирование для любого поля, зависящего от версии. В частности, от версии могут различаться ключи шифрования пакетов.Серверы, неподдерживающие конкретныую версию, вряд ли смогут расшифровать содержимое пакета. Серверы НЕ ДОЛЖНЫ пытаться декодировать или дешифровывать пакет неизвестной версии, но вместо этого отправляют пакет согласования версий при условии, что пакет достаточно длинный.
Пакеты поддерживаемой версии или без поля версии сопоставляются соединению, используя ID или - для пакетов с ID нулевой длинный - набор адрес\порт. Если пакет не соответствует соединению, сервер продолжает работать с ним как описано ниже.
Если пакет является Начальным и полностью соответствует спецификации, сервер продолжает рукопожатие. Сервер фиксиhetn версию, которую выбрал клиент.
Еслтсервер не принимает новые соединения, он ДОЛЖЕН отправить исходный пакет содержащий кадр CONNECTION_CLOSE с кодом ошибки SERVER_BUSY.
Если полученный пакет является 0-RTT, сервер МОЖЕТ буферизировать ограниченое число пакетов в ожидании запоздавшего Начального пакета. Клиенты не могут отправлять пакеты для рукопожатия до получения ответа сервера, поэтому сервер ДОЛЖЕН игнорировать любые такие пакеты.
Серверы ДОЛЖНЫ отбрасывать входящие пакеты при любых других обстаятельствах.

5.3 Срок жизни QUIC соединения.
Подлежит определению.

6. Согласование версий.
Согласование версий гарантирует, что клиент и сервер согласятся на взаимноподдерживаемую версию QUIC. Серве отправляет пакет согласования в ответ на каждый пакет, который может инициирововать соединениее (Разде 5.2)
Размер первого пакета отправленного клиентом, определяет отправляет ли сервер пакет согласования версий. Клиенты поддерживающие несколько версий QUIC, ДОЛЖНЫ дополнять первый отправляемый пакет наибольшим из минимальных размеров пакетов во всех версиях которые они поддерживают. Это гарантирует, что сервер ответит, еслисуществует взаимоподдерживаемая версия.

6.1 Отправка пакета согласования версий.
Если выбранная клиентом версия неприемлима для сервера, он отвечает пакетом согласования версий (Раздел 17.2.1). Он включает в себя список поддерживаемых сервером версий. Конечная точка НЕ ДОЛЖНА отвечать пакетом согласования на пакет согласования.
Такая система позволяет серверу обрабатывать пакеты с неподдерживаемой версией без сохранения состояния. Несмотря на то, что исходный пакет или пакет согласования версий может быть потерян, клиент будет отправлять новые пакеты до тех пор пока не получит ответ или не откажется от попытки подключения. В результате клиент сбрасывает все состояния подключения и не отправляет больше пакетов на соединение.
Сервер МОЖЕТ ограничить количество отправляемых пакетов согласования версий. Например, сервер который может распознавать 0-RTT  пакеты, может предпочесть не отправлять пакеты согласования версий в ответ на такие пакеты, ожидая получить в конечном итоге начальный пакет.

6.2 Обработка пакета согласования версий.
Когда клиент получает пакет согласования версий, он ДОЛЖЕН отказаться от текущей попытки подключения. Пакеты согласования версий предназначены для возможности будущий версий QUIC согласовывать используемые версии между конечными точками. Будущие версии QUIC могут изменить реализацию реагирования на пакеты согласования версий данной версии. Определение реализации согласования версий оставляется для будущий версий QUIC. В часности, будущие реализации должны обеспечить устойчивость к атакам понижения версии (Раздел 21.9).

6.3 Использование зарезервированных версий.
Для того, чтобы сервер мог использовать в будущем новую версию, клиенты должны правильно обрабатывать неподдерживаемые версии. Чтобы гарантировать это, сервер ДОЛЖЕН включать версию, зарезервированную для принудительного согласования версий(0x?a?a?a?a, как определено в Разделе 15), при генерации пакета согласования версии.
Такая конструкция согласования версий позволяет сервера избегать сохранения состояния для отклоненных таким образом пакетов.
Клиент МОЖЕТ отправить пакет, используя зарезервированную версию. Это может использоваться для получения от сервера списка поддерживаемых версий.

7. Криптографическое и транспортное рукоподатие.
QUIC использует комбинированное криптографическое и транспортное рукопожатие для минимизации задержки установления соединения. QUIC использует кадр CRYPTO (Раздел 19.6) для передачи криптографического рукопожатия. Версия 0x00000001  QUIC использует TLS[QUIC-TLS]. Другой номер версии QUIC можен указывать на использование другого криптографического протокола.
QUIC обеспечивает надежную, упорядоченую доставку данных криптографического рукопожатия. Защита пакетов QUIC используется для шифрования как можно больше части протокола рукопожатия. Криптографическое рукопожатие ДОЛЖНО обеспечивать следующие свойства:
o аутентифицированный обмен ключами, где
	* сервер всегда аутентифицирован,
	* клиент может быть дополнительно аутентифицирован,
	* каждое соединение создает отдельные и несвязанные ключи,
	* ключевой материал пригоден для защиты пакетов 0-RTT, 1-RTT и т.д.
	* ключи 1-RTT имеют премую секретность.
o аутентифицирование значения для транспортных параметров удаленного узла (Раздел 7.3)
o аутентифицируемое согласование протокола приложения (для этой цели TLS использует ALPN[RFC7301])
Первый кадр CRYPTO  от клиента ДОЛЖЕН быть отправлен в одном пакете. Любая другая попытка инициировать проверку адреса (Раздел 8.1) ДОЛЖНА также отправлятся в одном пакете. Это позволяет избежать сборки сообщения из нескольких пакетов.
Первый клиентский пакет протокола криптографического квитирования ДОЛЖЕН уместится в полезную нагрузку 1232-байтного пакета QUIC. Эта нагрузка включает в себя служебные данные уменьшающие пространство доступное для протокола криптографического квитирования.
Конечная точка может проверить поддержку явного уведомления о перегрузке (ECN) в первых отправленных ей пакетах(Раздел 13.3.2).
Кадр CRYPTO может быть отправлен в разных пространствах номеров пакетов. Порядковые номера используемые кадрами CRYPTO для обеспечения упорядоченой доставки дянных рукопожатия, начинаются с нуля в каждом пространстве пакетов.
Конечные точки ДОЛЖНЫ явно согласовать протоком приложения. Это позволит избежать разногласия по поводу используемого протокола.

7.1 Пример рукопожатия.
Подробная информация о том как ЕДЫ интегрирован в QUIC представвлена в [QUIC-TLS], но некоторые примеры приведены здесь. Расширение этого обмена для поддержки проверки адреса клиента показано в разделе 8.1.1.
После завершения любой проверки адресов, криптографическое подтверждение используется для согласования риптографических ключей. Криптографическое рукопожатие передается в пакетах Initial (Раздел 17.2.2) и Handshake (раздел 17.2.4).
На рисунке 3 представлен обзор рукопожатия 1-RTT. Каждая строка показывает пакет QUIC с типом и номером от начала, и сопровождаемыми кадрами которые обычно содержаться в этом пакете. Например, первый кадр имеет тип Initial с номером 0 и содержит кадр CRYPTO переносящий ClientHello.
Обратите внимание, что несколько пакетов, даже с разными уровнями шифрования, могут быть обьеденены в одну дейтаграмму UDP (Раздел 12.2). Поэтому, рукопожатие может состоять всего из 4 дейтаграмм UDP или любого другого числа. Например, первый ответ сервера содержит пакеты с начального уровня шифрования(обфускации), уровня рукопожатия и уровня 1-RTT с данными "0,5-RTT".
Client                                                  Server

   Initial[0]: CRYPTO[CH] ->

                                    Initial[0]: CRYPTO[SH] ACK[0]
                          Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                    <- 1-RTT[0]: STREAM[1, "..."]

   Initial[1]: ACK[0]
   Handshake[0]: CRYPTO[FIN], ACK[0]
   1-RTT[0]: STREAM[0, "..."], ACK[0] ->

                               1-RTT[1]: STREAM[3, "..."], ACK[0]
                                          <- Handshake[1]: ACK[0]

                     Figure 3: Пример 1-RTT Handshake

На рисунке 4 представлен пример соединения с рукопожатием 0-RTT и одним пакетом данных 0-RTT. Обратите внимание, как описано в разделе 12.3, сервер подтверждает данные 0-RTT на уровне шифрования 1-RTT и клиент отправляет пакеты 1-RTT в том же пространстве номеров пакетов.
Client                                                  Server

   Initial[0]: CRYPTO[CH]
   0-RTT[0]: STREAM[0, "..."] ->

                                    Initial[0]: CRYPTO[SH] ACK[0]
                                     Handshake[0] CRYPTO[EE, FIN]
                             <- 1-RTT[0]: STREAM[1, "..."] ACK[0]

   Initial[1]: ACK[0]
   Handshake[0]: CRYPTO[FIN], ACK[0]
   1-RTT[1]: STREAM[0, "..."] ACK[0] ->

                               1-RTT[1]: STREAM[3, "..."], ACK[1]
                                          <- Handshake[1]: ACK[0]

                     Figure 4: Пример 0-RTT Handshake
					 
7.2 Согласование идентификаторов соединения.
Идентификатор соединения используется для обеспечения согласованной маршрутизации пакетов, как описано в разделе 5.1. Длинный заголовой содержит два идентификатора соединения:
Destination Connection ID(DCID) - выбирается получателем пакета и используется для согласованной маршрутизации;
Source Connection ID(SCID) - используется для установки DCID используемого удаленным узлом.
Во время рукопожатия используются пакеты с длинными заголовка для установления идентификатора соединения, который использует каждая конечная точка. Каждая конечная точка использует поле SCID для указания DCID который используется для отправки им пакетов. После получения пакета каждая конечная точка устанавливает DCID для отправки, чтобы соответствовать SCID для получения.
Когда пакет Initial отправляется клиентом, который ранее не получал пакет Initial или Retry от сервера, он заполняет поле DCID случайным значением. Это значение ДОЛЖНО быть длиной не менее 8 байт. Пока от сервера не получен пакет, клиент ДОЛЖЕН использовать одно и то же значение, если только он не откажется от попытки соединения и не наченет новое. Исходный DCID используется для выработки защитных ключей для Initial пакетов.
Клиент заполняет поле SCID значение по своему выбору и устанавливает поле SCID Len для указания длины. В первой фазе пакеты 0-RTT используют те же значения DCID и SCID что и первый Initial пакет.
При вервом получении пакета Initial или Retry от сервера клиент использует SCID предоставленный сервером в качестве DCID для последующих пакетов, включая любые последующие пакеты 0-RTT. Это означает, что клдиент может изменить DCID дважды во время установления соединения, один раз в ота=вет на Retry и один раз во время получения Initial пакета от сервера. Как только клиент получил Initial пакет от сервера, он ДОЛЖЕН отбрасывать любой пакет, который он получает с другим SCID.