quic: базирующийся на UDP мультиплексный и безопасный транспортный протокол.

Анотация
Документ определяющий ядро транспортного протокола QUIC. Сопутствующий документ описывает QUIC детекцию потерь пакетов и контроль переполнения и использования обмена ключей TLS.

Введение
QUIC мультиплексируемый и безопасный транспортный протокол общего назначения и обеспечивает:
мультиплексирование потоков
управление потоком на уровне соединения
малая задержка на установку соединения
миграция соединения и устойчивость к NAT пересоединениям
аутентификация и шифрования заголовков и полезной нагрузки

Структура документа
Документ описывает ядро протокола QUIC и состоит из следующих частей.
Потоки как базовые абстракции предоставляемые QUIC:
	Раздел 2 описывает основные понятия связаные с потоками.
	Раздел 3 предоставляет базовую модель состояний потоков.
	Раздел 4 основные операции контроля потока.
Соединения - контекст, в котором взаимодействую конечные точки QUIC.
	Раздел 5 описывает основные понятия связаные с соединениями.
	Раздел 6 описывает версии согласования.
	Раздел 7 детальный процесс установки соединения.
	Раздел 8 особености критических механизмов предотвращиения отказов в обслуживании.
	Раздел 9 описывает каким образом конечные точки мигрирую соединения в новом сетевом окружении.
	Раздел 10 список опций для завершения и открытия соединения.
	Раздел 11 предоставляет основное руководство для обраблотки ошибок.
Пакеты и кадры основные еденицы используемы в соединениях QUIC.
	Раздел 12 описывает понятия связаные с пакетами и фреймами.
	Раздел 13 определяет модель для передачи, ретрянсляции и подтверждения данных.
	Раздел 14 спецификация правил для управления размером пакета.
Детальная расшифровка элементов протокола QUIC, описывает:
	Раздел 15 версии.
	Раздел 16 целочисленное кодирование.
	Раздел 17 заголовки пакета.
	Раздел 18 транспортные параметры.
	Раздел 19 кадры.
	Раздел 20 ошибки.

Дополнительные документы описывают детектирование потери пакетов и управления перегрузкой (QUIC-RECOVERY) и использование ЕДЫ для обмена ключами (QUIC-TLS).

1.2. Термины и определения.

Обычно используемые термины в документе описаны ниже.

QUIC: Транспортный протокол описаный в документе. QUIC это название, a не акроним.
Пакет QUIC: Полноценно обрабатываемая единица QUIC инкапсулированная в UDP датаграму. Множество пакетов QUIC могут быть инкапсулированы в одну UDP датаграму.
Конечная точка: субьект, который может участвовать в установлении QUIC соединения, приеме и обработки пакетов. Существуют только два вида конечных точек QUIC: клиент и сервер.
Клиент: конечная точка инициализирующая соединение.
Сервер: конечная точка принимающая входящее QUIC соединение.
ID соединения: непрозрачный идентификатор используемый для идентификации QUIC соединенияв конечной точке. Каждая конечная точка устанавливает значения для своего партнера и включает его в пакет отправляемый к конечной точке.
Поток: однонаправленный или двунаправденный канал для обмена байтами в QUIC соединении. QUIC соединение несет множество одновленыенных потоков.
Приложение: объект использующий QUIC для передачи и приема данных.

1.3 national conventions
Диаграммы пакетов и фреймов в этом документеиспользуют формат описаный в Секции 3.1 RFC2360, с следованием дополнительных соглашений:
[x]: указанный х опционален.
х (А): указанный х длинной А бит.
х (А/В/С): указанный х длинной А, В или С бит.
х (i): указанный х длинной переменное количество бит, расшифровка в Секции 16.
х (*): указанный х длинной переменное число бит.

2. Потоки
Потоки в QUIC предоставляют легкие, ориентированные на упорядоченый поток байт абстранции для приложений. Потоки могут быть однонаправленные и двунаправленные. Альтернативное представлений однонаправленных потоков в QUIC есть "сообщение" практически неограниченной длинны.
Потоки могут быть созданы для передачи даннных. Остальные процессы связанные с управлением потоком - окончание, отмена и управление потоком - разработаны с целью уменьшения накладных расходов. Для примера, одиночный потоковый фрейм  может быть открыт, передать данные и закрыть поток. Потоки могут быть долгоживущими и могут длинтся все время соединения.
Потоки могут создавать все конечные точки, могут однновременно передавать данные с другими потоками и могут быть отменены. QUIC не обеспечивает порядок байт между разными потоками.
QUIC допускает одновременно произвольное число потоков и передавать произвольное количество данных в любом потоке, с учетом ограничей накладываемых управление потоком(смотри Секцию 4).

2.1 Типы потоков и идентификаторов.
Потоки могут быть однонаправленными и двунаправленными. Однонаправленный поток передает данные только в одном направлении: от инициатора потока к получателю. Двунаправленный поток может передавать данные в обоих направлениях.
Потоки идентифицируются в соединении с помощью цифрового значения, называемым ID потока. ID потока это 62-х битное целое (от 0 до 2^62-1) иникальное для всех потоков данного соединения. ID потока записывается в целое переменой длинны(Раздел 16). Конечная точка QUIC не имеет права переиспользовать ID потока в соединении.
Первый значащий бит (0х1) в ID потока идентифицирует инициатора потока. Инициируемый клиентом поток имеет четный номер(бит установлен в 0), а инициируемый сервером нечетный(бит установлен в 1).
Второй значащий бит (0х2) в ID потока отличает двунаправленный поток(бит установлен в 0) от однонаправленного (бит установлен в 1).
Два первых значащих бита в ID потока идентифицируют поток как один из четырех типов представленных в таблице 1

Биты	Тип потокам
0х0		Инициализировано клиентом, Двунаправленный
0х1		Инициализированный сервером, Двунаправленный
0х2		Инициализированный клиентом, Однонаправленный
0х3		Инициализированный сервером, Однонаправленный

Внутри каждого типа, потоки создаются с числовым увеличением ID потока. ID потока, используемый не по порядку, приводит к тому, что будут открыты все потоки с меньшими порядковыми номерами.
Первый двунаправленный поток открываемый клиентом имеет ID потока 0.

2.2 Отправка и прием данных.
Фрейм потока(Раздел 19.8) инкапсулирует данные отправленные приложением. Конечная точка использует ID потока и поле смещения в фрейме для размещения данных.
Конечная точка может быть в состоянии доставить данные приложению в порядке потока байтов. Доставка потока байтов требует от конечной точки буферизировать любые данные полученые не по порядку, до достижения лимита управления потока.
QUIC не делает никаких специальных указаний для доставки потоком данных не по порядку. Тем не менее, реализация может предлагать возможность доставки приложению данных пришедших не по порядку.
Конечная точка может получать данные для потока с одинаковым смещением несколько раз. Данные которые были уже получены отбрасываются. Данные с данным смещением не могут быть изменены, если они были отправлены несколько раз. Конечная точка может воспринимать получение разных данных с одинаковым смещением в одном потоке как ошибку соединения типа PROTOCOL_VIOLATION.
Потоки - абстракция упорядоченого потока байтов, с не видимой структурой для QUIC. Фрейм потока не сохраняет границы данных при передаче, ретрансляции потеряного пакета и доставки до приложения на стороне приемника.
Конечная точка не может отправить данные в поток без обеспечения в пределах лимита управления потоком установленым второй стороной. Управление потоком детально описывается в Секции 4.

2.3 Приоритизация потоков.
Мультиплексирование потоков может оказать существенное влияние на производительность приложений, если ресурсы, выделеные потокам, имеют правильный приоритет.
QUIC не предоставляет механизм для обмена информацией о приоритетах. Вместо этого, полагается на получение информации о приоритетах от приложения использующего QUIC.
Рализация QUIC ДОЛЖНА предоставлять пути которые позволят приложению узнать относительные приоритеты потоков. При решении каким потокам выделять ресурсы, реализация ДОЛЖНА использовать информацию предоставленую приложением.

3. Состояние потоков.
Эта Раздел описывает потоки в терминах компонентов приема и передачи. Описываются два конечных автомата: один для описания передающмх потоков конечной точки(Раздел 3.1), другой для принимающих потоков конечной точки(Раздел 3.2).
Однонаправленные потоки используют соответствующий конечный автомат. Двунапрвленные потоки используют оба конечных автомата. По большей части использование этих конечных автоматов одинаковое является ли поток однонаправленным или двунаправленным. Условия для открытия двунаправленного потока немного сложнее, потому что, отправляющая и принимающая сторона открывают поток в двух направлениях.
Конечная точка ДОЛЖНА открывать потоки того же типа в порядке ввозрастания ID потока.
Замечание: Эти состояния являются во многом информативными. Этот документ использует состояния потока для описания правил отправки разных типов кадров, и реакции на получение разных типов кадров. Хотя конечный автомат реализовывать QUIC, эти состояния не должны стеснять реализацию.Реализация может обьявлять различные конечные автоматы до тех пор, пока его поведение соответсвует реализации, реализующей эти состояния.

3.1 Состояния потока передачи.
На Рисунке 1 показаны состояния передающей части потока отправляющей данные узлу.
 o
          | Create Stream (Sending)
          | Peer Creates Bidirectional Stream
          v
      +-------+
      | Ready | Send RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Send STREAM /             |
          |      STREAM_DATA_BLOCKED  |
          |                           |
          | Peer Creates              |
          |      Bidirectional Stream |
          v                           |
      +-------+                       |
      | Send  | Send RESET_STREAM     |
      |       |---------------------->|
      +-------+                       |
          |                           |
          | Send STREAM + FIN         |
          v                           v
      +-------+                   +-------+
      | Data  | Send RESET_STREAM | Reset |
      | Sent  |------------------>| Sent  |
      +-------+                   +-------+
          |                           |
          | Recv All ACKs             | Recv ACK
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Recvd |                   | Recvd |
      +-------+                   +-------+

               Рисунок 1: Состояния передающей части потоков.

Передающая часть потока конечной точки начинает (тип 0 и 2 для клиента, 1 и 3 для сервера) с открывается приложением. Состояние "Ready" представляет собой вновт созданный поток в состоянии принять данные от приложения. Данные потока могут быть помещены в буфер пля подготовки к отправлению.
Передав первым кадры STREAM и STREAM_DATA_BLOCKED передающая часть потока входит в состояние "Send". Реализация может отложить выделение ID потока, пока не отправит первый кадр STREAM и войти в это состояние, что позволит лучше использовать приоритезащию потоков.
Передающая часть двунаправленного потока инициированная удаленным узлом(тип 0 для сервера, тип 1 для клиента) входит в состояние "Ready" и немедленно переходит в состояние "Send" если принимающая часть переходит в состояние "Recv" (Раздел 3.2)
В состоянии "Send" конечная точка  передает - и ретранслирует если необходимо, - в потоке кадр STREAM. Конечная точка соблюдает лимитыы управления потоком установленые удаленным участниуком, и продолжает принимать м обрабатывать кадры MAX_STREAM_DATA. Конечная точка в состоянии "Send" генерирует кадры STREAM_DATA_BLOCKED, если лимины управления потоком блокируют передачу потока или соединения (Раздел 4.1).
После того, как приложение указало, что все данные потока были переданы и отправлен кадр STRERAM содержащий бит FIN, передающая часть потока переходит в состояние "Data Send". В этом состоянии, конечная точка только повторяет передачу данных если необходимо. Конечная точка не нуждается в проверке лимитов управления потоком или отправки кадров STREAM_DATA_BLOCKED для потока в этом состоянии. Кадры MAX_STREAM_DATA могут приниматься до тех пор пока удаленный участник не примет конец смещения потока. Конечная точка может безопасно игнорировать все MAX_STREAM_DATA кадры полученые от удаленного участника для потока в этом состоянии.
Когда все данные потока успешно подтвердятся, передающая часть потока переходит в состояние "Data Recvd", которое является конечным состоянием.
Для любого состояния "Ready","Send" и "Data Send", приложение может послать сигная с требованием закончить передачи данных. Конечная точка также может принять кадр STOP_SENDING от удаленного участника. В любом случае, конечная точка передает кадр RESET_STREAM, что приводит поток к переходу в сотояние "Reset Send"
Конечная точка МОЖЕТ послать RESET_STREAM в качестве первого кадра упоминаемого в потоке; в этом случае передающая часть открывает поток и немедленно переходит в состояние "Reset Sent".
Когда пакет включает RESET_STREAM успешно подтверждены, передающая часть потока переходит в состояние "Reset Recvd"? кторое является конечным состоянием.

3.2 Состояние потока приема
Рисунок 2 показывает состояния для принимающей части потока от удаленного узла. Принимающая часть отражает только некоторые состояния передающей части удаленного узла. Принимающая часть не отслеживает состояние отправителя которые нельзя наблюдать, такие как состояние "Ready". Вместо этого, принимающая часть отслеживает доставку данных приложению, некоторые из которых не могут быть отслежены отправителем.

          o
          | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM
          | Create Bidirectional Stream (Sending)
          | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)
          | Create Higher-Numbered Stream
          v
      +-------+
      | Recv  | Recv RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Recv STREAM + FIN         |
          v                           |
      +-------+                       |
      | Size  | Recv RESET_STREAM     |
      | Known |---------------------->|
      +-------+                       |
          |                           |
          | Recv All Data             |
          v                           v
      +-------+ Recv RESET_STREAM +-------+
      | Data  |--- (optional) --->| Reset |
      | Recvd |  Recv All Data    | Recvd |
      +-------+<-- (optional) ----+-------+
          |                           |
          | App Read All Data         | App Read RST
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Read  |                   | Read  |
      +-------+                   +-------+

              Рисунок 2: Состояния принимающей частии потокам

Принимающая часть потока инициируемая удаленным узлом (ти 1 и 3 для клиента, 0 и 2 для сервера), создается при получении первого STREAM, STREAM_DATA_BLOCKED или RESET_STREAM. Для двунаправленного потока, инициируемого удаленным узлом, получение кадра MAX_STREAM_DATA или STOP_SENDING также инициирует создание принимающей части. Начальное состояние принимающей части "Recv".
Принимающая часть потока переходит в состояние "Recv" когда отправляющая часть двунаправленного потока, инициируемого конечной точкой (тип 0 для клиента и 1 для сервера), переходит в состояние "Ready".
Конечная точка открывает двунаправленные поток, когда от удаленного узла получен кадр MAX_STREAM_DATA или STOP_SENDING. Получение кадра MAX_STREAM_DATA для неоткрытого потока указывает, что удаленный узел открылл поток и предоставил лимит управления потоком. Получение кадра STOP_SENDING для неоткрытого потока указывает, что удаленный узел больше не желает получать данные в этом потоке. Любой кадр может прибыть до кадра STREAM или STREAM_DATA_BLOCKED? если пакеты потеряны или переупорядочены.
Перед созданием потока ДОЛЖНЫ быть созданы все потоки этого типа с меньшими номерами идентификаторов потоков. Это грантирует, что создание потоков согласованы на обеих конечных точках.
В состоянии "Recv" конечная точка получает кадры STREAM и STREAM_DATA_BLOCKED. Поступающие данные буферизируются и могут быть собраны в правильном порядке для доставки в приложение. Когда данные успользуются приложением и освобождается буферное пространство, конечная точка отправляет MAX_STREAM_DATA, чтобы удаленный узел мог отправлять больше данных.
Когда получен кадр STREAM с битом FIN, то становится известен конечный размер потока (Раздел 4.4). Принимающая часть переходт в состояние "Size Known". В этом состоянии конечной точке не нужно отправлять кадры MAX_STREAM_DATA, jyfона только получает любые переданные в потоке данные.
Как только все данные потока получены, принимающая часть переходит в состояние "Data Recv". Это может произойти при получении того же кадра "STREAM", что вызывает переход в состояние "Size Known". После получения всех данных любые кадры STREAM или STREAM_DATA_BLOCKED для этого потока могут быть отбрашены.
Состояние "Data Recvd" сохраняется до тех пор, пока дыннфе не будут доставлены приложению. Как только данные потока доставлены приложению, поток переходит в конечное состояние "Data Read".
При получении кадра RESET_STREAM в состояниях "Recv" или "Size Known" поток переходит в "Reset Recvd". Это может привести к прерыванию доставки данных в приложение.
Возможно, что все данные потокабудут получены, когда поступил RESET_STREAM(то есть в состоянии "Data Recvd"). Аналогично, оставшиеся данные могут поступить после получения кадра RESET_STREAM(в состоянии Reset Recvd). Выбор как поступить в данной ситуации отдается на усмотрение реализации.
Отправка RESET_STREAM означает, что конечная точка не в состоянии гарантировать доставку данных; однако не требуется что бы данные потока не доставлялись, если получено RESET_STREAM. Реализация МОЖЕТ прервать доставку данных, отбросить все неиспользуемые данные и сигнализировать о получении RESET_STREAM. Сигнал RESET_STREAM может быть подавден или скрыт, есливсе данные потока полностью получены и буферизированы для чтения приложением. Если сигнал RESET_STREAM подавлен, принимающая часть потока остается в состоянии "Data Recvd".
Как только приложение получает сигнал о сбросе потока, принимающая часть переходит в конечное состояние "Reset Read".

3.3 Разрешенные типы кадров.
Отправитель потока отправляет три типа кадров, что влияют на состояние потока отправителя или получателя: STREAM(Раздел 19.8), STREAM_DATA_BLOCKED( Раздел 19.13) и RESET_STREAM(Раздел 19.4).
Отправитель НЕ ДОЛЖЕН отправлять все эти кадры в конечном состоянии("Data Recvd" или "Reset Recvd"). Отправитель НЕ ДОЛЖЕН отправлять STREAM или STREAM_DATA_BLOCKED после отправки RESET_STREAM; то есть, в конечных состояниях или в состоянии "Reset Sent". Получатель может принять любой из трех кадров в любом состоянии, из-за возможности задержки доставки пакетов несущих их.
Получатель отправляет кадры MAX_STREAM_DATA(Раздел 19.10) и STOP_SENDING(Раздел 19.5).
Получатель отправляет MAX_STREAM_DATA только в состоянии "Recv". Получатель может отправить STOP_SENDING в любом состоянии, если не получено RESET_STREAM; то есть в состоянии отличном от "Reset Recvd" или "RESET Read". Однако не имеет значения отправка STOP_SENDING в состоянии "Data Recvd", поскольку все данные потока были получены. Оправитель может принять любой из двух кадров в любом состоянии, из-за отложеной доставки пакетов.

3.4 Состояния двунаправленного потока.
Двунаправленный поток состоит из отпраляющей и принимаюзей части. Реализация может представлять состояния двунаправленного потока как состоящее из состояний отпраляюшей и принимающей части. Простоя модель представляет поток как "open" когда отправляющая и принимающая часть находятся не в конечном состоянии и "closed" когда отправитель и получатель потока находятся в конечном состоянии.
Таблица 2 показывает полную карту состояний двунаправленного потока неполно соответствующею состояниям потока HTTP/2[HTTP2]. Здесь показаны обьединенные состояния отправителя и получателясостоящие из обьединенных состояний. Эта запись одно из возможных отображений; оно требует подтверждение данных до перехода в состоние "closed" или "half-closed".

   +-----------------------+---------------------+---------------------+
   | Sending Part          | Receiving Part      | Composite State     |
   +-----------------------+---------------------+---------------------+
   | No Stream/Ready       | No Stream/Recv *1   | idle                |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Recv/Size Known     | open                |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Data Recvd/Data     | half-closed         |
   |                       | Read                | (remote)            |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Reset Recvd/Reset   | half-closed         |
   |                       | Read                | (remote)            |
   |                       |                     |                     |
   | Data Recvd            | Recv/Size Known     | half-closed (local) |
   |                       |                     |                     |
   | Reset Sent/Reset      | Recv/Size Known     | half-closed (local) |
   | Recvd                 |                     |                     |
   |                       |                     |                     |
   | Reset Sent/Reset      | Data Recvd/Data     | closed              |
   | Recvd                 | Read                |                     |
   |                       |                     |                     |
   | Reset Sent/Reset      | Reset Recvd/Reset   | closed              |
   | Recvd                 | Read                |                     |
   |                       |                     |                     |
   | Data Recvd            | Data Recvd/Data     | closed              |
   |                       | Read                |                     |
   |                       |                     |                     |
   | Data Recvd            | Reset Recvd/Reset   | closed              |
   |                       | Read                |                     |
   +-----------------------+---------------------+---------------------+ 
	Таблица 2: Возможное отображение состояний потока на HTTP/2
   
3.5 Запросы на переход состояний.

Если конечная точка больше не заинтересована в данных которая получает, она МОЖЕТ послать кадр STOP_SENDING для закрытия потока. Обычно это означает, что принимающее приложение больше не читает даннные получаемые в потоке, но не гарантируется, что входящие данные будут игнорироваться.
Кадры STREAM полученые после отправки STOP_SENDING, по прежнему учитываются для соединения и управления потоком, даже если они могут быть отброшены при получении.
Кадр STOP_SENDING запрашивает, что бы принимающая конечная точка отправила кадр RESET_STREAM. Конечная точка принявшая STOP_SENDING, ДОЛЖНА отправить кадр RESET_STREAM, если поток находится в состоянии "Ready" или "Send". Если поток находится в "Data Sent" и все оставшиеся данные обьявляются потеряными, конечной точке СЛЕДУЕТ отправить RESET_STREAM вместо повторной передачи.
Конечной точке СЛЕДУЕТ скопировать код ошибки из кадра STOP_SENDING в кадр RESET_STREAM который она отправляет, но МОЖЕТ использовать любой код ошибки приложения. Конечная точка отправляющая STOP_SENDING МОЖЕТ игнорировать код ошибки содержащийся в любом полученом кадре RESET_STREAM.
Если кадр STOP_SENDING получен в потоке находящимся в состоянии "Data Sent", конечная точка желающая прекратить повторную передачу ранее отправленных кадров STREAM, ДОЛЖНА сначала отправить RESET_STREAM.
STOP_SENDING СЛЕДУЕТ отправлять только для потоков, в состоянии не reset. STOP_SENDING наиболее полезен для потоков в состоянии "Recv" или "Size Known".
Ожидается, что конечная точка отправит еще один STOP_SENDING  если предыдущий пакет содержащий STOP_SENDING был утерян. Однако, как только получены все данные потока или кадр RESET_STREAM, то есть поток находится в состоянии отличном от "Recv" или "Size Known", отправка кадра STOP_SENDING не требуется.
Конечная точка желающая завершить оба направления двунаправленного потока, может завершить одно напрвление отправив RESET_STREAM, и стимулировать быстрое завершение другого направления отправив STOP_SENDING.

4 Контроль потока.
Необходимо ограничивать обьем данных, которое может буфферизировать получяатель, чтобы не дать быстрому отправителю перегрузить медленного получателя или чтобы злонамеренный отправитель не занял большой обьем памяти у получателя. Чтобы позволить получателю ограничить выделение памяти и оказывать давление на отправителя, потоки контролируются как индивидуально так и в совокупности. Получатель QUIC контролирует какой обьем данных может передать отправитель, как описано в Разделе 4.1 и Разделе 4.2.
Аналогично, что бы ограничить параллелизм внутри соединения, конечная точка QUIC контролирует максиматьное число потоков которое может нициировать удаленный узел, как описано в Разделе 4.5.
Жданные отправляемые в кадрах CRYPTO, не подчиняются контролю потока, как данные потока. QUIC полагается на реализацию криптографического протокола, чтобы избежать чрезмерной буферизации данных.(см. [QUIC-TLS]). Реализация ДОЛЖНА предоставить интерфейс для QUIC, сообщающий о его пределах буфферизации, что бы избежать чрезмерной буферизации на нескольких уровнях.

4.1 Управление потоком данных.
QUIC использует схему управления потоком на основе кредитов, аналогичную схеме HTTP\2, где получатель обьявляет количество байтов которое он готов принять в данном потоке и для всего соединения. Это приводит к двум уровням управления потоком в QUIC:
	Управление потоком, предотвращающее использование удним потоком всего буфера приема соединения, путем ограничения обьема данных, которое может быть отпраленно в любом соединении.
	Управление соединением, которое не позволит отправителям превысить емкость буфера получателя для соединения, путем ограничения общего количества байт отправляемых в кажрах STREAM всех потоков.
Получатель установливает начальные лимиты для всех потоков, отправляя параметры во время квитирования (Раздел 7.3). Получатель отправляет отправителю кадры MAX_STREAM_DATA (Раздел 19.10) или MAX_DATA (Раздел 19.9) для установки дополнительных лимитов.
Получатель обьявляет лимит для потока, отправляя кадр MAX_STREAM_DATA с соответствующим образом установленым полем идентификатора потока. Кадр MAX_STREAM_DATA указывает максимальное абсолютное байтовое смещение потока. Приемник используя текущее смещение, определить обьявленный лимит управление потоком. Получатель МОЖЕТ отправалять кадры MAX_STREAM_DATA в нескольких пакетах, чтобы удостоверится, что отправитель получит обновление лимита управления потоком, доже если один из пакетов утерян.
Получатель обьявлет лимит для сединения, отправляя кадр MAX_DATA, который указывает максимум суммы абсолютных смещений всех байтов всех потоков. Приемник сохраняет накопленную сумму байт, полученых во всех потоках, используя ее для проверки нарушения управления потоком. Получатель может использовать сумму байт, полученую во всех потоках, для определения и обьявления максимального предела данных.
Получатель может обьявить большее смещение отправля кадры MAX_STREAM_DATA или MAX_DATA. КАК только получатель обьявил смещение, он МОЖЕТ отправить кадр с меньщим смещением, но это не имеет эффекта.
Получатель ДОЛЖЕН закрыть поток с ошибкой FLOW_CONTROL_ERROR (Раздел 11), если отправитель нарушает лимиты соединения или потока.
Отправитель ДОЛЖЕН игнорировать любые кадры MAX_DATA или MAX_STREAM_DATA которые не увеличивают лимиты управления потоком.
Если отправителю не хватает лимита управления потоком, он не может передавать новые данные и считается заблокированным. Отправителю СЛЕДУЕТ отправить кадр STREAM_DATA_BLOCKED или DATA_BLOCKED, чтобы указать, что у него есть данные для отправки, но он заблокирован ограничениями управления потоком. Ожидается, что эти кадры в обычных случаях будут отправляться нечасто, но они полезны для целей мониторинга и отладки.
Отправителю не следует отправлять несколько кадров STREAM_DATA_BLOCKED или DATA_BLOCKED для одного и того же лимита данных, только если кадр не будет определен как потерянный. Еще один кадр STREAM_DATA_BLOCKED или DATA_BLOCKED может быть отправлен после увеличения лимита данных.
