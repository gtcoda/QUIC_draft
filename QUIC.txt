quic: базирующийся на UDP мультиплексный и безопасный транспортный протокол.

Аннотация
Документ определяющий ядро транспортного протокола QUIC. Сопутствующий документ описывает QUIC детекцию потерь пакетов и контроль переполнения и использования обмена ключей TLS.

Введение
QUIC мультиплексируемый и безопасный транспортный протокол общего назначения и обеспечивает:
мультиплексирование потоков
управление потоком на уровне соединения
малая задержка на установку соединения
миграция соединения и устойчивость к NAT rebinding
аутентификация и шифрования заголовков и полезной нагрузки

Структура документа
Документ описывает ядро протокола QUIC и состоит из следующих частей.
Потоки как базовые абстракции предоставляемые QUIC:
	Раздел 2 описывает основные понятия связанные с потоками.
	Раздел 3 предоставляет базовую модель состояний потоков.
	Раздел 4 основные операции контроля потока.
Соединения - контекст, в котором взаимодействую конечные точки QUIC.
	Раздел 5 описывает основные понятия связанные с соединениями.
	Раздел 6 описывает версии согласования.
	Раздел 7 детальный процесс установки соединения.
	Раздел 8 особенности критических механизмов предотвращения отказов в обслуживании.
	Раздел 9 описывает каким образом конечные точки мигрирую соединения в новом сетевом окружении.
	Раздел 10 список опций для завершения и открытия соединения.
	Раздел 11 предоставляет основное руководство для обработки ошибок.
Пакеты и кадры основные единицы используемы в соединениях QUIC.
	Раздел 12 описывает понятия связанные с пакетами и фреймами.
	Раздел 13 определяет модель для передачи, ретрансляции и подтверждения данных.
	Раздел 14 спецификация правил для управления размером пакета.
Детальная расшифровка элементов протокола QUIC, описывает:
	Раздел 15 версии.
	Раздел 16 целочисленное кодирование.
	Раздел 17 заголовки пакета.
	Раздел 18 транспортные параметры.
	Раздел 19 кадры.
	Раздел 20 ошибки.

Дополнительные документы описывают детектирование потери пакетов и управления перегрузкой (QUIC-RECOVERY) и использование TLS для обмена ключами (QUIC-TLS).

1.2. Термины и определения.

Обычно используемые термины в документе описаны ниже.

QUIC: Транспортный протокол описанный в документе. QUIC это название, a не акроним.
Пакет QUIC: Полноценно обрабатываемая единица QUIC инкапсулированная в UDP датаграмму. Множество пакетов QUIC могут быть инкапсулированы в одну UDP датаграмму.
Конечная точка: субъект, который может участвовать в установлении QUIC соединения, приеме и обработки пакетов. Существуют только два вида конечных точек QUIC: клиент и сервер.
Клиент: конечная точка инициализирующая соединение.
Сервер: конечная точка принимающая входящее QUIC соединение.
ID соединения: непрозрачный идентификатор используемый для идентификации QUIC соединения в конечной точке. Каждая конечная точка устанавливает значения для своего партнера и включает его в пакет отправляемый к конечной точке.
Поток: однонаправленный или двунаправленный канал для обмена байтами в QUIC соединении. QUIC соединение несет множество одновленыенных потоков.
Приложение: объект использующий QUIC для передачи и приема данных.

1.3 national conventions
Диаграммы пакетов и фреймов в этом документе используют формат описанный в Разделе 3.1 RFC2360, с следованием дополнительных соглашений:
[x]: указанный х опционален.
х (А): указанный х длинной А бит.
х (А/В/С): указанный х длинной А, В или С бит.
х (i): указанный х длинной переменное количество бит, расшифровка в Разделе 16.
х (*): указанный х длинной переменное число бит.

2. Потоки
Потоки в QUIC предоставляют легкие, ориентированные на упорядоченный поток байт абстракции для приложений. Потоки могут быть однонаправленные и двунаправленные. Альтернативное представлений однонаправленных потоков в QUIC есть "сообщение" практически неограниченной длинны.
Потоки могут быть созданы для передачи данных. Остальные процессы связанные с управлением потоком - окончание, отмена и управление потоком - разработаны с целью уменьшения накладных расходов. Для примера, одиночный потоковый Кадр  может быть открыт, передать данные и закрыть поток. Потоки могут быть долгоживущими и могут длится все время соединения.
Потоки могут создавать все конечные точки, могут одновременно передавать данные с другими потоками и могут быть отменены. QUIC не обеспечивает порядок байт между разными потоками.
QUIC допускает одновременно произвольное число потоков и передавать произвольное количество данных в любом потоке, с учетом ограничен накладываемых управление потоком(Раздел 4).

2.1 Типы потоков и идентификаторов.
Потоки могут быть однонаправленными и двунаправленными. Однонаправленный поток передает данные только в одном направлении: от инициатора потока к получателю. Двунаправленный поток может передавать данные в обоих направлениях.
Потоки идентифицируются в соединении с помощью цифрового значения, называемым stream ID. stream ID это 62-х битное целое (от 0 до 2^62-1) уникальное для всех потоков данного соединения. stream ID записывается в целое переменой длинны(Раздел 16). Конечная точка QUIC не имеет права переиспользовать stream ID в соединении.
Первый значащий бит (0х1) в stream ID идентифицирует инициатора потока. Инициируемый клиентом поток имеет четный номер(бит установлен в 0), а инициируемый сервером нечетный(бит установлен в 1).
Второй значащий бит (0х2) в stream ID отличает двунаправленный поток(бит установлен в 0) от однонаправленного (бит установлен в 1).
Два первых значащих бита в stream ID идентифицируют поток как один из четырех типов представленных в таблице 1

Биты	Тип потока
0х0		Инициализировано клиентом, Двунаправленный
0х1		Инициализированный сервером, Двунаправленный
0х2		Инициализированный клиентом, Однонаправленный
0х3		Инициализированный сервером, Однонаправленный

Внутри каждого типа, потоки создаются с числовым увеличением stream ID. stream ID, используемый не по порядку, приводит к тому, что будут открыты все потоки с меньшими порядковыми номерами.
Первый двунаправленный поток открываемый клиентом имеет stream ID 0.

2.2 Отправка и прием данных.
Кадр STREAM(Раздел 19.8) инкапсулирует данные отправленные приложением. Конечная точка использует stream ID и поле смещения в кадре STREAM для размещения данных.
Конечная точка может быть в состоянии доставить данные приложению в порядке потока байтов. Доставка потока байтов требует от конечной точки буферизировать любые данные полученные не по порядку, до достижения лимита управления потока.
QUIC не делает никаких специальных указаний для доставки потоком данных не по порядку. Тем не менее, реализация может предлагать возможность доставки приложению данных пришедших не по порядку.
Конечная точка может получать данные для потока с одинаковым смещением несколько раз. Данные которые были уже получены отбрасываются. Данные с данным смещением не могут быть изменены, если они были отправлены несколько раз. Конечная точка может воспринимать получение разных данных с одинаковым смещением в одном потоке как ошибку соединения типа PROTOCOL_VIOLATION.
Потоки - абстракция упорядоченного потока байтов, с не видимой структурой для QUIC. Кадр STREAM не сохраняет границы данных при передаче, ретрансляции потерянного пакета и доставки до приложения на стороне приемника.
Конечная точка не может отправить данные в поток без обеспечения в пределах лимита управления потоком установленным второй стороной. Управление потоком детально описывается в Разделе 4.

2.3 Приоритизация потоков.
Мультиплексирование потоков может оказать существенное влияние на производительность приложений, если ресурсы, выделенные потокам, имеют правильный приоритет.
QUIC не предоставляет механизм для обмена информацией о приоритетах. Вместо этого, полагается на получение информации о приоритетах от приложения использующего QUIC.
Реализация QUIC ДОЛЖНА предоставлять пути которые позволят приложению узнать относительные приоритеты потоков. При решении каким потокам выделять ресурсы, реализация ДОЛЖНА использовать информацию предоставленную приложением.

3. Состояние потоков.
Эта Раздел описывает потоки в терминах компонентов приема и передачи. Описываются два конечных автомата: один для описания передающих потоков конечной точки(Раздел 3.1), другой для принимающих потоков конечной точки(Раздел 3.2).
Однонаправленные потоки используют соответствующий конечный автомат. Двунаправленные потоки используют оба конечных автомата. По большей части использование этих конечных автоматов одинаковое является ли поток однонаправленным или двунаправленным. Условия для открытия двунаправленного потока немного сложнее, потому что, отправляющая и принимающая сторона открывают поток в двух направлениях.
Конечная точка ДОЛЖНА открывать потоки того же типа в порядке возрастания stream ID.
Замечание: Эти состояния являются во многом информативными. Этот документ использует состояния потока для описания правил отправки разных типов кадров, и реакции на получение разных типов кадров. Хотя конечный автомат реализовывать QUIC, эти состояния не должны стеснять реализацию. Реализация может объявлять различные конечные автоматы до тех пор, пока его поведение соответствует реализации, реализующей эти состояния.

3.1 Состояния потока передачи.
На Рисунке 1 показаны состояния передающей части потока отправляющей данные узлу.
          o
          | Create Stream (Sending)
          | Peer Creates Bidirectional Stream
          v
      +-------+
      | Ready | Send RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Send STREAM /             |
          |      STREAM_DATA_BLOCKED  |
          |                           |
          | Peer Creates              |
          |      Bidirectional Stream |
          v                           |
      +-------+                       |
      | Send  | Send RESET_STREAM     |
      |       |---------------------->|
      +-------+                       |
          |                           |
          | Send STREAM + FIN         |
          v                           v
      +-------+                   +-------+
      | Data  | Send RESET_STREAM | Reset |
      | Sent  |------------------>| Sent  |
      +-------+                   +-------+
          |                           |
          | Recv All ACKs             | Recv ACK
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Recvd |                   | Recvd |
      +-------+                   +-------+

Рисунок 1: Состояния передающей части потоков.

Передающая часть потока конечной точки начинает (тип 0 и 2 для клиента, 1 и 3 для сервера) с открывается приложением. Состояние "Ready" представляет собой вновь созданный поток в состоянии принять данные от приложения. Данные потока могут быть помещены в буфер для подготовки к отправлению.
Передав первым кадры STREAM и STREAM_DATA_BLOCKED передающая часть потока входит в состояние "Send". Реализация может отложить выделение stream ID, пока не отправит первый кадр STREAM и войти в это состояние, что позволит лучше использовать приоритезацию потоков.
Передающая часть двунаправленного потока инициированная удаленным узлом(тип 0 для сервера, тип 1 для клиента) входит в состояние "Ready" и немедленно переходит в состояние "Send" если принимающая часть переходит в состояние "Recv" (Раздел 3.2)

В состоянии "Send" конечная точка  передает - и ретранслирует если необходимо, - в потоке кадр STREAM. Конечная точка соблюдает лимиты управления потоком установленные удаленным участником, и продолжает принимать м обрабатывать кадры MAX_STREAM_DATA. Конечная точка в состоянии "Send" генерирует кадры STREAM_DATA_BLOCKED, если лимиты управления потоком блокируют передачу потока или соединения (Раздел 4.1).
После того, как приложение указало, что все данные потока были переданы и отправлен кадр STRERAM содержащий бит FIN, передающая часть потока переходит в состояние "Data Send". В этом состоянии, конечная точка только повторяет передачу данных если необходимо. Конечная точка не нуждается в проверке лимитов управления потоком или отправки кадров STREAM_DATA_BLOCKED для потока в этом состоянии. Кадры MAX_STREAM_DATA могут приниматься до тех пор пока удаленный участник не примет конец смещения потока. Конечная точка может безопасно игнорировать все MAX_STREAM_DATA кадры полученные от удаленного участника для потока в этом состоянии.
Когда все данные потока успешно подтвердятся, передающая часть потока переходит в состояние "Data Recvd", которое является конечным состоянием.
Для любого состояния "Ready","Send" и "Data Send", приложение может послать сигнал с требованием закончить передачи данных. Конечная точка также может принять кадр STOP_SENDING от удаленного участника. В любом случае, конечная точка передает кадр RESET_STREAM, что приводит поток к переходу в состояние "Reset Send"
Конечная точка МОЖЕТ послать RESET_STREAM в качестве первого кадра упоминаемого в потоке; в этом случае передающая часть открывает поток и немедленно переходит в состояние "Reset Sent".
Когда пакет включает RESET_STREAM успешно подтверждены, передающая часть потока переходит в состояние "Reset Recvd", которое является конечным состоянием.

3.2 Состояние потока приема
Рисунок 2 показывает состояния для принимающей части потока от удаленного узла. Принимающая часть отражает только некоторые состояния передающей части удаленного узла. Принимающая часть не отслеживает состояние отправителя которые нельзя наблюдать, такие как состояние "Ready". Вместо этого, принимающая часть отслеживает доставку данных приложению, некоторые из которых не могут быть отслежены отправителем.

          o
          | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM
          | Create Bidirectional Stream (Sending)
          | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)
          | Create Higher-Numbered Stream
          v
      +-------+
      | Recv  | Recv RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Recv STREAM + FIN         |
          v                           |
      +-------+                       |
      | Size  | Recv RESET_STREAM     |
      | Known |---------------------->|
      +-------+                       |
          |                           |
          | Recv All Data             |
          v                           v
      +-------+ Recv RESET_STREAM +-------+
      | Data  |--- (optional) --->| Reset |
      | Recvd |  Recv All Data    | Recvd |
      +-------+<-- (optional) ----+-------+
          |                           |
          | App Read All Data         | App Read RST
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Read  |                   | Read  |
      +-------+                   +-------+

    Рисунок 2: Состояния принимающей части потока

Принимающая часть потока инициируемая удаленным узлом (ти 1 и 3 для клиента, 0 и 2 для сервера), создается при получении первого STREAM, STREAM_DATA_BLOCKED или RESET_STREAM. Для двунаправленного потока, инициируемого удаленным узлом, получение кадра MAX_STREAM_DATA или STOP_SENDING также инициирует создание принимающей части. Начальное состояние принимающей части "Recv".
Принимающая часть потока переходит в состояние "Recv" когда отправляющая часть двунаправленного потока, инициируемого конечной точкой (тип 0 для клиента и 1 для сервера), переходит в состояние "Ready".
Конечная точка открывает двунаправленные поток, когда от удаленного узла получен кадр MAX_STREAM_DATA или STOP_SENDING. Получение кадра MAX_STREAM_DATA для неоткрытого потока указывает, что удаленный узел открыл поток и предоставил лимит управления потоком. Получение кадра STOP_SENDING для неоткрытого потока указывает, что удаленный узел больше не желает получать данные в этом потоке. Любой кадр может прибыть до кадра STREAM или STREAM_DATA_BLOCKED, если пакеты потеряны или переупорядочены.
Перед созданием потока ДОЛЖНЫ быть созданы все потоки этого типа с меньшими номерами идентификаторов потоков. Это гарантирует, что создание потоков согласованы на обеих конечных точках.
В состоянии "Recv" конечная точка получает кадры STREAM и STREAM_DATA_BLOCKED. Поступающие данные буферизируются и могут быть собраны в правильном порядке для доставки в приложение. Когда данные используются приложением и освобождается буферное пространство, конечная точка отправляет MAX_STREAM_DATA, чтобы удаленный узел мог отправлять больше данных.
Когда получен кадр STREAM с битом FIN, то становится известен конечный размер потока (Раздел 4.4). Принимающая часть переходит в состояние "Size Known". В этом состоянии конечной точке не нужно отправлять кадры MAX_STREAM_DATA, jyfjyf только получает любые переданные в потоке данные.
Как только все данные потока получены, принимающая часть переходит в состояние "Data Recv". Это может произойти при получении того же кадра "STREAM", что вызывает переход в состояние "Size Known". После получения всех данных любые кадры STREAM или STREAM_DATA_BLOCKED для этого потока могут быть отброшены.
Состояние "Data Recvd" сохраняется до тех пор, пока данные не будут доставлены приложению. Как только данные потока доставлены приложению, поток переходит в конечное состояние "Data Read".
При получении кадра RESET_STREAM в состояниях "Recv" или "Size Known" поток переходит в "Reset Recvd". Это может привести к прерыванию доставки данных в приложение.
Возможно, что все данные потока будут получены, когда поступил RESET_STREAM(то есть в состоянии "Data Recvd"). Аналогично, оставшиеся данные могут поступить после получения кадра RESET_STREAM(в состоянии Reset Recvd). Выбор как поступить в данной ситуации отдается на усмотрение реализации.
Отправка RESET_STREAM означает, что конечная точка не в состоянии гарантировать доставку данных; однако не требуется что бы данные потока не доставлялись, если получено RESET_STREAM. Реализация МОЖЕТ прервать доставку данных, отбросить все неиспользуемые данные и сигнализировать о получении RESET_STREAM. Сигнал RESET_STREAM может быть подавлен или скрыт, если все данные потока полностью получены и буферизированы для чтения приложением. Если сигнал RESET_STREAM подавлен, принимающая часть потока остается в состоянии "Data Recvd".
Как только приложение получает сигнал о сбросе потока, принимающая часть переходит в конечное состояние "Reset Read".

3.3 Разрешенные типы кадров.
Отправитель потока отправляет три типа кадров, что влияют на состояние потока отправителя или получателя: STREAM(Раздел 19.8), STREAM_DATA_BLOCKED( Раздел 19.13) и RESET_STREAM(Раздел 19.4).
Отправитель НЕ ДОЛЖЕН отправлять все эти кадры в конечном состоянии("Data Recvd" или "Reset Recvd"). Отправитель НЕ ДОЛЖЕН отправлять STREAM или STREAM_DATA_BLOCKED после отправки RESET_STREAM; то есть, в конечных состояниях или в состоянии "Reset Sent". Получатель может принять любой из трех кадров в любом состоянии, из-за возможности задержки доставки пакетов несущих их.
Получатель отправляет кадры MAX_STREAM_DATA(Раздел 19.10) и STOP_SENDING(Раздел 19.5).
Получатель отправляет MAX_STREAM_DATA только в состоянии "Recv". Получатель может отправить STOP_SENDING в любом состоянии, если не получено RESET_STREAM; то есть в состоянии отличном от "Reset Recvd" или "RESET Read". Однако не имеет значения отправка STOP_SENDING в состоянии "Data Recvd", поскольку все данные потока были получены. Отправитель может принять любой из двух кадров в любом состоянии, из-за отложенной доставки пакетов.

3.4 Состояния двунаправленного потока.
Двунаправленный поток состоит из отправляющей и принимающей части. Реализация может представлять состояния двунаправленного потока как состоящее из состояний отправляющей и принимающей части. Простоя модель представляет поток как "open" когда отправляющая и принимающая часть находятся не в конечном состоянии и "closed" когда отправитель и получатель потока находятся в конечном состоянии.
Таблица 2 показывает полную карту состояний двунаправленного потока неполно соответствующею состояниям потока HTTP/2[HTTP2]. Здесь показаны объединенные состояния отправителя и получателя состоящие из объединенных состояний. Эта запись одно из возможных отображений; оно требует подтверждение данных до перехода в состоние "closed" или "half-closed".

   +-----------------------+---------------------+---------------------+
   | Sending Part          | Receiving Part      | Composite State     |
   +-----------------------+---------------------+---------------------+
   | No Stream/Ready       | No Stream/Recv *1   | idle                |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Recv/Size Known     | open                |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Data Recvd/Data     | half-closed         |
   |                       | Read                | (remote)            |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Reset Recvd/Reset   | half-closed         |
   |                       | Read                | (remote)            |
   |                       |                     |                     |
   | Data Recvd            | Recv/Size Known     | half-closed (local) |
   |                       |                     |                     |
   | Reset Sent/Reset      | Recv/Size Known     | half-closed (local) |
   | Recvd                 |                     |                     |
   |                       |                     |                     |
   | Reset Sent/Reset      | Data Recvd/Data     | closed              |
   | Recvd                 | Read                |                     |
   |                       |                     |                     |
   | Reset Sent/Reset      | Reset Recvd/Reset   | closed              |
   | Recvd                 | Read                |                     |
   |                       |                     |                     |
   | Data Recvd            | Data Recvd/Data     | closed              |
   |                       | Read                |                     |
   |                       |                     |                     |
   | Data Recvd            | Reset Recvd/Reset   | closed              |
   |                       | Read                |                     |
   +-----------------------+---------------------+---------------------+
	Таблица 2: Возможное отображение состояний потока на HTTP/2
   
3.5 Запросы на переход состояний.

Если конечная точка больше не заинтересована в данных которая получает, она МОЖЕТ послать кадр STOP_SENDING для закрытия потока. Обычно это означает, что принимающее приложение больше не читает данные получаемые в потоке, но не гарантируется, что входящие данные будут игнорироваться.
Кадры STREAM полученные после отправки STOP_SENDING, по прежнему учитываются для соединения и управления потоком, даже если они могут быть отброшены при получении.
Кадр STOP_SENDING запрашивает, что бы принимающая конечная точка отправила кадр RESET_STREAM. Конечная точка принявшая STOP_SENDING, ДОЛЖНА отправить кадр RESET_STREAM, если поток находится в состоянии "Ready" или "Send". Если поток находится в "Data Sent" и все оставшиеся данные объявляются потерянными, конечной точке СЛЕДУЕТ отправить RESET_STREAM вместо повторной передачи.
Конечной точке СЛЕДУЕТ скопировать код ошибки из кадра STOP_SENDING в кадр RESET_STREAM который она отправляет, но МОЖЕТ использовать любой код ошибки приложения. Конечная точка отправляющая STOP_SENDING МОЖЕТ игнорировать код ошибки содержащийся в любом полученном кадре RESET_STREAM.
Если кадр STOP_SENDING получен в потоке находящимся в состоянии "Data Sent", конечная точка желающая прекратить повторную передачу ранее отправленных кадров STREAM, ДОЛЖНА сначала отправить RESET_STREAM.
STOP_SENDING СЛЕДУЕТ отправлять только для потоков, в состоянии не reset. STOP_SENDING наиболее полезен для потоков в состоянии "Recv" или "Size Known".
Ожидается, что конечная точка отправит еще один STOP_SENDING  если предыдущий пакет содержащий STOP_SENDING был утерян. Однако, как только получены все данные потока или кадр RESET_STREAM, то есть поток находится в состоянии отличном от "Recv" или "Size Known", отправка кадра STOP_SENDING не требуется.
Конечная точка желающая завершить оба направления двунаправленного потока, может завершить одно направление отправив RESET_STREAM, и стимулировать быстрое завершение другого направления отправив STOP_SENDING.

4 Контроль потока.
Необходимо ограничивать объем данных, которое может буферизировать получатель, чтобы не дать быстрому отправителю перегрузить медленного получателя или чтобы злонамеренный отправитель не занял большой объем памяти у получателя. Чтобы позволить получателю ограничить выделение памяти и оказывать давление на отправителя, потоки контролируются как индивидуально так и в совокупности. Получатель QUIC контролирует какой объем данных может передать отправитель, как описано в Разделе 4.1 и Разделе 4.2.
Аналогично, что бы ограничить параллелизм внутри соединения, конечная точка QUIC контролирует максимальное число потоков которое может инициировать удаленный узел, как описано в Разделе 4.5.
Данные отправляемые в кадрах CRYPTO, не подчиняются контролю потока, как данные потока. QUIC полагается на реализацию криптографического протокола, чтобы избежать чрезмерной буферизации данных.(см. [QUIC-TLS]). Реализация ДОЛЖНА предоставить интерфейс для QUIC, сообщающий о его пределах буферизации, что бы избежать чрезмерной буферизации на нескольких уровнях.

4.1 Управление потоком данных.
QUIC использует схему управления потоком на основе кредитов, аналогичную схеме HTTP\2, где получатель объявляет количество байтов которое он готов принять в данном потоке и для всего соединения. Это приводит к двум уровням управления потоком в QUIC:
	Управление потоком, предотвращающее использование одним потоком всего буфера приема соединения, путем ограничения объема данных, которое может быть отправлено в любом соединении.
	Управление соединением, которое не позволит отправителям превысить емкость буфера получателя для соединения, путем ограничения общего количества байт отправляемых в кадрах STREAM всех потоков.
Получатель устанавливает начальные лимиты для всех потоков, отправляя параметры во время квитирования (Раздел 7.3). Получатель отправляет отправителю кадры MAX_STREAM_DATA (Раздел 19.10) или MAX_DATA (Раздел 19.9) для установки дополнительных лимитов.
Получатель объявляет лимит для потока, отправляя кадр MAX_STREAM_DATA с соответствующим образом установленным полем идентификатора потока. Кадр MAX_STREAM_DATA указывает максимальное абсолютное байтовое смещение потока. Приемник используя текущее смещение, определить объявленный лимит управление потоком. Получатель МОЖЕТ отправлять кадры MAX_STREAM_DATA в нескольких пакетах, чтобы удостоверится, что отправитель получит обновление лимита управления потоком, доже если один из пакетов утерян.
Получатель объявляет лимит для соединения, отправляя кадр MAX_DATA, который указывает максимум суммы абсолютных смещений всех байтов всех потоков. Приемник сохраняет накопленную сумму байт, полученных во всех потоках, используя ее для проверки нарушения управления потоком. Получатель может использовать сумму байт, полученную во всех потоках, для определения и объявления максимального предела данных.
Получатель может объявить большее смещение отправляя кадры MAX_STREAM_DATA или MAX_DATA. КАК только получатель объявил смещение, он МОЖЕТ отправить кадр с меньшим смещением, но это не имеет эффекта.
Получатель ДОЛЖЕН закрыть поток с ошибкой FLOW_CONTROL_ERROR (Раздел 11), если отправитель нарушает лимиты соединения или потока.
Отправитель ДОЛЖЕН игнорировать любые кадры MAX_DATA или MAX_STREAM_DATA которые не увеличивают лимиты управления потоком.
Если отправителю не хватает лимита управления потоком, он не может передавать новые данные и считается заблокированным. Отправителю СЛЕДУЕТ отправить кадр STREAM_DATA_BLOCKED или DATA_BLOCKED, чтобы указать, что у него есть данные для отправки, но он заблокирован ограничениями управления потоком. Ожидается, что эти кадры в обычных случаях будут отправляться нечасто, но они полезны для целей мониторинга и отладки.
Отправителю не следует отправлять несколько кадров STREAM_DATA_BLOCKED или DATA_BLOCKED для одного и того же лимита данных, только если кадр не будет определен как потерянный. Еще один кадр STREAM_DATA_BLOCKED или DATA_BLOCKED может быть отправлен после увеличения лимита данных.

4.2 Увеличение лимита управления потоком.
Этот документ оставляет на усмотрение реализации когда и сколько байт обьявлять в кадрах MAX_STREAM_DATA или MAX_DATA, но предлагает несколько соображений. Эти кадры привносят издержки в соединение. Поэтому нежелательна частая отправка кадров с небольшими изменениями. В то же время необходимы большие приращения лимитов, чтобы избежать блокировок, если обновление выполняется редко, что в сою очередь требует наличия больших ресурсов у получателя. Таким образом, следует искать компромисс между выделение ресурсов и накладными расходами при определении лимита управляя потоком.
Приемник может использовать автоматический механизм настройки частоты и размера объявленного добавления лимита на основе оценки времени круговой задержки и скорости, ч какой принимающее приложение потребляет данные, аналогично обычным реализациям TCP. В качестве оптимизации, отправка кадров связанных с управление потоком, осуществляется только тогда, когда есть другие кадры для отправки или когда удаленный узел заблокирован. Это гарантирует, что управление потоком не вызовет отправку дополнительных пакетов.
Если отправителю не хватает лимита управления потоком, он не сможет передавать новые данные и считается заблокированным. Обычно считается, что отправитель не должен блокироваться. Чтобы избежать блокировки отправителя и учесть возможность потери кадров, получатель должен отправить кадр MAX_DATA или MAX_STREAM_DATA минимум за два RTT, до ожидаемого момента блокировки.
Получатель НЕ ДОЛЖЕН дожидаться STREAM_DATA_BLOCKED или DATA_BLOCKED перед отправкой MAX_STREAM_DATA или MAX_DATA, так как это означает, что отправитель будет заблокирован, по крайней мере на один цикл RTT, и возможно на более длительный срок, если партнер решит не отправлять STREAM_DATA_BLOCKED или DATA_BLOCKED.

4.3 Обработка отмены потока.
Конечные точки должны в конечном итоге договорится о сумме лимитов, который будет использоваться, чтобы избежать превышения лимитов или взаимоблокировки.
После получения RESET_STREAM конечная точка завершает работу для соответствующего потока и игнорирует другие данные поступающее в этот поток. Без смещения включенного в RESET_STREAM, количество байт которое учитывается при управлении потоком может не совпадать.
Чтобы устранить эту проблему кадр RESET_STREAM(Раздел 19.4) включает в себя окончательный размер данных передаваемый в потоке. Получив кадр RESET_STREAM получатель точно знает сколько байт было отправлено в этом потоке до кадра RESET_STREAM. Получатель ДОЛЖЕН использовать окончательный размер потока, для учета всех отправленных байт, в управлении потоком уровня соединения. 
RESET_STREAM завершает одно направление потока. Для двунаправленного потока RESET_STREAM не влияет на поток в противоположном направлении. Обе конечные точки ДОЛЖНЫ поддерживать состояние управления потоком для потока в незавершенном направлении, пока это направление не завершится или одна из конечных точек не отправит кадр CONNECTION_CLOSE.

4.4 Окончательный размер потока.
Окончательный размер это сумма лимита управления потоком.  Если предположить, что каждый байт в потоке был отправлен один раз, то окончательный размер равен количеству отправленных байт. В более общем случае, ky равен на единицу больше, чем смещение последнего байта отправленного в потоке или ноль, если не было ни одного байта.
Для потока в состоянии RESET окончательный размер явно берется из кадра RESET_STREAM. В противном случае окончательный размер это всещение плюс длинна кадра STREAM с флагом FIN, или 0 в случае входящих однонаправленных потоков.
Конечная точка будет знать окончательный размер потока, когда принимающая часть перейдет в состояние "Size Known" или "Reset Recvd" (Раздел 3).
Конечная точка НЕ ДОЛЖНА отправлять данные в поток за пределами конечного размера.
Как только окончательный размер потока известен, он не может изменится. Если получен кадр RESET_STREAM или STREAM, указывающий на изменение конечного размера, конечная точка ДОЛЖНА ответить ошибкой FINAL_SIZE_ERROR (Раздел 11). Получателю СЛЕДУЕТ обработать получение данных окончательного размера или за его пределами как ошибку FINAL_SIZE_ERROR даже после закрытия потока. Генерирование этих ошибок не является обязательным, только потому, что требуются ресурсы, чтобы конечная точка должна поддерживать состояние финального размера для закрытых потоков.

4.5 Контроль согласованности.
Конечная точка ограничивает общее количество входящих потоков, которое может открыть удаленный узел. Открыты могут быть только потоки с идентификатором меньше чем (max_stream * 4 + initial_stream_id_for_type)(Таблица 5). Начальные ограничения устанавливаются транспортными параметрами (Раздел 18.1), а затем объявляются с использованием кадров MAX_STREAMS(раздел 19.11). Отдельные ограничения для однонаправленных и двунаправленных потоков.
Если транспортный параметр max_stream или кадр MAX_STREAMS получен со значением превышающем 2^60, что является максимальным идентификатором, который может быть выражен целым числом переменной длинны. (Раздел 16). Если такой идентификатор получен соединение ДОЛЖНО быть немедленно закрыто с ошибкой STREAM_LIMIT_ERROR (Раздел 10.3)
Конечные точки НЕ ДОЛЖНЫ превышать ограничения установленные удаленными узлами. Конечная точка получившая кадр с идентификатором потока превышающем установленный ею лимит, ДОЛЖНА трактовать это как ошибку соединения типа STREAM_LIMIT_ERROR (Раздел 11).
Как только получатель объявляет ограничение потока с помощью кадра MAX_STREAMS, объявление меньшего ограничения не имеет никакого эффекта. Приемник ДОЛЖЕН игнорировать любой кадр  MAX_STREAMS, который не увеличивает лимит.
Этот документ оставляет выбор реализации когда и сколько открывать потоков через MAX_STREAMS. Реализация может увеличивать предел по мере того, как потоки закрываются, чтобы количество потоков для удаленного узла было примерно одинаковым.
Конечная точка, которая не может открыть новый поток из-за ограничения, ДОЛЖНА отправить кадр STREAMS_BLOCKED (Раздел 19.14) Этот сигнал считается полезным для отладки. Конечная точка НЕ ДОЛЖНА ждать получения этого сигнал, прежде чем увеличить лимит. Поскольку это означает, что удаленный узел будет заблокирован, по крайней мере на один цикл RTT, и возможно на более длительный срок, если удаленный узел решит не отправлять кадр STREAMS_BLOCKED.

5. Соединения
QUIC соединение сочетает согласование версии с криптографическим и транспортным рукопожатием для уменьшение задержки установки соединения, как описано в Разделе 7. После установления соединения конечная точка может менять IP или порт, как описано в разделе 9. Соединение может быть прервано любой конечной точкой, как описано в разделе 10.

5.1 ID соединения.
Каждое соединение обладает набором идентификаторов, или ID соединения, каждый из которых может идентифицировать соединение. Идентификаторы независимо выбираются двумя конечными точками, каждая конечная точка выбирает идентификаторы соединения которые использует удаленный узел.
Основная функция ID соединения заключается в обеспечении того, чтобы изменение на более низких уровнях протокола(UDP, IP) не приводили к доставке пакетов соединения QUIC в неправильную конечную точку. Каждая конечная точка выбирает идентификаторы соединения, используя метод специфичный для реализации, который позволит маршрутизировать пакеты с этим идентификатор обратно к конечной точке и идентифицировать конечную точку при получении.
ID соединения НЕ ДОЛЖНЫ содержать информацию, которая может использоваться внешним наблюдателем для сопоставления их с другими ID соединения этого же соединения. В качестве тривиального примера, один и то же ID НЕ ДОЛЖЕН выдаваться более одного раза для одного и того же соединения.
Пакеты с длинными заголовками включают поля "Sourse Connection ID" и "Destination Connection ID". Эти поля используются для установки идентификаторов новых соединений, см Раздел 7.2.
Пакеты с короткими заголовками(Раздел 17.3) включают только "Destination Connection ID" и явно опускают длину. Ожидается, что длинна поля "Destination Connection ID" известна конечным точкам. Конечные точки, использующие балансировщик нагрузки маршрутизирующий на основе ID соединения, могут согласовать с балансировщиком фиксированную длину идентификатора, или согласовать схему кодирования.
В пакете Согласования (Раздел 17.2.1), повторяются идентификаторы соединения выбранные клиентом, чтобы гарантировать правильность маршрутизации к клиенту и позволит ему проверить, что данный пакет является ответом на начальный пакет.
ID соединения нулевой длинны МОЖЕТ использоваться, когда ID соединения не нужен для маршрутизации, а набор адрес/порт пакета достаточно для идентификации. Конечная точка, чей удаленный узел выбрал ID нулевой длинны, ДОЛЖНА продолжать использовать такой ID в течении всего времени существования соединения, и НЕ ДОЛЖНА отправлять пакеты с любого другого локального адреса.
Когда конечная точка запросила ID ненулевой длинны, она должна убедится, что удаленный узел имеет запас идентификаторов соединения, из которого можно выбрать пакеты для отправки конечной точке. Эти ID предоставляются конечной точкой с использованием кадра NEW_CONNECTION_ID (Раздел 19.15)

5.1.1 Выдача идентификаторов соединений.
Каждый ID имеет связанный порядковый номер помогающий в дедупликации сообщений. Начальный ID, выданный конечной точкой, отправляется в поле Sourse Connection ID длинного заголовка пакета (Раздел 17.2) во время квитирования. Порядковый номер исходного идентификатора равен 0. Если передан транспортный параметр preferred_address, прядкой номер предоставляемого идентификатора равен 1.
Дополнительные идентификаторы передаются удаленному узлу с помощью кадров NEW_CONNECTION_ID (Раздел 19.15). Порядковый номер каждого вновь выданного соединения ДОЛЖЕН увеличиваться на 1. ID, произвольно выбранный клиентом в исходном пакете, и любой идентификатор предоставленный пакетом Retry, не являются назначенными порядковыми номерами, только если сервер не решит сохранить их в качестве своего начального ID.
Когда конечная точка выдала ID, она ДОЛЖНА принимать все пакеты с этим ID на все время соединения или до тех пор, пока удаленный узел не сделает этот ID недействительным по средствам кадра RETIRE_CONNECTION_ID (Раздел 19.16).
Конечной точке СЛЕДУЕТ гарантировать, что удаленный узел имеет достаточное количество доступных и неиспользованный ID. Конечные точки хранят полученные идентификаторы для будущего использования и объявляют номера ID которые они готовы хранить с помощью транспортного параметра active_connection_id_limit. Конечной точке НЕ СЛЕДУЕТ представлять больше ID чем ограничение удаленного узла.
Конечной точке СЛЕДУЕТ предоставить новый идентификатор соединения, когда она получает пакет с ранее неиспользуемым ID или когда удаленный узел удаляет его, если только предоставление нового ID не превысит лимит установленный удаленным узлом. Конечная точка МОЖЕТ ограничить частоту и общее количество ID, cjolfdftvs[ для каждого соединения, чтобы избежать риска исчерпания идентификаторов соединения (Раздел 10.4.2)
Конечная точка, инициирующая миграцию и требующая идентификаторов ненулевой длинны, ДОЛЖНА гарантировать, что пул ID доступных удаленному узлу, позволит использовать новый ID при миграции, в противном случае, при исчерпании пула, соединение будет закрыто.

5.1.2 Использование и удаление идентификаторов соединения.
Конечная точка может изменить ID соединения, который она использует для удаленного узла, в любой момент соединения. Конечная точка использует ID в ответ на миграцию удаленного узла. (Раздел 9.5).
Конечная точка поддерживает набор идентификаторов, полученных от удаленного узла, любой из которых может использоваться при отправке пакетов. Когда конечная точка желает удалить идентификатор из списка используемых, она отправляет кадр RETIRE_CONNECTION_ID. Отправка кадра RETIRE_CONNECTION_ID указывает, что ID соединения больше не будет использоваться, и запрашивает, чтобы удаленный узел заменил его новым используя NEW_CONNECTION_ID.
Из обсуждения в Разделе 9.5, каждый идентификатор ДОЛЖЕН использоваться в пакетах, отправляемых ьлдбко с одного локального адреса. Конечной точке, которая мигрирует с локального адреса, СЛЕДУЕТ удалить идентификаторы, используемые для этого адреса, если она не планирует больше использовать этот адрес.
Конечная точка может запросить удаленный узел удалить ID соединения отправлением кадра NEW_CONNECTION_ID с увеличением поля "Retire Prior To". После получения удаленный узел ДОЛЖЕН удалить соответствующие идентификаторы соединения и своевременно отправить соответствующие карды RETIRE_CONNECTION_ID. Невыполнение этого требования может привести к задержкам, потерям пакетов или к тому, что исходная конечная точка отправит сброс в ответ на идентификатор, который она не может правильно маршрутизировать.
Конечная точка МОЖЕТ отбросить ID, для которого запрошено удаление, по истечению не менее 3 PTO с момента получения подтверждения для кадра NEW_CONNECTION_ID, запросившего такое удаление. Последующие входящие пакеты использующие этот ID, могут вызвать токеном сброса.

5.2 Сопоставление пакетов с соединением
Входящие пакеты классифицируются при получении. Пакеты могут быть связаны с существующим соединением или, для серверов, потенциально создавать новое соединение.
Хосты пытаются связать пакеты с существующим соединением. Если пакет имеет Destination Connection ID, соответствующий существующему соединению, QUIC обрабатывает этот пакет соответствующим образом. Обратите внимание, что с соединением может быть связано больше одного соединения, см Раздел 5.1.
Если Destination Connection ID имеет нулевую длину и пакет соответствует набору адрес\порт соединения, для которого хосту не требовалось ID, QUIC обработает пакет как часть этого соединения. Конечные точки ДОЛЖНЫ либо отклонять попытки соединения, которые используют те же адреса, что и существующие соединения, либо использовать Destination Connection ID ненулевой длинны, чтобы пакеты могли быть правильно отнесены к соединениям.
Конечные точки могут отправлять сброс без сохранения состояния (Раздел 10.4) для любых пакетов, которые нельзя отнести к существующему соединению. Сброс без сохранения состояния позволяет удаленному узлу быстрее определить, что соединение становится непригодным для использования.
Пакеты, которые соответствуют существующему состоянию, отбрасываются, если эти пакеты не соответствуют состоянию этого соединения. Например, пакеты отбрасываются, если они указывают версию протокола, отличную от версии соединения. Или если расшифровка пакета не удалась, несмотря на наличие ожидаемых ключей.
Неверные пакеты без шифрования, такие как Initial, Retry или Version Negitiation, МОГУТ быть отброшены. Конечная точка ДОЛЖНА генерировать ошибку соединения, если она фиксирует изменение состояния до обнаружения ошибки.

5.2.1 Обработка пакетов клиентом
Правильные пакеты, отправляемые клиентом, всегда содержат Destination Connection ID который соответствует значению выбранному клиентом. Клиенты, которые выбирают получение ID нулевой длинны, могут использовать набор адрес\порт для идентификации соединения. Пакеты которые не соответствуют существующему соединению отбрасываются.
Из-за переупорядочивания или потери пакетов клиент может получить пакеты зашифрованные с помощью ключа, который он еще не вычислил. Клиент МОЖЕТ отбросить эти пакеты или МОЖЕТ буферизировать их в ожидании более поздних пакетов позволяющих вычислить ключ.
Если клиент получает пакет с неподдерживаемой версией он ДОЛЖЕН отбросить пакет.

5.2.2 Обработка пакетов сервером
Если сервер получает пакет неподдерживаемой версии, но пакет достаточен для того, чтобы инициализировать новое соединение для любой версии поддерживаемой сервером, он ДОЛЖЕН отправить пакет согласования версии, как описано в разделе 6.1. Серверы МОГУТ контролировать эти пакеты, чтобы избежать пакетных штормов. В противном случае серверы ДОЛЖНЫ отбрасывать пакеты, которые указывают неподдерживаемые версии.
Первый пакет неподдерживаемой версии может использовать различную семантику и кодирование для любого поля, зависящего от версии. В частности, от версии могут различаться ключи шифрования пакетов. Серверы, не поддерживающие конкретную версию, вряд ли смогут расшифровать содержимое пакета. Серверы НЕ ДОЛЖНЫ пытаться декодировать или дешифровывать пакет неизвестной версии, но вместо этого отправляют пакет согласования версий при условии, что пакет достаточно длинный.
Пакеты поддерживаемой версии или без поля версии сопоставляются соединению, используя ID или - для пакетов с ID нулевой длинный - набор адрес\порт. Если пакет не соответствует соединению, сервер продолжает работать с ним как описано ниже.
Если пакет является Начальным и полностью соответствует спецификации, сервер продолжает рукопожатие. Сервер фиксирует версию, которую выбрал клиент.
Если сервер не принимает новые соединения, он ДОЛЖЕН отправить исходный пакет содержащий кадр CONNECTION_CLOSE с кодом ошибки SERVER_BUSY.
Если полученный пакет является 0-RTT, сервер МОЖЕТ буферизировать ограниченное число пакетов в ожидании запоздавшего Начального пакета. Клиенты не могут отправлять пакеты для рукопожатия до получения ответа сервера, поэтому сервер ДОЛЖЕН игнорировать любые такие пакеты.
Серверы ДОЛЖНЫ отбрасывать входящие пакеты при любых других обстоятельствах.

5.3 Срок жизни QUIC соединения.
Подлежит определению.

6. Согласование версий.
Согласование версий гарантирует, что клиент и сервер согласятся на взаимно поддерживаемую версию QUIC. Сервер отправляет пакет согласования в ответ на каждый пакет, который может инициировать соединение (Раздел 5.2)
Размер первого пакета отправленного клиентом, определяет отправляет ли сервер пакет согласования версий. Клиенты, поддерживающие несколько версий QUIC, ДОЛЖНЫ дополнять первый отправляемый пакет наибольшим из минимальных размеров пакетов во всех версиях которые они поддерживают. Это гарантирует, что сервер ответит, если существует взаимоподдерживаемая версия.

6.1 Отправка пакета согласования версий.
Если выбранная клиентом версия неприемлема для сервера, он отвечает пакетом согласования версий (Раздел 17.2.1). Он включает в себя список поддерживаемых сервером версий. Конечная точка НЕ ДОЛЖНА отвечать пакетом согласования на пакет согласования.
Такая система позволяет серверу обрабатывать пакеты с неподдерживаемой версией без сохранения состояния. Несмотря на то, что исходный пакет или пакет согласования версий может быть потерян, клиент будет отправлять новые пакеты до тех пор пока не получит ответ или не откажется от попытки подключения. В результате клиент сбрасывает все состояния подключения и не отправляет больше пакетов на соединение.
Сервер МОЖЕТ ограничить количество отправляемых пакетов согласования версий. Например, сервер который может распознавать 0-RTT  пакеты, может предпочесть не отправлять пакеты согласования версий в ответ на такие пакеты, ожидая получить в конечном итоге начальный пакет.

6.2 Обработка пакета согласования версий.
Когда клиент получает пакет согласования версий, он ДОЛЖЕН отказаться от текущей попытки подключения. Пакеты согласования версий предназначены для возможности будущий версий QUIC согласовывать используемые версии между конечными точками. Будущие версии QUIC могут изменить реализацию реагирования на пакеты согласования версий данной версии. Определение реализации согласования версий оставляется для будущий версий QUIC. В частности, будущие реализации должны обеспечить устойчивость к атакам понижения версии (Раздел 21.9).

6.3 Использование зарезервированных версий.
Для того, чтобы сервер мог использовать в будущем новую версию, клиенты должны правильно обрабатывать неподдерживаемые версии. Чтобы гарантировать это, сервер ДОЛЖЕН включать версию, зарезервированную для принудительного согласования версий(0x?a?a?a?a, как определено в Разделе 15), при генерации пакета согласования версии.
Такая конструкция согласования версий позволяет сервера избегать сохранения состояния для отклоненных таким образом пакетов.
Клиент МОЖЕТ отправить пакет, используя зарезервированную версию. Это может использоваться для получения от сервера списка поддерживаемых версий.

7. Криптографическое и транспортное рукопожатие.
QUIC использует комбинированное криптографическое и транспортное рукопожатие для минимизации задержки установления соединения. QUIC использует кадр CRYPTO (Раздел 19.6) для передачи криптографического рукопожатия. Версия 0x00000001  QUIC использует TLS[QUIC-TLS]. Другой номер версии QUIC может указывать на использование другого криптографического протокола.
QUIC обеспечивает надежную, упорядоченную доставку данных криптографического рукопожатия. Защита пакетов QUIC используется для шифрования как можно больше части протокола рукопожатия. Криптографическое рукопожатие ДОЛЖНО обеспечивать следующие свойства:
o аутентифицированный обмен ключами, где
	* сервер всегда аутентифицирован,
	* клиент может быть дополнительно аутентифицирован,
	* каждое соединение создает отдельные и несвязанные ключи,
	* ключевой материал пригоден для защиты пакетов 0-RTT, 1-RTT и т.д.
	* ключи 1-RTT имеют прямую секретность.
o аутентифицирование значения для транспортных параметров удаленного узла (Раздел 7.3)
o аутентифицируемое согласование протокола приложения (для этой цели TLS использует ALPN[RFC7301])
Первый кадр CRYPTO  от клиента ДОЛЖЕН быть отправлен в одном пакете. Любая другая попытка инициировать проверку адреса (Раздел 8.1) ДОЛЖНА также отправляется в одном пакете. Это позволяет избежать сборки сообщения из нескольких пакетов.
Первый клиентский пакет протокола криптографического квитирования ДОЛЖЕН уместится в полезную нагрузку 1232-байтного пакета QUIC. Эта нагрузка включает в себя служебные данные уменьшающие пространство доступное для протокола криптографического квитирования.
Конечная точка может проверить поддержку явного уведомления о перегрузке (ECN) в первых отправленных ей пакетах(Раздел 13.3.2).
Кадр CRYPTO может быть отправлен в разных пространствах номеров пакетов. Порядковые номера используемые кадрами CRYPTO для обеспечения упорядоченной доставки данных рукопожатия, начинаются с нуля в каждом пространстве пакетов.
Конечные точки ДОЛЖНЫ явно согласовать протоком приложения. Это позволит избежать разногласия по поводу используемого протокола.

7.1 Пример рукопожатия.
Подробная информация о том как ЕДЫ интегрирован в QUIC представлена в [QUIC-TLS], но некоторые примеры приведены здесь. Расширение этого обмена для поддержки проверки адреса клиента показано в разделе 8.1.1.
После завершения любой проверки адресов, криптографическое подтверждение используется для согласования криптографических ключей. Криптографическое рукопожатие передается в пакетах Initial (Раздел 17.2.2) и Handshake (раздел 17.2.4).
На рисунке 3 представлен обзор рукопожатия 1-RTT. Каждая строка показывает пакет QUIC с типом и номером от начала, и сопровождаемыми кадрами которые обычно содержаться в этом пакете. Например, первый кадр имеет тип Initial с номером 0 и содержит кадр CRYPTO переносящий ClientHello.
Обратите внимание, что несколько пакетов, даже с разными уровнями шифрования, могут быть объединены в одну дейтаграмму UDP (Раздел 12.2). Поэтому, рукопожатие может состоять всего из 4 дейтаграмм UDP или любого другого числа. Например, первый ответ сервера содержит пакеты с начального уровня шифрования(обфускации), уровня рукопожатия и уровня 1-RTT с данными "0,5-RTT".
   Client                                                  Server

   Initial[0]: CRYPTO[CH] ->

                                    Initial[0]: CRYPTO[SH] ACK[0]
                          Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                    <- 1-RTT[0]: STREAM[1, "..."]

   Initial[1]: ACK[0]
   Handshake[0]: CRYPTO[FIN], ACK[0]
   1-RTT[0]: STREAM[0, "..."], ACK[0] ->

                               1-RTT[1]: STREAM[3, "..."], ACK[0]
                                          <- Handshake[1]: ACK[0]

 Figure 3: Пример 1-RTT Handshake

На рисунке 4 представлен пример соединения с рукопожатием 0-RTT и одним пакетом данных 0-RTT. Обратите внимание, как описано в разделе 12.3, сервер подтверждает данные 0-RTT на уровне шифрования 1-RTT и клиент отправляет пакеты 1-RTT в том же пространстве номеров пакетов.
   Client                                                  Server

   Initial[0]: CRYPTO[CH]
   0-RTT[0]: STREAM[0, "..."] ->

                                    Initial[0]: CRYPTO[SH] ACK[0]
                                     Handshake[0] CRYPTO[EE, FIN]
                             <- 1-RTT[0]: STREAM[1, "..."] ACK[0]

   Initial[1]: ACK[0]
   Handshake[0]: CRYPTO[FIN], ACK[0]
   1-RTT[1]: STREAM[0, "..."] ACK[0] ->

                               1-RTT[1]: STREAM[3, "..."], ACK[1]
                                          <- Handshake[1]: ACK[0]

 Figure 4: Пример 0-RTT Handshake
					 
7.2 Согласование идентификаторов соединения.
Идентификатор соединения используется для обеспечения согласованной маршрутизации пакетов, как описано в разделе 5.1. Длинный заголовок содержит два идентификатора соединения:
Destination Connection ID(DCID) - выбирается получателем пакета и используется для согласованной маршрутизации;
Source Connection ID(SCID) - используется для установки DCID используемого удаленным узлом.
Во время рукопожатия используются пакеты с длинными заголовка для установления идентификатора соединения, который использует каждая конечная точка. Каждая конечная точка использует поле SCID для указания DCID который используется для отправки им пакетов. После получения пакета каждая конечная точка устанавливает DCID для отправки, чтобы соответствовать SCID для получения.
Когда пакет Initial отправляется клиентом, который ранее не получал пакет Initial или Retry от сервера, он заполняет поле DCID случайным значением. Это значение ДОЛЖНО быть длиной не менее 8 байт. Пока от сервера не получен пакет, клиент ДОЛЖЕН использовать одно и то же значение, если только он не откажется от попытки соединения и не начнет новое. Исходный DCID используется для выработки защитных ключей для Initial пакетов.
Клиент заполняет поле SCID значение по своему выбору и устанавливает поле SCID Len для указания длины. В первой фазе пакеты 0-RTT используют те же значения DCID и SCID что и первый Initial пакет.
При первом получении пакета Initial или Retry от сервера клиент использует SCID предоставленный сервером в качестве DCID для последующих пакетов, включая любые последующие пакеты 0-RTT. Это означает, что клиент может изменить DCID дважды во время установления соединения, один раз в ответ на Retry и один раз во время получения Initial пакета от сервера. Как только клиент получил Initial пакет от сервера, он ДОЛЖЕН отбрасывать любой пакет, который он получает с другим SCID.
Клиент ДОЛЖЕН изменить только значение отправляемое в DCID в ответ на первый пакет любого типа полученного от сервера (Retry или Initial). Сервер ДОЛЖЕН установить свое значение DCID на основе начального пакета от клиента. Любые дополнительные изменения не допускаются, если последующие пакеты этих типов включают в себя другой SCID они ДОЛЖНЫ быть отброшены. Это позволяет избежать проблем которые могут возникнуть в результате обработки множества Initial пакетов с разными идентификаторами соединений.
Идентификатор соединения может изменяться в течении срока жизни соединения, особенно в ответ на миграцию (Раздел 9. Раздел 5.1.1).

7.3 Транспортные параметры.
Во время установки соединения обе конечные точки делают аутентифицированные декларации своих транспортных параметров. Эти декларации делаются каждой конечной точкой в одностороннем порядке. Конечные точки должны соответствовать ограничениям, налагаемыми этими параметрами. Описание параметра включает в себя правила его обработки.
Кодирование транспортных параметров подробно описано в Разделе 18.
QUIC включает закодированные транспортные параметры в криптографическое рукопожатие. Как только рукопожатие завершается, становятся доступны транспортные параметры объявленные узлом. Каждая конечная точка проверяет предоставленные узлом транспортные параметры.
Определения для каждого определенного параметра включены в Раздел 18.1.
Конечная точка ДОЛЖНА трактовать получение транспортного параметра с недопустимым значением как ошибку соединения типа TRANSPORT_PARAMETER_ERROR.
Сервер ДОЛЖЕН включить транспортный параметр original_connection_id (Раздел 18.1), если он отправляет пакет Retry, чтобы включить проверку Retry, как описано в Разделе 17.2.5.

7.3.1 Значения транспортного параметра для 0-RTT.
Обе конечные точки хранят значения транспортных параметров сервера из соединения и применяют их ко всем 0-RTT пакетам которые отправляются этому узлу, за исключением явно исключенных параметров. Сохраненные транспортные параметры применяются к новому соединению до тех пор, пока рукопожатие не завершится, и клиент не начнет отправлять 1-RTT пакеты. Как только рукопожатие завершается, клиент использует транспортные параметры установленные в рукопожатии.
Определение новых транспортных параметров (Раздел 7.3.2) ДОЛЖНО указывать ДОЛЖНЫ, МОГУТ или НЕ ДОЛЖНЫ сохранятся для 0-RTT. Клиенты не нужно хранить транспортный параметр который он не может обработать.
Клиент НЕ ДОЛЖЕН использовать сохранение значений для следующих параметров: original_connection_id, preferred_address, stateless_reset_token, ack_delay_exponent и active_connection_id_limit. Вместо этого клиент ДОЛЖЕН использовать новые серверные значения в рукопожатии, а если они отсутствуют, то значения по умолчанию.
Клиент который пытается отправить значения 0-RTT ДОЛЖЕН помнить все другие транспортные параметры используемые сервером. Сервер может запомнить эти транспортные параметры или сохранить integrity-protected копию значений в ticket и восстановить информацию при приеме пакета 0-RTT. Сервер использует транспортные параметры при определении принимать или нет 0-RTT данные.
Если сервер принимает данные 0-RTT он НЕ ДОЛЖЕН уменьшать какие либо лимиты или изменять другие значения, которые могут быть не согласованы с клиентскими данными 0-RTT. В частности, сервер которые принимает данные 0-RTT НЕ ДОЛЖЕН устанавливать значения меньше чем запомненные для следующих параметров (Раздел 18.1):
initial_max_data
initial_max_stream_data_bidi_local
initial_max_stream_data_bidi_remote
initial_max_stream_data_uni
initial_max_streams_bidi
initial_max_streams_uni
Пропуск или установка нулевого значения транспортных параметром может привести к тому, что данные 0-RTT будут включены, но не будут использоваться. Подмножество транспортных параметров разрешающих отправку данных приложения ДОЛЖНЫ быть установлены в ненулевое значение для 0-RTT. Включая параметры initial_max_data и initial_max_streams_bidi и initial_max_stream_data_bidi_remote или initial_max_streams_uni и initial_max_stream_data_uni.
Сервер ДОЛЖЕН отклонить данные 0-RTT или прервать квитирование, если не поддерживаются подразумеваемые значения для транспортных параметров.
При отправке кадров в 0-RTT пакетах клиент ДОЛЖЕН использовать только запомненные транспортные параметры. Важно, клиент НЕ ДОЛЖЕН использовать обновленные значения параметров, извлекаемые из обновленных транспортных параметров сервера или кадров 1-RTT. Обновленные транспортные параметры полученные в ходе рукопожатия применяются только к пакетам 1-RTT. Например, лимиты управления потоком применяются из запомненных транспортных параметров применяются ко всем пакетам 0-RTT, даже если эти значения увеличены при рукопожатии или в пакетах 1-RTT. Сервер МОЖЕТ рассматривать использование обновленных параметров в пакетах 0-RTT как ошибку соединения типа PROTOCOL_VIOLATION.

7.3.2 Новые транспортные параметры.
Новые транспортные параметры могут использоваться для согласования нового поведения протокола. Конечная точка ДОЛЖНА игнорировать неподдерживаемые транспортные параметры. Отсутствие транспортного параметра отключает необязательную функцию протокола использующую этот параметр.
Новые транспортные параметры могут быть зарегистрированы в соответствии с правилами описанными в Разделе 22.1

7.4 Буферизация криптографических сообщений
Реализации должны поддерживать буферизацию полученных не по-порядку данных CRYPTO. Поскольку отсутствует управление потоком кадров CRYPTO конечная точка может заставить своего партнера буферизировать неограниченное количество данных.
Реализации ДОЛЖНЫ поддерживать буферизацию не менее 4096 байт данных CRYPTO полученных не по порядку. Конечные точки МОГУТ разрешить буферизацию дополнительных данных во время рукопожатия. Большой лимит во время рукопожатия может позволить обменяться большими ключами или учетными данными. Размер буфера конечной точки не должен оставаться постоянным в течении всего соединения.
Невозможность буферизировать кадры CRYPTO во время рукопожатия может привести к сбою соединения. Если во время рукопожатия превышен буфер конечной точки, этот буфер может быть расширен до конца рукопожатия. Если конечная точка не расширила свой буфер, она ДОЛЖНА закрыть соединение с кодом ошибки CRYPTO_BUFFER_EXCEEDED.
Как только рукопожатие завершается, если конечная точка не может буферизировать данные в кадре CRYPTO, она МОЖЕТ отбросить кадр CRYPTO и все кадры полученные в будущем, или МОЖЕТ закрыть соединение с кодом ошибки CRYPTO_BUFFER_EXCEEDED. Пакеты, содержащие отброшенные кадры CRYPTO, должны быть подтверждены, поскольку пакет был принят и обработан транспортом.

8. Проверка адресов.
Проверка адресов используется QUIC, чтобы избежать использование протокола для атаки усиления трафика. При этой атаке пакет отправляется на сервер с поддельной информацией об адресе источника. Если сервер генерирует большое количество трафика или пакетов в ответ на этот пакет, злоумышленник может использовать сервер, чтобы отправлять жертве больше данных, чем он мог отправить самостоятельно.
Основой защитой от атак на усиление трафика является проверка того, что конечная точка способна принимать пакеты по требуемому транспортному адресу. Проверка адреса выполняется во время установки соединения (Раздел 8.1), так и во время миграции соединения (Раздел 8.2)

8.1 Проверка адреса во время установки соединения
Установление соединения неявно обеспечивает проверку адреса обеих конечных точек. В частности, получения пакета защищенного ключами рукопожатия, подтверждает, что клиент получил начальный пакет с сервера. Как только сервер успешно обработал пакет от клиент, он может считать, что адрес клиент проверен.
Для проверки клиентского адреса сервера НЕ ДОЛЖНЫ  отправлять более чем в три раза больше байт, чем количество полученных ими байт от клиента. Это ограничивает масштаб любой атаки на усиление с использованием поддельных адресов источников.  При определении этого предела сервер учитывает только размер успешно обработанных пакетов.
Клиенты ДОЛЖНЫ гарантировать, что UDP-датаграммы, содержащие начальные пакеты, имеют размер не менее 1200 байт, добавляя заполнение к пакетам по мере необходимости. Отправка дополненных датаграмм гарантирует, что сервер не будет чрезмерно стеснен ограничением усиления.
Потеря пакета, в частности пакета рукопожатия от сервера, может вызвать ситуацию, когда сервер не может отправить данные в ситуации когда у клиенты нет данных для передачи и достигнут предел ограничения усиления. Чтобы избежать взаимоблокировки рукопожатия, клиенты ДОЛЖНЫ отправить пакет по истечению времени повторной передачи, как описано в [QUIC-RECOVERY]. Если клиент не имеет данных для повторной передачи и не имеет ключей рукопожатия, он ДОЛЖЕН послать исходный пакет в дейтаграмме размеров не менее 1200 байт. Если у клиента есть ключи рукопожатия, он ДОЛЖЕН отправить пакет рукопожатия.
Сервер может захотеть проверить адрес клиента перед началом криптографического подтверждения связи. QUIC использует токен в исходной пакете для проверки адреса перед завершением рукопожатия. Этот токен доставляется клиенты во время установки соединения с пакетом Retry (Раздел 8.1.1) или в предыдущем соединении с использование кадра NEW_TOKEN (Раздел 8.1.2)
Серверы помимо ограничений устанавливаемых проверкой адресов, также ограничены контроля перегрузки. Клиенты ограничен только механизмами контроля перегрузки.

8.1.1 Проверка адреса с использование пакета Retry.
После получения пакета Initial сервер может запросить подтверждение адреса, отправив пакет Retry(Раздел 17.2.5) содержащий токен. Этот токен ДОЛЖЕН быть повторен клиентом во всех Initial пакетах, которые от отправляет для этого соединения после получения пакета Retry. В ответ на обработку Initial пакетов сервер может прервать соединение или разрешить его продолжить.
Не представляется возможным атакующему сгенерировать действительный токен для своего собственного адреса (Раздел 8.1.3) и заставить клиента вернуть этот токен, чтобы доказать серверу его получение.
Сервер также может использовать пакет Retry отложить затраты на установку соединения. Представляя клиенты другой ID соединения, сервер может направить подключение к другому экземпляру с большим количество ресурсов.
Использование пакета Retry показано на рисунке 5.
   Client                                                  Server

   Initial[0]: CRYPTO[CH] ->

                                                   <- Retry+Token

   Initial+Token[1]: CRYPTO[CH] ->

                                    Initial[0]: CRYPTO[SH] ACK[1]
                          Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                    <- 1-RTT[0]: STREAM[1, "..."]

   Figure 5: Пример рукопожатия с пакетом Retry


8.1.2 Проверка адреса для будущего соединения
Сервер МОЖЕТ предоставить клиентам токен проверки адреса в текущем соединении для использования в последующих соединения. Проверка адреса особенно важна для 0-RTT, поскольку сервер потенциально отправляет большое количество данных в ответ на 0-RTT.
Сервер использует кадры NEW_TOKEN(Раздел 19.7) для предоставления клиенты токена провери адреса используемый для будущих соединений. Клиент включает этот токен в Initial пакеты для проверки адреса будущих соединений. Клиент ДОЛЖЕН включать токен во все Initial пакеты, если только Retry не заменит токен более новым. Клиент НЕ ДОЛЖЕН использовать токен, предоставленный Retry для будущих соединений. Серверы МОГУТ отбросить любой Initial пакет не содержащий ожидаемый токен.
Токен ДОЛЖЕН быть создан таким, чтобы сервер легко мог отличить его от токенов отправленных в пакетах Retry, поскольку они  переносятся в одном поле.
Токен НЕ ДОЛЖЕН содержать информацию, которая позволила бы наблюдателю связать его с соединением для которого он был создан. Например, он не может включать идентификатор соединения или информацию об адресации, если эти значения не зашифрованы.
В отличии от токена созданного для пакета Retry, этот токен может иметь некоторое время между создание и использованием. Таким образом, токен ДОЛЖЕН иметь время действия. Это может быть любая явно указанное время либо временная отметка выдачи используемая для динамического расчета время действия. Сервер может хранить время действия или включить его в зашифрованном виде в токен.
Маловероятно, что номер порта клиента будет одинаков в двух разных соединениях, поэтому проверка порта едва ли будет успешной.
Если у клиента есть токен полученный в кадре NEW_TOKEN во время предыдущего соединения с тем же сервером, он ДОЛЖЕН включить это значение в толе Token своего Initial пакета. Включение токена позволит серверу проверить адрес клиента без дополнительной обратной передачи.
Токен позволяет серверу соотнести активность между соединением, где был выдан токен и другим соединение, где он используется. Клиенты, которые желают не допустить такой идентификации, МОГУТ сбросить токены полученные с использованием кадра NEW_TOKEN. Токен полученный  в пакете Retry должен быть использован сразу во время попытки соединения и не может использоваться в последующих попытках.
Клиент НЕ ДОЛЖЕН повторно использовать токен в разных соединениях. Повторное использование токена позволяет связать сущности соединений (Раздел 9.5). Клиент НЕ ДОЛЖЕН повторно использовать токен если он считает, что его точка подключения к сети изменилась с момента последнего подключения. То есть, если изменился его локальный IP-адрес или сетевой интерфейс. Клиент должен начать процесс подключения заново, если он мигрирует до завершения рукопожатия.
Когда сервер получает Initial пакет с токена проверки адреса, он ДОЛЖЕН попытаться поверить адрес, если только он уже не завершил проверку адреса. Если токен недействительный, то сервер ДОЛЖЕН действовать так, как если бы клиента не было проверенного адреса, включая отправку Retry. Если проверка прошла успешно, сервер ДОЛЖЕН разрешить рукопожатие.
Примечание.  Обоснование того, что клиент считается не проверенным, а не отбрасываются его пакеты, заключается в том, что клиент мог получить токен в предыдущем соединении с использованием кадра NEW_TOKEN. Если сервер потерял состояние, то он не сможет проверить токен вовсе, что приведет к сбою соединения, если пакет отбрасывать. Сервер ДОЛЖЕН по-разному кодировать токены, отправляемые кадрами NEW_TOKEN и пакетами Retry и проверять последние более строго.
В схеме без сохранения состояния сервер может использовать зашифрованные и аутентифицированные токены для передачи клиентам информации, которую сервер последствии сможет восстановить и использовать для проверки адреса клиента. Токены не интегрированы в криптографическое рукопожатие и поэтому не аутентифицируются. Например, клиент может повторно использовать токен. Чтобы избежать атак использующих это свойство, сервер может ограничить использование токенов только информацией, необходимой для проверки адреса клиента.
Злоумышленники могут воспроизводить токены, для использования серверов в качестве усилителей в DDOS атаках. Для защиты от таких атак серверы ДОЛЖНЫ гарантировать, что токены отправленные в пакетах Retry будут приниматься только в течении короткого времени. Токены предоставленные в кадрах NEW_TOKEN (Раздел 19.7) должны приниматься дольше, но НЕ ДОЛЖНЫ приниматься несколько раз подряд за короткий период. Серверы должны разрешить использование токенов только один раз если это возможно.

8.1.3 Целостность токена проверки адреса.
Токен проверки адреса ДОЛЖЕН быть трудно угадываемым. Включение в токен большого случайного значения должно быть достаточно, в зависимости от того, запоминает ли сервер отправляемое значения.
Схема на основе токенов позволяет серверу разгрузить клиента от любой проверки. Чтобы такая схема работала, токен ДОЛЖЕН быть защищен от модификации и фальсификации клиентом. Без защиты целостности злоумышленник может генерировать или угадывать значения токенов, которые будут приняты сервером. Только сервер должен обладать доступом к ключу защиты целостности токенов.
Нет необходимости в одном четко определенном формате токенов, поскольку сервер использующий токен сам генерирует его. Токен может содержать информацию о заявленном клиентом адресе(IP и порт), метку времени и любую другую полезную информацию нужную серверу для проверки токена в будущем.

8.2 Проверка пути
Проверка пути используется во время миграции конечной точки (Раздел 9 и Раздел 9.6), чтобы проверить доступность узла с нового локального адреса. При проверки пути конечные точки проверяют доступность между конкретным локальным адресом и узлом, где адрес двойной набор IP-адреса и порта
Проверка пути проверяет, что пакеты (PATH_CHALLENGE) могут быть отправлены и получены (PATH_RESPONSE) от узла. Важно, что проверка пути  проверяет пакеты полученные от мигрирующей точки на поддельный адрес источника.
Проверка пути может использоваться в любой время любой конечной точкой. Например, конечная точка может проверить, что узел по прежнему владеет локальным адресом после периода простоя.
Проверка пути не разработана как механизм обхода NAT. Несмотря на то, что описанный механизм эффективен для создания NAT bindings, поддерживающих обход NAT, ожидается возможность передачи пакета от узла к узлу без предварительной отправки пакета по этому пути. Для эффективного обхода NAT требуются дополнительные механизмы синхронизации, которые здесь не представлены.
Конечная точка МОЖЕТ объединить кадры PATH_CHALLENGE и PATH_RESPONSE с другими кадрами. В частности, конечная точка может дополнить пакет содержащий PATH_CHALLENGE для обнаружения PMTU или может связать PATH_RESPONSE с собственным PATH_CHALLENGE.
При поиске нового узла конечная точка может захотеть убедится, что узел имеет неиспользованный идентификатор соединения для ответа. Конечная точка может отправить кадр NEW_CONNECTION_ID и PATH_CHALLENGE в одном пакете. Это гарантирует, что неиспользованный ID соединения будет доступен узлу для отправки ответа.

8.3 Инициирование проверки пути
Чтобы инициировать проверку пути  конечная точка отправляет кадр PATH_CHALLENGE содержащий случайную полезную нагрузку по проверяемому пути.
Конечная точка МОЖЕТ отправить несколько кадров PATH_CHALLENGE для защиты от потери пакетов. Однако, конечной точке НЕ СЛЕДУЕТ отправлять несколько PATH_CHALLENGE в одном пакете. Конечной точке НЕ СЛЕДУЕТ отправлять PATH_CHALLENGE чаще, чем Initial пакет. Это гарантирует, что миграция соединения не вызывает большую загрузку пути чем установка нового соединения.
Конечная точка ДОЛЖНА использовать непредсказуемые данные в каждом кадре PATH_CHALLENGE, чтобы была возможность связать ответ сервера с конкретным PATH_CHALLENGE.

8.4 Ответ проверки пути.
Конечная точка при получении кадра PATH_CHALLENGE ДОЛЖНА немедленно ответить повторив данные содержащиеся в полученном кадре в кадре PATH_RESPONSE.
Конечная точка НЕ ДОЛЖНА отправлять более одного кадра PATH_RESPONSE в ответ на один кадр PATH_CHALLENGE (Раздел 13.2). Ожидается, что узел отправит кадр PATH_CHALLENGE по мере необходимости.

8.5 Успех проверки пути
Когда получен кадр PATH_RESPONSE содержащий данные отправленные в предыдущем PATH_CHALLENGE, новый адрес считается действительным. Получение подтверждения для кадра PATH_CHALLENGE не является адекватной проверкой, так как может быть подделано злоумышленником.
Обратите внимание, что получение по другому локальному адресу не приводит с сбою проверки пути, так как это может быть результатом пересылки пакета (Раздел 9.3.3) или сбоем маршрутизации. Возможно, что в будущем будет получен действительный PATH_RESPONSE.

8.6 Неудача проверки пути
Проверка пути завершается неудачей, когда конечная точка пытающееся проверить путь отказывается от проверки.
Конечные точки ДОЛЖНЫ отказаться от проверки пути на основании таймера. При настройке этого таймера реализацией [QUIC-RECOVERY] рекомендует, что время поиска нового пути должно быть в три раза больше текущего Probe Timeout(PTO) или больше начального тайм-аута (kinitialRtt * 2).
validation_timeout = max (3 * PTO, 6 * kInitialRtt)
Обратите внимание, что конечная точка может принимать содержимое других кадров из неподтвержденного пути, но для успешного подтверждение требуется кадр PATH_RESPONSE с соответствующими данными.
Когда конечная точка отказывается от проверки пути, она считает, что данный путь непригоден для использования. Это не означает сбой соединения - конечные точки могут посылать в зависимости от ситуации пакеты по другому пути. Если пути недоступны, конечная точка может дожидаться другого пути или закрыть соединение.
проверка пути может быть отменена и по другим причинам. Пряжде всего, если инициируется миграция соединения на новый путь во время проверки старого.

9. Миграция соединения
Использование идентификатора соединения позволяет конечным точкам пережить изменение адресов (IP-адрес и порт), например, вызванные переходом конечной точки в новую сеть. В этом разделе описывается процесс миграции конечной точки на новый адрес.
Дизайн QUIC основывается на том, что конечные точки сохраняют стабильный адрес на время рукопожатия. Коечная точка НЕ ДОЛЖНА начинать миграцию до подтверждения рукопожатия, как описано в Разделе 4.1.2 [QUIC-TLS].
Конечная точка НЕ ДОЛЖНА инициировать миграцию, если узел отправил транспортный параметр "disable_migration" во время рукопожатия. Конечная точка, отправившая данный параметр, но обнаружившая, что узел мигрировал в другую сеть МОЖЕТ закрыть соединение с ошибкой типа INVALID_MIGRATION. Конечная точка также НЕ ДОЛЖНА инициировать миграцию, если узел предоставил идентификатор соединения нулевой длинны. Поскольку пакеты без DCID не могут быть отнесены к соединению на основе набора адресов.
Не все изменения адреса узла являются преднамеренными миграциями. Узел может подвергаться NAT rebinding: изменение адреса из-за промежуточного устройства, например NAT, выделению нового исходящего порта или нового исходящего IP-адреса. Конечная точка ДОЛЖНА выполнить проверку пути (Раздел 8.2), когда она обнаруживает изменение в адресе узла, если только ранее не была выполнена проверка пути по этому адресу.
Когда конечная точка не имеет проверенного пути для отправки пакетов, она МОЖЕТ сбросить соединение. Конечная точка, способная к миграции, МОЖЕТ подождать пока новый путь не станет доступным, прежде чем сбросить соединение.
Этот документ ограничивает миграцию соединений только новыми клиентскими адресами. за исключением случаев описанных в Разделе 9.6. Клиенты несут ответственность за инициирование всех миграций. Сервер не отправляет non-probing пакеты по адресу клиенты, пока не увидят non-probing пакет с этого адреса. Клиент ДОЛЖЕН отбросить пакеты полученные с неизвестного адреса.

9.1 Зондирование нового пути
Конечная точка перед миграцией МОЖЕТ проверить доступность узла с нового локального адреса используя проверку пути(Раздел 8.2). Ошибка проверки пути означает невозможность его использования для этого соединения. Неспособность проверить путь не приводит к завершению соединения, если нет доступных альтернативных путей.
Конечная точка использует новый идентификатор соединения для "зондов" отправляемых с нового локального адреса(Раздел 9.5). Конечная точка, использующая новый локальный адрес, должна гарантировать доступность по крайней мере одного нового идентификатора соединения на узле. Это может быть достигнуто включение кадра NEW_CONNECTION_ID в "зондирующий" пакет.
Получение кадра PATH_CHALLENGE от узла указывает на проверку доступности пути. Конечная точка отправляет PATH_RESPONSE в ответ (Раздел 8.2).
Кадры PATH_CHALLENGE, PATH_RESPONSE, NEW_CONNECTION_ID, PADDING являются "зондирующими кадрами", а все остальные "не зондирующими". Пакет содержащий только зондирующие кадры, называется "зондирующим пакетом", а пакет содержащий любой другой кадр "не зондирующим пакетом".

9.2 Инициализации миграции соединений
Конечная точка может мигрировать на новый локальный адрес, отправляя пакеты содержащие не зондирующие кадра с этого адреса.
Конечная точка во время установки соединения проверяет адрес узла. Поэтому, мигрирующая конечная точка может отправлять пакеты узлу, зная, что узел готов получать по данному локальному адресу. Таким образом, конечная точка может мигрировать на новый локальный адрес без предварительной проверки адреса узла.
Новый путь при миграции может не поддерживать текущую скорость отправки. Поэтому контрольная точка сбрасывает контроллер перегрузки, как описано в Разделе 9.4.
Новый путь может не иметь такой же возможности ECN. Конечная точка проверяет возможность ECN, как описано в разделе 13.3.
Получение подтверждений для данных, отправленных по новому пути, служит доказательством доступности партнера. Поскольку подтверждения могут быть получены по любому пути, обратная доступность не устанавливается. Чтобы проверить обратную доступность, конечная точка МОЖЕТ инициировать проверку пути как описано в Разделе 8.2.

9.3 Ответ на миграцию соединений
Получение пакета с нового адреса содержащий не зондирующий кадр указывает, что узел мигрировал на этот адрес.
В ответ на такой пакет конечная точка ДОЛЖНА начать отправку последующих пакетов на новый адрес узла и ДОЛЖНА инициировать проверку пути(Раздел 8.2), чтобы подтвердить владение узлом нового адреса.
Конечная точка МОЖЕТ отправлять данные на непроверенный адрес, но она ДОЛЖНА защищаться от потенциальных атак, как описано в РАЗДЕЛЕ 9.2.1 и Разделе 9.3.2. Конечная точка МОЖЕТ пропустить проверку адреса, если адрес  был замечен недавно.
Конечная точка изменяет адрес только в ответ на не зондирующий пакет с наибольшим номером. Это гарантирует, что конечная точка не отправит пакеты на старый адрес в случае получения переупорядоченных пакетов.
После изменения адреса, на который отправляются не зондирующие пакеты, конечная точка может отказаться от проверки пути для других адресов.
Получение пакета с нового адреса может быть связано с NAT rebinding.
После проверки нового клиентского адреса, сервер ДОЛЖЕН отправить новые токены проверки адреса (Раздел 8.2) клиенту.

9.3.1 Подмена адреса узла
Возможно, что узел подделывает свой исходный адрес, чтобы заставить конечную точку отправить чрезмерные объемы данных нежелательному хосту. Если конечная точка отправляет значительно больше данных, чем узел-спуфер, миграция соединения может использоваться для атаки усиления.
Как описано в Разделе 9.3 конечная точка требует проверку адреса узла для подтверждения владения этим адресом. Пока адрес не будет считаться подтвержденным, конечная точка ДОЛЖНА ограничивать скорость передачи данных по этому адресу. Конечная точка НЕ ДОЛЖНА превышать объемы окна перегрузки на расчетное RTT (kMinimunWindow, как определено в [QUIC-RECOVERY]). В отсутствии этого ограничения конечная точка может быть использована для атаки типа "Отказ в обслуживании". Поскольку конечная точка не будет иметь никаких измерений времени RTT по этому адресу, оценка ДОЛЖНА быть начальным значением по умолчанию(см [QUIC-RECOVERY]).
Если конечная точка пропускает проверку адреса, как описано в Разделе 9.3, ей не нужно ограничивать скорость отправки.

9.3.2 Подмена адреса пути
Злоумышленник находящийся на пути может вызвать ложную миграцию соединения, копируя и пересылая пакет с поддельным адресом, так что он пребывает до исходного пакета. Пакет с поддельным адресом будет получен из мигрирующего соединения, а исходный пакет будет считаться дубликатом и отброшен.  После ложной миграции проверка адреса не удастся, поскольку у объекта с поддельным адресом нет необходимых криптографических ключей для чтения и ответа на PATH_CHALLENGE.
Чтобы защитить соединение от ложной миграции, конечная точка ДОЛЖНА вернуться к использованию последнего проверенного адреса узла, если проверка нового адреса не удалась.
Если конечная точка не имеет последнего подтвержденного адреса узла, она ДОЛЖНА закрыть соединение без вывода сообщения, сбрасывая все состояния соединения. Это приведет к тому, что новые пакеты будут обрабатываться по общим правилам. Например, конечная точка МОЖЕТ отправить сброс без сохранения состояния в ответ на любые дальнейшие входящие пакеты.
Получение пакетов с более высокими номерами пакетов с легитимного адреса вызовет другую миграцию соединения. Это приведет к тому, что проверка ложной миграции будет прекращена.

9.3.3 Переадресация пакета off-path
Злоумышленник, находящийся off-path и способный наблюдать пакеты, может пересылать копии подлинных пакетов на конечные точки. Если скопированный пакет прибывает до подлинного, это будет создавать видимость NAT rebinding. Любой подлинный пакет будет отброшен как дубликат. Если злоумышленника может продолжать пересылку пакетов, то есть возможность вызвать миграцию соединения через путь атакующего. Тем самым давая ему возможность наблюдать или отбрасывать все последующие пакеты.
В отличии от атаки описанной в Разделе 9.3.2 злоумышленник может убкдится, что новый путь успешно подтвержден.
Эта атака основана на том, что злоумышленники использует примерно такой же быстрый путь, как прямой путь между двумя точками. Успешность атаки повышается, если отправлено относительно мало пакетов или происходит потеря пакетов.
Не зондирующий пакет увеличивающий максимальный номер, полученный по исходному пути, заставит конечную точку вернуться на этот путь. выявление пакетов на этом пути увеличивает вероятность неудачной атаки. Следовательно, смягчение атаки зависит от запуска обмена пакетами.
В ответ на миграцию конечные точки ДОЛЖНЫ проверить ранее активный путь используя кадр PATH_CHALLENGE. Это вызовет отправку новых пакетов по этому пути. Если путь не жизнеспособный, проверка потерпит неудачу. Если путь  жизнеспособный, но больше не требуется, проверка будет успешной, но приведет только к отправке проверочного пакета по этому пути.
Конечная точка, получившая PATH_CHALLENGE на активном пути ДОЛЖНА отправить в ответ не зондирующий пакет. Если не зондирующий пакет прибудет до копии злоумышленника, то соединение мигрирует обратно на исходный путь. Любая последующая миграция перезапустит этот процесс.
Эта защита несовершенна, но это не считается серьезной проблемой. Если путь через атакующего быстрее исходного пути, несмотря на попытки использовать исходный путь, то невозможно провести различия между атакой и улучшением маршрутизации.
Конечная точка может использовать эвристику для обнаружения подобной атаки. Например, NAT rebinding маловероятна, если пакеты были недавно получены по старому пути. Аналогично, повторное связывание редко встречается в сетях Ipv6. И наоборот, изменение идентификатора соединения с больше вероятностью указывает на миграцию, а не на атаку.

9.4 Обнаружение потерь и контроль заторов
Объем доступный по новому пути, может не совпадать со старым путем. Пакеты отправленные по старому пути, НЕ ДОЛЖНЫ влиять на управление перегрузкой или оценку RTT для нового пути.
После подтверждения владения узлом нового адреса конечной точке СЛЕДУЕТ немедленно сбросить контроллер перегрузки и оценки времени RTT для нового пути.
Конечная точка НЕ ДОЛЖНА возвращаться к скорости отправки используемой для предыдущего пути, только если у нее нет достаточной уверенности в том, что предыдущая скорость отправки действительна для нового пути. Например, изменение номера порта клиента, вероятно, свидетельствует о повторной привязки на промежуточном узле, а не о полной смене маршрута. Определение таких ситуаций зависит от несовершенной эвристики. Если скорость нового пути значительно снижается, то контроллер перегрузки среагирует на сигналы и соответствующим образом снизит скорость передачи.
Может случаться переупорядочивание в приемнике, когда конечная точка отправляет данные и зондирующие пакеты с/на несколько адресов в течении периода миграции, поскольку два пути могут иметь различное время прохождения сигнала. Получатель пакетов по нескольким путям будет по прежнему отправлять ACK-кадры покрывающие все полученные пакеты.
Хотя во время миграции соединения используется несколько путей, может быть достаточно одного контекста контроля перегрузки и восстановления потерь (как описано в [QUIC-RECOVERY]). Например, конечная точка может задержать переключения контекста управления перегрузкой, пока не будет подтверждено, что старый путь более не нужен (как в случае описанном в Разделе 9.3.3).
Отправитель может сделать исключение для зондирующих пакетов, чтобы обнаружение их потери не приводило к чрезмерному снижению скорости отправки контроллером перегрузки. Конечная точка может установить отдельный таймер при отправке PATH_CHALLENGE, который сбросится при получении PATH_RESPONSE. Если таймер срабатывает до получения PATH_RESPONSE, конечная точка может отправить новый PATH_CHALLENGE и перезапустить таймер на более длительный период времени.

9.5 Последствия миграции соединения для конфиденциальности
Использование постоянного идентификатора соединения на нескольких путях, позволяет пассивному наблюдателю сопоставить активность между этими путями. Конечная точка, перемещаясь между разными сетями, может не захотеть, чтобы активность коррелировалась с каким либо объектом, кроме удаленного узла. Для этого при отправке с разных локальных адресов используются разные идентификаторы соединения, как описано в Разделе 5.1. Для эффективности этого действия, конечные точки должны гарантировать, что предоставляемые идентификаторы соединения не связаны с любым другим объектом.
В любое время конечные точки МОГУТ изменить отправляемый DCID, на значение, которое не используется на другом пути.
Конечная точка ДОЛЖНА использовать новый идентификатор соединения, если она инициирует миграцию. Использование нового идентификатора соединения исключает использования этого идентификатора для связывания активности одного и того же соединения в разных сетях. Защита заголовка гарантирует, что номера пакетов не могут использоваться для корреляции активности. Однако, это не мешает использовать другие свойства пакетов, такие как время и размер, для корреляции активности.
Возможны непреднамеренные изменения пути без изменения идентификатора соединения. Например, после периода бездействия сети NAT rebinding может привести к отправке пакетов по новому пути, при возобновлении передачи.
Клиент может захотеть уменьшить возможности соединения, используя новый идентификатор соединения и исходный порт UDP при отправке трафика после периода бездействия. Изменение порта UDP для отправки пакетов может вызвать появление пакета приводящего к миграции соединения. Это гарантирует, что механизмы поддерживающие миграцию, применяются даже для клиентов не испытывающих NAT rebinding или настоящих миграций. Изменение номера порта может привести к тому, что узел сбросит контекст контроля перегрузки (Раздел 9.4), поэтому порт СЛЕДУЕТ менять редко.
Конечная точка исчерпавшая идентификаторы соединения не может мигрировать. Чтобы гарантировать возможность миграции и отсутствия корреляции между путями, конечные точки ДОЛЖНЫ предоставлять новые идентификаторы соединения перед миграцией узлов.

9.6 Предпочитаемый адрес сервера
QUIC позволяет серверами принимать соединения на одном IP-адресе и пытаться перенести эти соединения на более предпочтительные адрес вскоре после квитирования. Это особенно полезно, когда клиенты первоначально подключаются в адресу совместно используемому несколькими серверами, но предпочитают использовать адрес одноадресной рассылки для обеспечения стабильности соединения. В этом разделе описывается протокол переноса соединения на предпочитаемый сервер.
Миграция соединения с новым адресом сервера, оставляет промежуточное соединение для дальнейшей работы. Если клиент получает пакете с нового адреса сервера, не указанного в транспортном параметре предпочитаемого адреса, клиент ДОЛЖЕН отбросить эти пакеты.

9.6.1 Сообщение предпочитаемого адреса
Сервер передает предпочитаемый адрес включив его в транспортный параметр preferred_address в TLS рукопожатии.
Серверы МОГУТ сообщать предпочитаемый адрес каждого семейства адресов (IPv4 и IPv6), чтобы клиенты могли выбрать тот, который наиболее подходит для их сетевого подключения.
Как только рукопожатие закончено, клиент ДОЛЖЕН выбрать один из двух предпочтительных адресов сервера и инициировать проверку пути (Раздел 8.2) этого адреса с использованием идентификатора соединения, предоставленного в транспортном параметре preferred_address.
Если проверка пути прошла успешно, клиент ДОЛЖЕН немедленно начать отправку всех будущих пакетов на новый адрес сервера с использованием нового идентификатора соединения и прекратить использование старого адреса сервера. Если проверка не удалась, клиент ДОЛЖЕН продолжить отправку всех будущих пакетов на исходный адрес сервера.

9.6.2 Ответ на миграцию соединения
Сервер может получить пакет адресованные его предпочтительному IP в любое время после принятия соединения. Если этот пакет содержит кадр PATH_CHALLENGE, сервер отправляет кадр PATH_RESPONSE в соответствии с разделом 8.2. Сервер ДОЛЖЕН отправлять другие не зондирующие кадры со своего исходного адреса до тех пор, пока не получит не зондирующий кадр на предпочтительный адрес от клиента и пока не проверит новый путь.
Сервер ДОЛЖЕН проверить путь до клиента с предпочтительного адреса. Это помогает защитится от ложной миграции инициируемой злоумышленником.
После завершения проверки пути и получения не зондирующего пакета с наибольшим номером на предпочтительном адресе, сервер начинает отправлять не зондирующие пакеты исключительно со своего предпочитаемого адреса. Он ДОЛЖЕН отбрасывать пакеты для этого соединения полученные по старому адресу, но МОЖЕТ продолжить обработку задержавшихся пакетов.

6.9.3 Взаимодействие клиентской и предпочтительного адреса
Клиенту может потребоваться выполнить миграцию прежде чем он перейдет на предпочитаемый адрес сервера. В этом случае клиент ДОЛЖЕН одновременно выполнить проверку пути как к исходному так и к предпочтительному адресу сервера с нового клиентского адреса.
Если соединение с предпочтительным адресом сервера не от того же адреса клиента, сервер ДОЛЖЕН защищаться от потенциальных атак, как описано в РАЗДЕЛЕ 9.3.1 и Разделе 9.3.2. В дополнение к преднамеренной одновременной миграции может произойти изменение NAN binding для предпочтительного адреса сервера.
Серверы ДОЛЖНЫ инициировать проверку пути по новому адресу клиента после получения зондирующего пакета с нового адреса. До завершения проверки пути серверы НЕ ДОЛЖНЫ отправлять на новый адрес больше, чем минимальное количество не запрошенных пакетов окна перегрузки.
Мигрирующий на новый адрес клиент ДОЛЖЕН использовать предпочитаемый адрес из того же семейства адресов для сервера.

9.7 Использование метку потока Ipv6 и миграция
Конечные точки, использующие для отправки данных IPv6, ДОЛЖНЫ применять метку потока в соответствии с [RFC6437], если только локальный API не позволяет установить метку потока.
Метка потока IPv6 ДОЛЖНА быть псевдослучайной функцией адреса и порта источника и приемника, а также CID назначения. Генерация метки потока ДОЛЖНА быть спроектировано так, чтобы минимизировать шансы связности с ранее использованной меткой, так как это позволило бы коррелировать активность на нескольких путях (Раздел 9.5).
Возможной реализацией является вычисление метки потока в виде криптографической хеш-функции адресов источника и приемника, портов UDP источника и приемника, CID назначения и локального секрета.

10. Завершение соединения
Установленное соединение QUIC может быть завершено одним из трех способов:
o время простоя (Раздел 10.2)
o немедленное закрытие (Раздел 10.3)
o сброс без сохранения состояния (Раздел 10.4)
Конечная точка МОЖЕТ отбросить состояние соединения если у нее нет проверенного пути, по которому она может отправлять пакеты (Раздел 8.2).

10.1. Закрытие и состояние стока соединения
Существуют состояния закрытия и стока соединения, для гарантии того, что соединения закрываются чисто и что задержанные и переупорядоченные пакеты должным образом отбросятся. Эти состояния ДОЛЖНЫ сохраняться в течении минимум трехкратного интервала PTO, как определено в [QUIC-RECOVERY].
Конечная точка входит в период закрытия после инициирования немедленного закрытия (Раздел 10.3). При закрытии конечная точка НЕ ДОЛЖНА отправлять пакеты не содержащие кадр CONNECTION_CLOSE (Раздел 10.3). Конечная точка хранит количество информации достаточное для генерации пакета, содержащего кадр CONNECTION_CLOSE и для идентификации пакетов принадлежащих соединению. Выбранный конечной точкой идентификатор соединения и  версия QUIC является достаточной информацией для идентификации пакетов закрывающегося соединения. Все остальное состояние соединения конечная точка может отбросить. Конечная точка МОЖЕТ сохранить ключи защиты пакетов, чтобы читать и обрабатывать кадр CONNECTION_CLOSE.
Состояние стока вводится, как только конечная точка получает сигнал, что узел закрывает или сливает соединение. В состоянии стока, в отличии от состояния закрытия, конечная точка НЕ ДОЛЖНА отправлять какие-либо пакеты. Сохранение ключей защиты не требуется.
Конечная точка МОЖЕТ перейти от периода закрытия к периоду стока, если она получает кадр CONNECTION_CLOSE или сброс без сохранения состояния, указывающие что узел также закрывается или находится в состоянии стока. Период стока ДОЛЖЕН закончится, когда завершается период закрытия. Другими словами, конечная точка может использовать то же время окончания, но прекратить повторную передачу завершающего пакета.
Удаления состояния соединения до окончания периода закрытия или стока может привести к тому, что задержанные или переупорядоченные пакеты вызовут сброс всех сохранения состояния. Конечные точки, имеющие альтернативные средства для гарантии того, что опоздавшие пакеты не вызовут ответ, как способность закрыть сокет UDP, МОГУТ использовать сокращенный период стока для быстрого восстановления ресурсов. Серверы, сохраняющие открытым сокет для новых соединений, НЕ ДОЛЖНЫ выходить раньше из периода закрытия или стока.
После завершения периода закрытия или стока, конечной точке СЛЕДУЕТ удалить все состояния соединения. Это приведет к тому, что новые пакеты будут обрабатываться по общим правилам. Например, конечная точка МОЖЕТ отправлять сброс без сохранения состояния на любой входящий пакет.
Периоды закрытия и стока не применяются при отправке сброса без сохранения состояния (Раздел 10.4).
Конечная точка в состоянии закрытия или стока не должна обрабатывать обновления ключа. Это может помешать переходу конечной точки из состояния закрытия в состояние стока, но в остальном не окажет влияния.
Находясь в состоянии закрытия, конечная точка может получить пакеты с нового адреса источника, что указывает на миграцию. Конечная точка в состоянии закрытия ДОЛЖНА строго ограничить количество пакетов отправляемых на новый адрес, до тех пор пока новый адрес не будет проверен (Раздел 8.2). Сервер с состоянии закрытия МОЖЕТ отказаться от пакетов полученных с нового адреса источника.

10.2 Время простоя
Если при включении тайм-аута простоя соединение простаивает больше чем объявленное время и более чем три PTO, то состояние соединения молча сбрасывается и соединение закрывается.
Каждая конечная точка объявляет свое время простоя. Конечная точка перезапускает таймер, когда пакет от узла получен и обработан. Таймер также перезапускается при отправке пакета, содержащего кадры отличные от ACK или PADDING(пакет вызывающий ACK [QUIC-RECOVERY]), но только в том случае, если после последнего приема пакета не было отправлено никаких других пакетов вызывающих ACK. Перезапуск при отправке пакетов гарантирует, что время соединения при инициализации новой активности не истечет преждевременно.
Значение простоя могут быть ассиметричными. Объявленные конечной точкой значения, используются только для определения является ли соединение действующим в этой конечной точке. Конечная точка отправляющая пакеты ближе к концу времени простоя узла, рискует что пакеты будут отброшены, если узел войдет в состояние стока перед получение пакетов. Если узел может установить таймаут простоя как PTO(Раздел 6.3 [QUIC-RECOVERY]), рекомендуется проверить его на живучесть, прежде чем отправлять данные которые нельзя безопасно повторить. Обратите внимание, скорее всего только протоколы или приложения будут знать какую информацию можно повторить.

10.3 Немедленное закрытие
Конечная точка отправляет кадр CONNECTION_CLOSE(Раздел 19.19) для немедленного завершения соединения. Кадр CONNECTION_CLOSE вызывает немедленное закрытие всех потоков. Можно предполагать, что открытые потоки неявно сбрасываются.
После отправки CONNECTION_CLOSE конечные точки немедленно переходят в состояние закрытия. В течении заключительно периода конечная точка отправившая кадр CONNECTION_CLOSE, ДОЛЖНА отвечать на любой получаемый пакет, другим пакетом содержащим кадр CONNECTION_CLOSE. Для минимизации состояния поддерживаемого для закрываемого соединения, конечные точки МОГУТ отправлять точно такой же пакет. Однако конечным точкам СЛЕДУЕТ ограничить количество генерируемых ими пакетов, содержащих кадр CONNECTION_CLOSE. Например, конечная точка может постепенно увеличивать количество пакетов получаемых перед отправкой дополнительного пакета или увеличить время между такими пакетами.
Примечание.  Разрешение повторной отправки закрывающего пакета противоречит другим рекомендациям настоящего документа, в которых рекомендуется создавать новые номера пакетов для каждого пакета. Отправка новых номеров пакетов в первую очередь выгодна для восстановления потерь и управления перегрузкой. Как ожидается для закрываемого соединения эти механизмы не будут иметь значения. Повторная передача финального пакета требует меньше ресурсов.
Новые пакеты с не проверенных узлом могут использоваться для усиления атаки (Раздел 8). Поэтому, конечные точки ДОЛЖНЫ ограничивать передачу кадров CONNECTION_CLOSE подтвержденными адресами, либо отбрасывать пакеты без ответа, если ответ будет более чем в три раза больше принятого пакета.
После получения кадра CONNECTION_CLOSE конечные точки переходят в состояние стока. Конечная точка принявшая кадр CONNECTION_CLOSE, прежде чем войдет в состояние стока МОЖЕТ отправить один пакет содержащий кадр CONNECTION_CLOSE и код NO_ERROR при необходимости. Конечная точка НЕ ДОЛЖНА отправлять дополнительные пакеты, т.к. это может привести к постоянному обмену кадрами CONNECTION_CLOSE до завершения периода закрытия одного из узлов.
Немедленное закрытие может использоваться после подготовки прикладного протокола закрытия соединения. Это может произойти после согласования постепенного завершения работы протоколами приложения. Протокол приложения обменивается необходимыми данными для закрытия соединения обеими конечными точками, после чего приложение запрашивает закрытие соединения. Протокол приложения может использовать кадр CONNECTION_CLOSE с соответствующим кодом ошибки для сигнализации закрытия.
Цель отправки CONNECTION_CLOSE состоит в том, чтобы узел гарантировано обработал кадр. Обычно это означает отправку пакета с наивысшим уровнем защиты для избежания отбрасывания пакета. Однако, возможно продвинутые ключи защиты не доступны узлу, поэтому кадр МОЖЕТ быть повторен в пакете имеющем более низкий уровень защиты.
После подтверждения рукопожатия конечная точка ДОЛЖНА отправлять любые кадра CONNECTION_CLOSE в пакете 1-RTT. До подтверждения рукопожатия узел может не иметь ключей 1-RTT, поэтому конечной точке следует отправлять кадр CONNECTION_CLOSE в пакете рукопожатия. Если конечная точка не имеет ключей рукопожатия, она ДОЛЖНА отправлять кадры CONNECTION_CLOSE в Initial пакете.
Клиент всегда знает есть ли у сервера ключи рукопожатия (Раздел 17.2.2.1), но сервер, возможно не знает, есть ли ключи у клиента. При этих обстоятельствах серверу СЛЕДУЕТ отправлять кадр CONNECTION_CLOSE в пакетах Handshake и Initial, чтобы гарантировать, что хотя бы один из них может быть обработан клиентом. Эти пакеты могут быть объединены в одну датаграмму UDP(Раздел 12.2)

10.4 Сброс без сохранения состояния
Сброс без сохранения состояния предоставляется как опция последней надежды для конечной точки, которая не имеет доступа к состоянию соединения. Авария или сбой могут привести к тому, что узлы продолжат отправлять данные коечной точке, которая не может правильно продолжить соединение. Конечная точка МОЖЕТ отправить сброс без сохранения состояния в ответ на получение пакета, который она не может связать с активным соединением.
Сброс без сохранения состояния не подходит для сигнализации об ошибках. Конечная точка желающая сообщить о фатальной ошибке соединения ДОЛЖНА использовать кадр CONNECTION_CLOSE, если имеется такая возможность.
Для поддержки этого процесса конечными точками отправляется токен. Токен передается в кадре NEW_CONNECTION_ID, где серверы указывают транспортный параметр stateless_reset_token во время рукопожатия (клиенты не указывают токен, т.к. их транспортные параметры не защищены). Благодаря шифрованию только клиент и сервер знают это значение. Токены становятся недействительными, когда связанный с ними идентификатор соединения удаляется кадром RETIRE_CONNECTION_ID (Раздел 19.16).
Конечная точка, получившая пакеты которые она не в состоянии обработать, отправляет пакет следующей структуры:
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|1|               Unpredictable Bits (198..)                ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                   Stateless Reset Token (128)                 +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     Рисунок 6: Пакет сброса без сохранения состояния.
Такая структура гарантирует, что пакет сброса не отличим от обычного пакета с коротким заголовком, насколько это возможно.
Сброс без сохранения состояния использует всю датаграмму UDP, начиная с первых двух битов заголовка пакета. Остальная часть байта и произвольное число байтов, следующих за ним, устанавливаются в случайное значение. Последние 16 байт датаграммы содержат маркер сброса.
Для всех, кроме получателя, пакет сброса будет выглядеть как пакет с коротким заголовком. Чтобы пакет выглядел действительным, поле "Unpredictable Bits" должно содержать 198 бит данных (или 25 байт минус два фиксированных бита). Такая структура предназначается для пакетов с максимально разрешенной длинной DCID, минимальным номером пакета и  полезной нагрузкой. Маркер сброса соответствует минимальному расширению защиты пакета AEAD. Может потребоваться больше случайных байт, если конечная точка согласовала схему защиты с большим количеством байт AEAD.
Конечной точке НЕ СЛЕДУЕТ отправлять пакет сброса, который значительно больше полученного пакета. Конечные точки ДОЛЖНЫ отбрасывать слишком малые пакеты. С набором функций AEAD, определенной в [QUIC-TLS], пакеты размером менее 21 байта недействительны.
Конечные точки ДОЛЖНЫ отправлять пакеты сброса, сформированные как пакеты с короткими заголовками. Однако, конечные точки ДОЛЖНЫ обработать как сброс без сохранения состояния любой пакет, заканчивающийся действительным маркером сброса, так как другие версии QUIC могут разрешить использование длинного заголовка.
Конечная точка МОЖЕТ отправить сброс без сохранения состояния в ответ на пакет с длинным заголовком. Отправка сброса не вызывает никакого эффекта, до получения узлом токена сброса. В этой версии QUIC пакеты с длинными заголовками используются только во время установления соединения. Поскольку маркер сброса недоступен до конца установления соединения, игнорирование неизвестного пакета с длинным заголовком может быть столь же эффективна, как и отправка сброса.
Конечная точка не может определить SCID из пакета с коротким заголовком, поэтому она не может установить DCID пакета сброса. Следовательно, DCID будет отличаться от значений используемых в предыдущих соединениях. Случайный DCID приводит к тому, что идентификатор соединения выглядит как новый, предоставленный кадром NEW_CONNECTION_ID (Раздел 19.15).
Использование случайного идентификатора соединения приводит в двум проблемам:
o Пакет может не достичь узла. Если DCID имеет решающее значение для маршрутизации, пакет может быть неправильно маршрутизирован. Это может вызвать другой сброс без сохранения состояния в ответ (Раздел 10.4.3). Механизм обнаружения и восстановления ошибок является неэффективным в случае неправильно маршрутизированного сброса. В таком случае применяются другие методы обнаружения сбоя соединения, такие как таймеры.
o случайно сгенерированные ID соединения могут использоваться другими объектами для идентификации потенциального сброса без сохранения состояния. Конечная точка использующая разные ID соединения иногда может внести некоторую неопределенность.
Последние 16 байт устанавливают значение токена сброса без сохранения состояния.
Эта структура специфичная для версии QUIC 1 версии. Конечной точке поддерживающей несколько версий QUIC, необходимо создать сброс без сохранения состояния, такой что его примет узел поддерживающий любую версию QUIC. Разработчики QUIC должны либо повторять такую структуру, либо использовать часть пакета отличную от последних 16 байт.

10.4.1 Обнаружение сброса без сохранения состояния
Конечная точка обнаруживает потенциальный сброс, когда входящий пакет не может быть связан с соединением, не может быть расшифрован либо помечен как дублирующий. Затем конечная точка ДОЛЖНА сравнить последние 16 байт пакета со всеми токенами сброса связанными с идентификаторами соединения, которые конечная точка отправляла по IP-адресу с которого принята датаграмма. Включая токены сброса из кадров NEW_CONNECTION_ID и транспортных параметров сервера. Конечная точка НЕ ДОЛЖНА проверять наличие токена, связанных с идентификаторами которые не использовались или были удалены.
Если последние 16 байт значения пакета идентичны токену, конечная точка ДОЛЖНА перейти в состояние стока и не посылать дальнейшие пакеты по соединению. Если сравнение не удалось, пакет отбрасывается.

10.4.2 Расчет токена сброса без сохранения состояния
Токен ДОЛЖЕН быть трудно угадываемым. Для создания токена конечная точка генерирует[RFC4086] случайным образом секрет для каждого соединения. Однако, это создает проблему для согласования, когда существует кластер и проблему возможной утери токена. Сброс без сохранения состояния существует для случая потери состояния, поэтому подход является неоптимальным.
Можно использовать один статичный ключ для всех соединений с конкретной конечной точкой, используя две итерации устойчивой к атаке нахождения прообраза функции, подавая на вход статичный ключ и идентификатор соединения (Раздел 5.1). Конечная точка может использовать HMAC[RFC2104] (пример, HMAC (static_key, connection_id)) или HKDF [RFC5869] (статичный ключ в качестве ключевого параметра, ID в виде соли). Для создания маркера, выходные данные усекаются до 16 байт.
Конечная точка потерявшая состояние, может использую тот же метод восстановить идентификатор сброса. Идентификатор соединения берется из пакета  сброса.
Эта конструкция полагается на то, что узел всегда отправляет идентификатор соединения в пакетах, для восстановления токена сброса. Конечная точка использующая данную схему ДОЛЖНА любо использовать одинаковую длину идентификатора соединения для всех соединений либо кодировать длину идентификатора соединения, для восстановлении его без состояния. Кроме того, конечная точка не может использовать идентификаторы нулевой длинны.
Раскрытие токена сброса позволит любому объекту разорвать соединение, поэтому токен используется только один раз. Применение данного метода означает, что комбинация идентификатора и статичного ключа НЕ ДОЛЖНА использоваться для другого соединения. Возможна атака отказа в облуживании, если один и тот же идентификатор соединении используется разными экземплярами совместно использующими статический ключ или если злоумышленник может отправить пакет экземпляру не имеющему состоянии, но использующий тот же статический ключ(Раздел 21.8). Идентификатор соединения сбрасываемый путем раскрытия токена НЕ ДОЛЖЕН использоваться повторно для новых соединений с узлами используя статический ключ.
Один и тот же токен МОЖЕТ использоваться для нескольких идентификаторов одного соединения. Однако, повторное использование токена может подвергать конечную точку отказу в обслуживании, если связанные идентификаторы соединения будут удалены, а токен все еще активен на узле. Конечная точка ДОЛЖНА гарантировать, что пакеты с DCID соответствующие повторно используемому токену относятся к одному и тому же соединению, если токен сброса еще действителен. В противном случае злоумышленник может отправить пакет с удаленным идентификатор соединения и заставить конечную точку провести сброс, используя его для разрыва соединения как и при атаках описанных в Разделе 21.8.
Обратите внимание, что пакет сброса не имеет криптографической защиты. 

10.4.3 Looping
Дизайн сброса без сохранения состояния таков, что пакет без знания токена неотличим от действительного пакета. Например, если сервер отправляет сброс на другой сервер, он может получить в ответ еще один сброс, что может привести к бесконечному обмену.
Конечная точка ДОЛЖНА гарантировать, что каждый сброс который она отправляет меньше чем инициализировавший его пакет. При условии, что не поддерживается состояние, достаточное для предотвращения зацикливания. В случае цикла это приведет к тому, что со временем размер пакета уменьшиться до состояния не способного вызвать ответ.
Конечная точка может запоминать количество отправленных пакетов сброса и прекращать генерацию новых по достижению лимита. Использование отдельных лимитов для разных удаленных адресов гарантирует, что пакеты сброса могут использоваться для закрытия соединения, когда  другие лимиты исчерпаны.
уменьшение размера пакета сброса меньше рекомендуемых 41 байт, может показать наблюдателю характер пакета. И наоборот, отказ от отправки сброса в ответ на небольшой пакет может не позволить обнаружить разрыв соединения, когда оправляются маленькие пакеты. Сбои такого вида обнаруживаются с помощью других средств, например таймеров.
В случае невозможности обработки пакета, конечная точка может увеличить вероятность вызова сброса, дополнив пакет по крайней мере 42 байт.

11. Обработка ошибок
Конечная точка обнаружившая ошибку ДОЛЖНА сигнализировать о ошибке своему партнеру. Ошибки как транспортного так и уровня приложений могут влиять на всё соединения (Раздел 11.1), ошибки только уровня приложения могут затрагивать только один поток (Раздел 11.2).
Наиболее подходящий код ошибки (Раздел 20) ДОЛЖЕН быть включен в сигнализирующий об ошибке кадр. Если спецификация идентифицирует условия ошибки, она также идентифицирует используемый код ошибки.
Сброс без сохранения состояния (Раздел 10.4) не подходит для ошибки которую можно сигнализировать кадрами CONNECTION_CLOSE или RESET_STREAM. Сброс НЕ ДОЛЖЕН использоваться конечной точкой, способной отправить необходимый кадр по соединению.

11.1 Ошибки соединения
С использование кадра CONNECTION_CLOSE(Раздел 19.19) ДОЛЖНЫ сигнализироваться ошибки приводящие к невозможности использования соединения, такие как явное нарушение семантики протокола или искажение состояния. Конечная точка МОЖЕТ закрыть соединение даже если ошибка затрагивает только один поток.
Прикладные протоколы могут сигнализировать об ошибках протокола приложения, использую приложение-специфичный вариант кадра CONNECTION_CLOSE. Ошибки характерные для транспорта описанные в этом документе, передаются в QUIC-специфичном кадре CONNECTION_CLOSE.
Пакет содержащий кадр CONNECTION_CLOSE может потеряться. Конечная точка ДОЛЖНА быть готова повторно отправить пакет, если она продолжает принимать пакеты по закрытому соединению. Ограничение количества повторных передач и времени отправки финального пакета, ограничивает усилия затрачиваемые на разрыв соединения.
Конечная точка не желающая повторно передавать пакет содержащий CONNECTION_CLOSE рискует, что узел пропустит этот пакет. Единственный механизм доступный конечной точке, продолжающей принимать данные из разорванного соединения, - использовать сброс без сохранения состояния(Раздел 10.4).
Конечная точка получившая недопустимый кадр CONNECTION_CLOSE НЕ ДОЛЖНА сигнализировать об ошибке своему партнеру.

11.2 Ошибки потока
При ошибке уровня приложения затрагивающей один поток и при желании оставить соединение, конечная точка может отправить кадр RESET_STREAM (Раздел 19.4) с соответствующим кодом ошибки, для завершения только ошибочного потока.
RESET_STREAM ДОЛЖЕН инициироваться протоколом использующим QUIC, либо напрямую либо через получение кадра STOP_SENDING от узла. RESET_STREAM содержит код ошибки приложения. Сброс потока без уведомления протокола приложения может привести к входу протокола приложения в неисправимое состояние. Прикладные протоколы могут потребовать надежной доставки определенных потоков для гарантии согласованности состояний между конечными точками.

12. Пакеты и кадры
Конечные точки QUIC связываются путем обмена пакетами. Пакеты имеют защиты конфиденциальности и целостности (Раздел 12.1) и передаются в датаграммах UDP (Раздел 12.2).
Эта версия QUIC использует длинный заголовок пакета (Раздел 17.2) во время установки соединения. Пакеты с длинным заголовком: Initial (Раздел 17.2.2), 0-RTT (Раздел 17.2.3), Handshake (Раздел 17.2.4) и Retry (Раздел 17.2.5). При согласовании версии используется независимый от версии пакет с длинным заголовком (Раздел 17.2.1).
Пакеты с коротким заголовком (Раздел 17.3) спроектированы для минимальных издержек и используются после установки соединения и получения ключей 1-RTT.

12.1 Защита пакетов
Все пакеты QUIC, за исключением пакетов согласования версии и Retry используют аутентифицированное шифрование с дополнительными данными (AEAD)[RFC5116] для обеспечения конфиденциальности и защиты целостности. Подробная информация о защите пакетов находятся в [QUIC-TLS]. Текущий раздел содержит обзор процесса.
Исходные пакеты защищены с помощью статических ключей.  Защита пакета не является защитой конфиденциальности. Начальная защита существует для гарантии того, что отправитель находится на сетевом пути. Получивший Initial пакет от клиента, может восстановить ключи, необходимые для снятия защиты пакетов или для генерации успешно аутентифицированных пакетов.
Все остальные пакеты защищены ключами полученными в ходе криптографического рукопожатия. Тип пакета длинного заголовка или фаза ключа из короткого заголовка используются  для определения уровня шифрования. Ожидается, что пакеты защищенные ключами 0-RTT и 1-RTT имеют конфиденциальность и аутентификацию источника данных. Криптографическое рукопожатие гарантирует, что только конечные точки получают соответствующие ключи.
Поле номера пакета содержащий номер пакета, имеет дополнительную защиту конфиденциальности, применяемая после применения защиты пакета ([QUIC-TLS]). Базовый номер пакета увеличивается с каждым пакетом, отправленным в данном пространстве номеров пакетов (Раздел 12.3).

12.2 Объединение пакетов
Initial(Раздел 17.2.2), 0-RTT(Раздел 17.2.3) и Handshake (Раздел 17.2.4) содержит поле длинны определяющий конец пакета. Длина включает в себя поля "Номер пакета" и "Полезная нагрузка" оба из которых защищены и имеют изначально неизвестную длину. Длина поля нагрузки определяется после снятия защиты заголовка.
Используя поле длины отправитель может обледенить несколько пакетов QUIC в одну датаграмму UDP. Это уменьшает количество датаграмм необходимых для криптографического рукопожатия и начала отправки данных. Объединение пакетов может использоваться для создания зондов PMTU (Раздел 14.3.1). Приемники ДОЛЖНЫ иметь возможность обрабатывать объединенные пакеты.
Объединение пакетов в порядке увеличения уровней шифрования (Initial, 0-RTT, Handshake, 1-RTT) повышает вероятность обработки получателям пакетов за один проход. Пакет с коротким заголовком не имеет длины, поэтому он может быть только последним пакетом в датаграмме UDP. Конечной точке НЕ СЛЕДУЕТ объединять несколько пакетов с одним уровнем шифрования. 
Отправители НЕ ДОЛЖНЫ объединять пакеты QUIC для разных соединений в одну датаграмму UDP. Получателям СЛЕДУЕТ игнорировать любые последующие пакеты с DCID, отличными от первого в датаграмме.
Каждый пакет QUIC, объединенный в одну датаграмму UDP, является отдельным и полным. Несмотря на то, что некоторые поля в заголовке могут быть избыточны, никакие поля не опускаются. Получатель объединенных пакетов QUIC ДОЛЖЕН индивидуально обрабатывать каждый пакет QUIC и отдельно подтверждать их, как если бы они были получены в отдельных датаграммах UDP. Например, если расшифровка не удалась(недоступны ключи и т.д.), получатель МОЖЕТ либо отбросить либо буферизировать пакет для последующей обработки и ДОЛЖЕН пытаться обработать оставшиеся пакеты.
Пакеты Retry(Раздел 17.2.5), пакеты согласования версий (Раздел 17.2.1) и пакеты с коротким заголовком (Раздел 17.3) не содержат поля длины и поэтому не могут сопровождаться другими пакетами в той же датаграмме UDP.

12.3 Номера пакетов
Номера пакетов представляют собой целое число в диапазоне от 0 до 2^62 - 1. Этот номер используется при определении одноразового шифрования для защиты пакета. Каждая конечная точка поддерживает отдельный номер пакета для отправления и получения.
Номера пакетов ограничены данными рамками, потому что должны быть представлены в поле "Наибольшее подтверждение" кадра ACK (Раздел 19.3). Однако,  в длинном или коротком заголовке, номер пакета сокращается и кодируется 1-4 байтами (Раздел 17.1).
Пакеты согласования версий (Раздел 17.2.1) и Retry (Раздел 17.2.5) не включают номера пакетов.
Номера пакетов QUIC разделяются на 3 пространства:
o Начальное пространство: все Initial пакеты (Раздел 17.2.2) находятся в этом пространстве
o Пространство рукопожатия: все пакеты Handshake (Раздел 17.2.4)
o Область данных приложения: все зашифрованные 0-RTT и 1-RTT (Раздел 12.1) пакеты
Как описано в [QUIC-TLS] каждый тип пакета использует разные ключи шифрования.
Концептуально, пространство номеров пакета - это контекст, в котором пакет может быть обработан и подтвержден. Initial пакет могут быть отправлены только с ключами защиты начальных пакетов и подтверждены только в таких же Initial пакетах. Аналогично, пакеты рукопожатия отправляются на уровне шифрования рукопожатии и могут быть подтверждены только на этом уровне.
Это обеспечивает криптографическое разделение данных, отправляемых в разных пространствах порядковых номеров пакетов. Номера пакетов в каждом адресном пространстве начинаются в 0. Последующие пакеты, отправляемые в том же пространстве, ДОЛЖНЫ увеличивать номер пакета минимум на один.
Данные 0-RTT и 1-RTT существуют в одном и том же пространстве номеров пакетов, чтобы упростить реализацию алгоритмов восстановления потерь между двумя типами пакетов.
Конечная точка QUIC в одном соединении НЕ ДОЛЖНА повторна использовать номера пакетов одного пространства.  Если номер достигает 2^62 - 1 отправитель ДОЛЖЕН закрыть соединение без отправки кадра CONNECTION_CLOSE или дополнительных пакетов. Конечная точка МОЖЕТ отправить сброс в ответ на дополнительные пакеты которые она получает.
Приемник ДОЛЖЕН отбросить расшифрованные пакет, если только он уверен, что обрабатывал другой пакет с тем же номером из того же адресного пространства. Подавление дубликатов ДОЛЖНО происходить после снятия защиты по причинам, описанным в Разделе 9.3 [QUIC-TLS]. Эффективный алгоритм подавления дубликатов можно найти в Разделе 3.4.3 [RFC4303].
Кодирование номера пакета отправителем и декодирование получателем описаны в Разделе 17.1.

12.4 Кадры и типы кадров
Полезная нагрузка пакетов QUIC, после снятия защиты, состоит из последовательности полных кадров, как показано на рисунке 7. Пакеты согласования версий, Сброса, Retry не содержат кадров.
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Frame 1 (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Frame 2 (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                  ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Frame N (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                          Figure 7: Полезная нагрузка QUIC
Полезная нагрузка пакета  содержащего кадры, ДОЛЖНА содержать по крайней мере один кадр и МОЖЕТ содержать несколько кадров разных типов. Кадры всегда помещаются в пакет QUIC и не могут занимать несколько пакетов.
Каждый кадр начинается с Freme Type, указывающего на тип кадра, за которым следуют специфичные дополнительные поля:
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Frame Type (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   Type-Dependent Fields (*)                 ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 8: Структура кадра
Типы кадров, определенных спецификацией, перечислены в таблице 3. Кадры типа ACK, STREAM, MAX_STREAMS,STREAMS_BLOCKED и CONNECTION_CLOSE используются для передачи флагов специфичных для кадра. Поле Freme Type всех остальных кадров просто идентифицирует кадр. Эти кадры более подробно описаны в Разделе 19.
          +-------------+----------------------+---------------+
          | Type Value  | Frame Type Name      | Definition    |
          +-------------+----------------------+---------------+
          | 0x00        | PADDING              | Раздел  19.1  |
          |             |                      |               |
          | 0x01        | PING                 | Раздел  19.2  |
          |             |                      |               |
          | 0x02 - 0x03 | ACK                  | Раздел  19.3  |
          |             |                      |               |
          | 0x04        | RESET_STREAM         | Раздел  19.4  |
          |             |                      |               |
          | 0x05        | STOP_SENDING         | Раздел  19.5  |
          |             |                      |               |
          | 0x06        | CRYPTO               | Раздел  19.6  |
          |             |                      |               |
          | 0x07        | NEW_TOKEN            | Раздел  19.7  |
          |             |                      |               |
          | 0x08 - 0x0f | STREAM               | Раздел  19.8  |
          |             |                      |               |
          | 0x10        | MAX_DATA             | Раздел  19.9  |
          |             |                      |               |
          | 0x11        | MAX_STREAM_DATA      | Раздел  19.10 |
          |             |                      |               |
          | 0x12 - 0x13 | MAX_STREAMS          | Раздел  19.11 |
          |             |                      |               |
          | 0x14        | DATA_BLOCKED         | Раздел  19.12 |
          |             |                      |               |
          | 0x15        | STREAM_DATA_BLOCKED  | Раздел  19.13 |
          |             |                      |               |
          | 0x16 - 0x17 | STREAMS_BLOCKED      | Раздел  19.14 |
          |             |                      |               |
          | 0x18        | NEW_CONNECTION_ID    | Раздел  19.15 |
          |             |                      |               |
          | 0x19        | RETIRE_CONNECTION_ID | Раздел  19.16 |
          |             |                      |               |
          | 0x1a        | PATH_CHALLENGE       | Раздел  19.17 |
          |             |                      |               |
          | 0x1b        | PATH_RESPONSE        | Раздел  19.18 |
          |             |                      |               |
          | 0x1c - 0x1d | CONNECTION_CLOSE     | Раздел  19.19 |
          +-------------+----------------------+---------------+

                           Table 3: Типы кадров
Конечная точка ДОЛЖНА трактовать получение кадра неизвестного типа как ошибку соединения FRAME_ENCODING_ERROR.
Все кадры QUIC являются идемпотентными. То есть, действительный кадр не вызовет нежелательных побочных эффектов или ошибок при приеме более одного раза.
Поле Frame Type использует целочисленное кодирование переменной длинный (Раздел 16), за одним исключением. Для обеспечения простой и эффективной реализации синтаксического анализа кадра, тип кадра ДОЛЖЕН использовать кратчайшее кодирование. Хотя возможно двух-, четырех- и восьмибайтное кодирование типов кадров, поле Frame Type кодируется одним байтом. Например, 0x4001 является допустимым двухбайтным кодированием для числа переменной длинны со значение 1, кадр PING всегда кодируется как один байт со значением 0x01. Конечная точка МОЖЕТ рассматривать получение типа кадра, использующего более длинное кодирование, как ошибку соединения типа PROTOCOL_VIOLATION.

13. Пакетизация и надежность
Отправитель связывает один или несколько кадров в пакет QUIC (Раздел 12.4).
Отправитель может минимизировать затраты полосы пропускания и вычислительных ресурсов, объединяя как можно больше кадров в пакет QUIC. Отправитель МОЖЕТ ожидать короткий период времени, прежде чем отправлять не максимальный пакет, чтобы избежать отправки большого количества мелких пакетов. Реализация МОЖЕТ использовать данные о поведении приложения или эвристики, для определения стоит ли ждать и как долго. Период ожидания выбирается реализацией. Реализация должна быть внимательна, поскольку любая задержка может увеличить видимую приложению задержку.
Мультиплексирование потоков достигается путем чередования кадров STREAM из нескольких потоков в один или несколько пакетов QUIC. Один пакет QUIC может включать в себя один или несколько кадров STREAM из одного или нескольких потоков.
Одним из преимуществ QUIC является предотвращение Head-of-line blocking нескольких потоков.  Когда происходит потеря пакета, блокируются только потоки с данными в этом пакете, в то время как другие потоки продолжают передаваться. Обратите внимание, когда данные нескольких потоков объединены в один пакет QUIC, потеря этого пакета блокирует передачу всех этих потоков. Реализациям рекомендуется объединять столько пакетов сколько нужно чтоб не терять эффективности передачи от недостаточно заполненных пакетов.

13.1 Обработка пакета и подтверждение
Пакет НЕ ДОЛЖЕН подтверждаться до тех пор, пока не будет снята защита и все кадры, содержащиеся в пакете, не будут обработаны. Для кадров STREAM это означает, что данные должны быть помещены в очередь приема протокола приложения, но доставки и потребления данных не требуется.
Как только пакет полностью обработан, получатель подтверждает получение посылая один иди несколько ACK кадров с номером принятого пакета.

13.1.1 Отправка кадров ACK
Конечная точка отправляет кадры ACK для подтверждения полученных и обработанных пакетов.
Пакеты содержащие только кадры ACK не контролируются системой предотвращения перегрузки, поэтому существует ограничение на частоту их отправки. Конечная точка НЕ ДОЛЖНА отправлять более одного пакета для кадра ACK в ответ на прием вызвавшего АСК пакета (содержащие кадры отличные от ACK и/или PADDING). Конечная точка НЕ ДОЛЖНА отправлять пакет содержащий только кадр ACK, в ответ на не вызывающий ACK пакет (содержащий только кадры ACK и/или PADDING), даже если существует пропуск пакетов предшествующему принятому пакету. Ограничение ACK пакетов позволяет избежать зацикливания подтверждений, способного повлиять на работоспособность соединение. Однако, конечная точка подтверждает не вызывающие ACK пакеты, когда отправляет кадры ACK.
Пакеты, содержащие кадр PADDING, считаются передающимися для контроля перегрузки [QUIC-RECOVERY]. Отправка только кадров PADDING может привести к ограничению отправителя контроллером перегрузки (как описано в [QUIC-RECOVERY]) без получения подтверждения от отправителя. Следовательно, отправителю СЛЕДУЕТ гарантировать, что другие кадры отправляются в дополнение к кадрам PADDING, для вызова подтверждения от получателя.
Конечная точка, отправляющая только кадры ACK? не будет получать подтверждении от узла, если эти подтверждения не включены в пакеты с ACK вызывающими кадрами. Конечная точка ДОЛЖНА объединять кадры ACK с другими кадрами, когда есть новые ACK вызывающие пакеты для подтверждения. Когда необходимо подтвердить только ACK не вызывающие пакеты, конечная точка МОЖЕТ ждать, пока не будет получен ACK вызывающий пакет для объединения кадра ACK с исходящими кадрами.
Конечной точке СЛЕДУЕТ обрабатывать получение подтверждения для не отправленного пакета, как ошибку соединения типа PROTOCOL_VIOLATION, если она способна обнаружить условие.
Таймер отложенного подтверждения получателя НЕ ДОЛЖЕН превышать текущую оценку RTT или значение указываемое в транспортном параметре "max_ack_delay". Это гарантирует, что при получении подтверждаемого пакета, подтверждение отправляется по крайней мере один раз за RTT. отправитель может использовать значение "max_ack_delay" получателя при определении тайм-аутов для повторной передачи на основе таймера.
Стратегии и последствия частоты генерации подтверждений более подробно обсуждаются в [QUIC-RECOVERY].

13.1.2 Ограничение диапазонов ACK
Для ограничения еще не принятых диапазонов ACK, получателю СЛЕДУЕТ отслеживать подтвержденные кадры ACK. Приемник ДОЛЖЕН исключить подтвержденные пакеты из будущих ACK, когда эти пакеты будут излишне влиять на размер кадра ACK. При отправке только пакетов не вызывающих ACK, отправитель может обледенить PING или другой вызывающий ACK небольшой кадр и отправить один раз за RTT, чтобы разрешить отбросить  ненужные диапазоны ACK и любые состояние для ранее отправленных пакетов. Приемник НЕ ДОЛЖЕН связывать кадр вызвавший ACK, такой как PING, со всеми пакетами не вызывающими ACK, чтобы избежать бесконечного цикла подтверждений.
Чтобы ограничить состояние приемника или размер кадров ACK, получатель МОЖЕТ ограничить количество отправляемых диапазонов ACK. Получатель может это сделать даже без получения подтверждения своих кадров ACK, зная что отправитель повторно передаст некоторые данные. Стандартные алгоритмы QUIC ([QUIC-RECOVERY]) объявляют потерянные пакеты подтвержденными после получения подтверждения более новых пакетов. Следовательно, получателю СЛЕДУЕТ предпочитать подтверждать вновь принятые пакеты, а не полученные в прошлом.

13.1.3 Кадры ACK и защита пакетов
Кадры ACK ДОЛЖНЫ быть переданы только в пакете имеющем то же пространство номеров пакетов, что и пакет вызвавший ACK(Раздел 12.1). Например, пакеты защищенные кличами 1-RTT, ДОЛЖНЫ быть подтверждены в пакетах также защищенных ключами 1-RTT.
Пакеты отправляемые с защитой 0-RTT, ДОЛЖНЫ подтверждаться сервером в пакетах 1-RTT. Это означает, что клиент не может использовать подтверждения, если ответ сервера с ключами криптографического рукопожатия задерживается или теряется. Обратите внимание, что такое ограничение применяется и к другим отправляемым севером данным защищенных ключами 1-RTT.
Конечные точки ДОЛЖНЫ отправлять подтверждение для пакетов содержащих кадры CRYPTO с уменьшенной задержкой(Раздел 6.2 [QUIC-RECOVERY]).

13.2 Повторная передача информации
Потерянные пакеты QUIC не передаются повторно целиком. То же относится к содержащихся в этих пакетах кадрах. Вместо этого содержащаяся в этих кадрах информация отправляется по мере необходимости в новых кадрах.
Для переноса информации определенной как потерянная используются новые кадры и пакеты. Когда пакет определяется как потерянный информация отправляется снова. Повторная отправка прекращается после получения подтверждения.
o Данные, отправленные в кадрах CRYPTO, передаются повторно в соответствиями с правилами [QUIC-RECOVERY], пока все данные не будут подтверждены. Данные в кадрах CRYPTO для пакетов Initial и Handshake отбрасываются, когда отбрасываются ключи шифрования соответствующего уровня.
o Данные приложения, отправляемые в кадрах STREAM, повторно передаются в новых кадрах STREAM? если только конечная точка не отправила RESET_STREAM для этого потока. Как только конечная точка отправляет кадр RESET_STREAM, дополнительные кадры STREAM не нужны.
O В кадрах ACK отправляется самый последний набор подтверждений. Кадр ACK ДОЛЖЕН содержать все неподтвержденные подтверждения, как описано в разделе 13.1.1
O Отмена передачи потока, отправляемая в кадре RESET_STREAM, отправляется до тех пор, пока узел не подтвердит подтверждение или все данные потока не будут подтверждены узлом(т.е в состоянии "Reset Recvd" или "Data Recvd"передающей части потока). Содержимое кадра RESET_STREAM НЕ ДОЛЖНО меняться при повторной отправке.
O Аналогичным образом, запрос на отмену передачи потока, закодированный в кадре STOP_SENDING, отправляется до перехода принимающей части в состояние "Data Recvd" или "Reset Recvd"(Раздел 3.5)
O Сигналы закрытия соединения, включенные в пакеты содержащие кадр CONNECTION_CLOSE, не отправляются снова при обнаружении потери пакета, как описано в Разделе 10.
O Максимум данных текущего соединения отправляется в кадрах MAX_DATA. Если пакет содержащий последний отправленный кадр MAX_DATA объявляется утерянным или конечная точка решит обновить ограничение происходит обновление отправляемого значения в кадре MAX_DATA. Необходимо соблюдать осторожность, что избежать слишком частой отправки этого кадра, поскольку ограничение может часто увеличиваться, что вызовет большое число кадров MAX_DATA.
Текущее максимальное смещение данных потока отправляется в кадрах MAX_STREAM_DATA. Как и MAX_DATA? обновленное значение отправляется, когда содержащий последний кадр MAX_STREAM_DATA пакет потерян или когда обновлен лимит. Отправлять следует с осторожностью, чтобы предотвратить слишком частую отправку кадра. Конечной точке Следует прекратить отправку кадра MAX_STREAM_DATA? когда принимающая часть потока переходит в состояние "Size Known". Ограничения на поток отправляется в кадрах MAX_STREAMS. Как и MAX_DATA? обновленное значение отправляется, когда содержащий самый последний кадр MAX_STREAMS объявляется утерянным или когда обновляется лимит. Отправку кадра необходимо выполнять с осторожностью, чтобы предотвратить слишком частую отправку.
o Сигналы блокировки передаются в кадрах DATA_BLOCKED, STREAM_DATA_BLOCKED и STREAMS_BLOCKED. Кадры DATA_BLOCKED управляют областью подключения, кадры STREAM_DATA_BLOCKED область потока, а STREAMS_BLOCKED ограничены определенным типом потока. Новые кадры отправляются, если последний кадр для области признан утерянным, но только в том случае, когда конечная точка заблокировала соответствующий лимит. Эти кадры всегда включают лимит вызывающий блокировку во время их передачи.
o Проверка жизнеспособности или проверка пути отправляет кадр PATH_CHALLENGE до тех пор, пока не будет получен соответствующий кадр PATH_RESPONSE или пропадет надобность проверок. Кадры PATH_CHALLENGE содержат разную полезную нагрузки при каждой отправке.
o Ответ на проверку пути использующий кадр PATH_RESPONSE отправляется один раз. Ожидается, что узел отправит больше PATH_CHALLENGE по мере необходимости, чтобы вызвать дополнительные кадры PATH_RESPONSE.
o Новфе идентификаторы соединения отправляются в кадрах NEW_CONNECTION_ID и передаются повторно в случае утери. Повторные передачи этого кадра имеют одинаковый порядковый номер. Аналогично, удаленные идентификаторы отправляемые в кадрах RETIRE_CONNECTION_ID повторно передаются в случае утери.
o Кадры PING и PADDING не содержат информации, поэтому в повторной передачи не нуждаются.
Конечные точки ДОЛЖНЫ устанавливать приоритет повторной передачи, а не отправке новых данных, только если приоритеты указанные приложением, не устанавливают иного (Раздел 2.3).
Не смотря на то, что отправителю рекомендуется каждый раз собирать актуальную информацию при отправке пакета, не запрещается повторно передавать копии кадров из потерянных пакетов. Приемник ДОЛЖЕН принимать пакеты содержащие старые кадры. Например кадр MAX_DATA несущий меньший меньшее максимальное значение, чем более старый.
При обнаружении потерь отправитель ДОЛЖЕН предпринять соответствующие меры по контролю перегрузки. Подробности обнаружения потерь и контроля перегрузки описаны в [QUIC-RECOVERY].

13.3 Явное уведомление о перегрузке
Конечные точки QUIC могут использовать явное уведомление о перегрузке(ECN) [RFC3168] для обнаружения и реагирования на перегрузку сети. ECN позволяет сетевому узлу указывать на перегрузку в сети, устанавливая значение(codepoint) в заголовке IP пакета вместо отбрасывания. Конечные точки реагируют на перегрузку в сети, уменьшая скорость отправки их данных, как описано в [QUIC-RECOVERY].
Чтобы использовать ECN, конечная точка QUIC определяет поддерживает сетевой путь маркировку ECN и имеет ли узел доступ к кодовой точке ECN в заголовке IP. Если сетевой путь не поддерживает ECN, пакеты с ECN отбрасываются или маркировка ECN перезаписывается в пути. Конечная точка проверяет путь как во время установки соединения, так и при переходе на новый сетевой путь(Раздел 9).

13.3.1 Подсчет ECN
При  получении пакета QUIC с кодовой точкой ECT или CE, конечная точка поддерживающая ECN и имеющая доступ к кодовым точка ECN IP заголовка, увеличивает соответствующий счетчик ECT(0), ECT(1) или CE и включает эти числа в последующие кадры ACK (Раздел 13.1 и Раздел 19.3). Обратите внимание, что для этого необходимо иметь возможность считывать контрольные точки ECN из прилагаемого IP-пакета, что возможно не на всех платформах.
Пакет, определенный как дубликат не влияет на количество локальных кодовых точек ECN получателя. Смотри Раздел 21.7 для соответствующих проблем безопасности.
Если конечная точке получает пакет без кодовых точек ECT или CE в заголовке IP, она отвечает в соответствии с Разделом 13.1 кадром ACK без увеличения числа ECN. Если конечная точка не реализует ECN или не имеет  доступ к заголовку IP-пакета, она не увеличивает счетчик ECN.
Объединенные пакеты (Раздел 12.2), могут использовать один заголовок IP для нескольких пакетов. Счетчик ECN для кодовой точки ECN, получены в соответствующем заголовке IP, увеличивается один раз для каждого пакета QUIC, а не для каждого пакета IP или датаграммы UDP.
Каждое пространство номеров пакетов поддерживает отдельные состояния подтверждений и  отдельные подсчеты ECN. Например, если объединен один из пакетов Initial, 0-RTT, Handshake и 1-RTT, то соответствующие значения для пространства номеров пакетов Initial и Handshake будут увеличены на единицу, а значение для пакета номерного пространства 1-RTT будет увеличено на два.

13.3.2 Подтверждение ECN
Каждая конечная точка независимо проверяет и разрешает использование ECN? устанавливая значение ECN Capable Transport (ECT) в заголовке IP для пути от нее до узла. Конечной точке СЛЕДУЕТ предоставлять обратную связь о полученных маркерах ECN (если это возможно), даже если сама конечная точка не устанавливает кодовые точки.
Чтобы убедиться в поддержке трактом ECN и предоставлении узлом обратной связи, конечная точка устанавливает кодовую точку ECT (0) в заголовке IP всех исходящих пакетов [RFC8311].
Если установленная кодовая точка в заголовке IP не искажена сетевым устройством, то полученный ответ содержит либо кодовую точку отправленную узлом, либо  Congestion Experienced (CE) установленную сетевым устройством испытывающим перегрузку.
Если пакет QUIC отправленный с кодовой точкой ECT? подтверждается кадром ACK без обратной связи ECN? то конечная точка прекращает установку кодовых точек ECT в IP пакетах, ожидая что путь или узел не поддерживает ECN.
Сетевые устройства повреждающие или применяющие нестандартную маркировку ECN, могут привести к снижению производительности сети или другим нежелательным побочным эффектам. Для уменьшения риск, конечная точка использует следующие шаги  для подсчетов полученных в кадрах ACK.
o Общее увеличение количества  ECT(0), ECT(1), и CE ДОЛЖНО быть не меньше числа пакетов QUIC, отправленных с кодовой точкой ECT и подтвержденных в этом кадре ACK. На этом этапе обнаруживается любая перемаркировка с кодовых точек  ECT(0), ECT(1), или CE на Not-ECT.
o Любое увеличение количества ECT(0) или УСЕ(1) плюс любое увеличение количества CE ДОЛЖНО быть не меньше, чем количество пакетов отправленных с кодовой точкой УСЕ, и подтвержденных этим кадром ACK. Этот шаг обнаруживает любую ошибочную разметку сети от ECT(0) до ECT(1) (или наоборот).
Конечная точка может пропустить подтверждение пакета при утери ACK кадра. Следовательно, общее увеличение количества ECT (0), ECT (1) и CE  будет больше, чем количество подтвержденных в кадре ACK пакетов. Когда происходит такое событие, и проверка прошла успешно, локальные счетчики ДОЛЖНЫ быть увеличены, чтобы соответствовать подсчетам в кадре ACK.
Обработка счетчиков не по порядку может привести в ошибке. Конечной точке НЕ СЛЕДУЕТ выполнять проверку, если кадр ACK принимается в пакете с номером ниже, чем ранее полученный кадр ACK. Проверка основанная на поступающих не по порядку кадрах ACK, может привести к ненужному отключению ECN.
После успешной проверки конечная точка продолжает устанавливать кодовые точки ECT в последующих пакетах с ожиданием того, что путь поддерживает ECN.
Если проверка не удалась, конечная точка прекращает установку кодовых точек ECT в пакетах, считая что путь или узел не поддерживают ECN.
Если конечная точка устанавливающая кодовые точки ECT для исходящих IP пакетов сталкивается с тайм-аутом повторной передачи из-за отсутствия подтверждения от узла ([QUIC-RECOVERY]) или если есть основания полагать, что на сетевом пути искажаются кодовые точки УСТ, конечная точка МОЖЕТ прекратить установку кодовых точек ECN в последующих пакетах. Это позволяет сетевому соединению быть устойчивым к сетевым элементам повреждающим кодовые точки ECN или отбрасывающих пакеты с кодовыми точками.

14. Размер пакета
Размер пакета QUIC включает в себя заголовок QUIC и зашифрованную полезную нагрузку. Но не включает заголовки UDP или IP.
Клиенты ДОЛЖНЫ отправлять первый Initial пакет в одном IP-пакете. Аналогично, первый Initial пакет после пакета Retry, ДОЛЖЕН быть отправлен в одном IP-пакете.
Полезная нагрузка датаграммы UDP несущей Initial пакет, должна быть расширена до 1200 байт путем добавления кадра PADDING и\или путем объединения Initial пакета (Раздел 12.2). Отправка датаграммы такого размера гарантирует, что сетевой путь поддерживает приемлимою Maximum Transmission Unit (MTU), и помогает уменьшить амплитуду атак на усиление вызванного ответами сервера на непроверенный адрес клиента (Раздел 8).
Датаграмма содержащая Initial пакета МОЖЕТ превышать 1200 байт, если клиент считает, что Maximum Transmission Unit (MTU) поддерживает выбранный размер.
Сервер МОЖЕТ отправить кадр CONNECTION_CLOSE с кодом ошибки PROTOCOL_VIOLATION в ответ на Initial пакет, если датаграмма UDP меньше 1200 байт. Сервер НЕ ДОЛЖЕН отправлять другой тип кадра или вести себя так, будто какая-либо часть пакета была обработана как действительная.
Сервер ДОЛЖЕН ограничить количество отправляемых байт, до проверки адреса клиента (Раздел 8).

14.1.  Path Maximum Transmission Unit (PMTU)
PMTU - максимальный размер пакета IP, включая заголовок IP, Заголовок UDP и полезную нагрузку UDP. Полезная нагрузка UDP включает заголовок QUIC, зашифрованную полезную нагрузку и любые поля аутентификации. PMTU зависит от характеристик сетевого пути. Поэтому, текущая наибольшая полезная нагрузка UDP, отправляемая реализацией, называется максимальным размером пакета QUIC.
QUIC рассчитывает на PMTU не менее 1280 байт. Это минимальный размер Ipv6 [RFC8200], который также поддерживается большинством современных сетей IPv4. Все пакеты QUIC ДОЛЖНЫ рассчитываться так, чтобы соответствовать максимальному размеру пакета для избежание фрагментации или отбрасывания.
Конечной точке СЛЕДУЕТ использовать Datagram Packetization Layer PMTU Discovery ([DPLPMTUD]) или реализовать обнаружение MTU пути (PMTUD) [RFC1191] [RFC8201], для определения возможности доставки по сетевому пути пакета требуемого размера без фрагментации.
При отсутствии этих механизмов конечные точек НЕ ДОЛЖНЫ отправлять IP-пакеты более 1280 байт. Предполагая минимальный размер IP-заголовка, это приводит к максимальному размеру QUIC пакета 1232 байта для Ipv6 и 1252 для Ipv4. Реализация QUIC МОЖЕТ учитывать при вычислении максимального размера пакета неизвестные издержки туннеля или опции/расширения заголовка IP-пакета.
Каждая пара локальных и удаленных адресов может иметь разные PMTU. Реализации QUIC, реализующие любой вид обнаружения PMTU, ДОЛЖНЫ поддерживать максимальный размер пакета для каждой комбинации локальных и удаленных IP-адресов.
Если конечная точка определяет, что PMTU между парой локальный/удаленный IP упал ниже наименьшего максимального размера пакета, отправка пакетов QUIC ДОЛЖНА прекратится. Отправляются только пробные пакеты PMTU. Конечная точка МОЖЕТ разорвать соединение, при отсутствии альтернативного пути.

14.2.  ICMP Packet Too Big Messages
Обнаружение PMTU [RFC1191] [RFC8201] основано на приеме ICMP сообщений, которые указывают, что пакет отбрасывается потому, что он больше MTU локального маршрутизатора. DPLPMTUD также может использовать эти сообщения. Такое использование сообщений ICMP потенциально опасно для off-path атак успешно угадывающих адреса используемые в пути и уменьшают PMTU до неэффективных значений.
Конечная точка ДОЛЖНА игнорировать сообщения ICMP, утверждающее уменьшение MTU ниже 1280 байт.
Требования для генерации ICMP([RFC1812], [RFC4443]) гласят, что цитируемый пакет должен содержать как можно большую часть исходного пакета, не превышая MTU для IP. Размер процитированного пакета может быть меньше или информация может быть непонятна, как описано в Разделе 1.1 [DPLPMTUD]
Конечные точки QIUC ДОЛЖНЫ проверять сообщения ICMP для защиты от off-path атак, как указано в [RFC8201] и разделе 5.2 [RFC8085]. Эта проверка ДОЛЖНА использовать цитируемый пакет, представленный в полезной нагрузке ICMP, чтобы связать сообщение с соответствующим транспортным соединением [DPLPMTUD].
Проверка сообщения ICMP ДОЛЖНА включать сопоставление IP-адресов и портов UDP [RFC8085] и, если возможно, идентификаторов соединений с активным сеансом QUIC.
Дальнейшая проверка также может включать:
o Конечная точка Ipv4 может установить флаг Don't Fragment (DF) для небольшой части пакетов. Поступление большого количества сообщений ICMP, когда нет неподтвержденных пакетов с DF, может идентифицироваться как ложные.
o Конечная точка может хранить дополнительную информацию  из заголовков IP или UDP и использовать ее для проверки.
Конечной точке СЛЕДУЕТ игнорировать все сообщения ICMP не прошедшие проверку.
Конечная точка НЕ ДОЛЖНА увеличивать PMTU на основе сообщений ICMP. Любое уменьшение максимального размера пакета QUIC МОЖЕТ быть временным, пока алгоритм контроля потерь, не определит фактическую потерю пакета.

14.3 Обнаружение PMTU уровня датаграмм
Раздел 6.4 [DPLPMTUD] содержит рекомендации по реализации PMTUD уровня датаграмм (DPLPMTUD) с помощью QUIC/
При реализации алгоритма в разделе 5.3 [DPLPMTUD] начальное значение BASE_PMTU ДОЛЖНО соответствовать минимальному размеру пакета QUIC (1232 байта для IPv6 и 1252 байта для IPv4).
Кадры PING и PADDING могут использоваться для генерации тестовых пакетов PMTU. Эти кадры не передаются повторно в случае утери содержащего их пакета. Однако, эти кадры используют окно перегрузки и могут задержать передачу последующих данных.
Кадр PING может быть включен в зонд PMTU для проверки подтверждения зонда.
Соображения по обработки сообщений ICMP из предыдущего раздела также применимы и для DPLPMTUD.

14.3.1 Зонды PMTU содержащие SCID
Конечные точки полагающиеся на SCID для маршрутизации пакетов QUIC, требуют включение ID соединения в тестовые пакеты PMTU для маршрутизации сообщений ICMP(Раздел 14.2) обратно к конечной точке. Однако, только пакеты с длинным заголовком (Раздел 17.2) содержат SCID, а пакеты с длинным заголовком не расшифровываются и не подтверждаются после завершения рукопожатия. Одним из способов создания зонда PMTU является объединение (Раздел 12.2) пакета рукопожатия (Раздел 17.2.4) с пакетом с коротким заголовком в одной датаграмме UDP. Если датаграмма UDP достигнет конечной точки, пакет Handshake будет проигнорирован, но пакет с коротким заголовком будет подтвержден. Если датаграмма UDP вызовет ICMP сообщение, то это сообщение скорее всего будет содержать SCID в указанной части UDP датаграммы.

15. Версии
Версии QUIC идентифицируются с использованием 32-разрядного числа без знака.
Версия 0x00000000 зарезервирована для представления согласования версий. Эта версия спецификации идентифицируется номером 0x00000001.
Другие версии QUIC могут иметь свойства, отличные от этой версии. Свойства QUIC, которые гарантированно будут согласованы во всех версиях протокола, описаны в [QUIC-INVARIANTS].
Версия 0x00000001 QUIC использует TLS в качестве протокола криптографического рукопожатия, как описано в [QUIC-TLS].
Версии с старшими 16 битами номера зарезервированы для использования в будущих документах IETF.
Версии следующие шаблону 0x?a?a?a?a зарезервированы для использования при принудительным согласованием версий. То есть любой номер версии, где младшие четыре бита 1010. Клиент и сервер МОГУТ объявить о поддержки любой из этих зарезервированных версий.
Зарезервированные номера версий не представляют собой настоящий протокол. Клиент МОЖЕТ использовать одну из этих версий, ожидая что сервер инициирует согласование версий. Сервер МОЖЕТ объявить о поддержке одной из этих версий ожидая, что клиент проигнорирует это значение.

16. Кодирование целых переменной длинны
Пакеты и кадры QUIC используют кодирование переменной длинны для неотрицательных целочисленных значений. Это гарантирует, что для меньших целочисленных значений требуется меньше байт для кодирования.
Кодирование целых переменной длинны QUIC резервирует два старших значащих бита первого байта для кодирования двоичного логарифма длинны в байтах. Целочисленное значение кодируется в оставшихся битах в порядке байт в сети.
Это означает, что целые числа кодируются в 1,2,4 или 8 байтах и могут кодировать 6, 14, 30, 62-битные значения соответственно. Таблица 4 суммирует свойства кодирования.
+------+--------+-------------+-----------------------+
| 2Bit | Length | Usable Bits | Range                 |
+------+--------+-------------+-----------------------+
| 00   | 1      | 6           | 0-63                  |
|      |        |             |                       |
| 01   | 2      | 14          | 0-16383               |
|      |        |             |                       |
| 10   | 4      | 30          | 0-1073741823          |
|      |        |             |                       |
| 11   | 8      | 62          | 0-4611686018427387903 |
+------+--------+-------------+-----------------------+
        Table 4: Summary of Integer Encodings
Например, восьмибайтовая последовательность c2 19 7c 5e ff 14 e8 8c декодируется в десятичное значение 151288809941952652. Четырехбайтовая последовательность 9d 7f 3e 7d декодирует до 494878333; двухбайтовая последовательность 7b bd декодирует до 15293; и один байт 25 декодирует до 37 (как и двухбайтовая последовательность 40 25).
Коды ошибок (Раздел 20) и версии (Раздел 15) описаны с использованием целых чисел, но не используют эту кодировку.

17. Формат пакетов
Ве числовые значения кодируются в сетевом порядке байт(big-endian), а все размеры полей указаны в битах. Шестнадцатеричная запись используется для описания значения полей.

17.1 Кодирование и декодирование номера пакета
Номера пакетов - это целые числа в диапазоне от 0 до 2^62-1 (Раздел 12.3). В длинных или коротких заголовках пакетов они кодируются значением от 1 до 4 байт. Количество битов, требуемых для представления номера пакета, уменьшается путем включения только наименьших значащих битов номера пакета.
Кодированный номер пакета защищен, как описано в Разделе 5.1 [QUIC-TLS].
Отправитель ДОЛЖЕН использовать размер номера пакета, способный представлять более двукратного диапазона, чем разница между наибольшим подтвержденным пакетом и номером отправляемого пакета. Узел принимающий пакет, сможет правильно декодировать номер пакета, только если пакет не задержался настолько, что после него прибыло много пакетов с более высокими номерами.  Конечной точке СЛЕДУЕТ использовать большой размер кодирования номеров пакетов, чтобы позволить восстановить номер пакета даже после прихода большого количества отправленных после пакетов.
Размер кодирования номеров пакетов должен быть минимум на один бит больше, чем логарифм по основанию 2 количества смежных неподтвержденных номеров пакетов, включая новый пакет.
Например, если конечная точка получила подтверждение для пакета 0xabe8bc, отправка пакета с номером 0xac5c02 требует кодирования номера пакета с 16 битами или более, тогда как для отправки пакета с номером 0xace8fe необходимо 24-битное кодирование номера пакета.
В приемнике защита номера пакета удаляется до восстановления полного номера пакета. Полный номер пакета восстанавливается на основе количества значимых битов, значения этих битов и наибольшего номера пакета, принятого в успешно аутентифицированном пакете. Восстановление полного номера пакета необходимо для успешного снятия защиты пакета.
Как только защита заголовка снята, номер пакета декодируется путем нахождения значения номера пакета являющимся ближайшим к следующему ожидаемому пакету. Следующий ожидаемый пакет - это наивысший номер принятого пакета плюс один. Например, если наибольший пакет с успешной аутентификацией имел номер 0xa82f30ea, тогда пакет, содержащий 16-битное значение 0x9b32, будет декодирован как 0xa82f9b32. Пример псевдокода для декодирования номера пакета можно найти в Приложении А.

17.2 Длинный заголовок пакета

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+
   |1|1|T T|X X X X|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Version (32)                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | DCID Len (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Destination Connection ID (0..160)            ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | SCID Len (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Source Connection ID (0..160)               ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    Figure 9: Long Header Packet Format
Длинные заголовки используются для пакетов, отправляемых до установления ключей 1-RTT. Как только оба условия будут выполнены, отправитель переходит на отправку пакетов с короткими заголовками (Раздел 17.3). Длинная форма позволяет представлять специальные пакеты, такие как пакет согласования версий, в унифицированном формате фиксированной длинны. Пакеты с длинными заголовками имеют следующие поля:
Header Form: для длинных заголовков самый старший бит(0x80) байта 0(первый байт) установлен в 1.
Fixed Bit: следующий бит (0x40) байта 0 установлен в 1. Пакеты, содержащие нулевое значение для этого бита, являются не действительными пакетами в этой версии и ДОЛЖНЫ быть отброшены.
Long Packet Type (T): следующие два бита (с маской 0x30) байта 0 содержат тип пакета. Типы пакетов перечислены в таблице 5.
Type-Specific Bits (X): младшие четыре бита (с маской 0x0f) байта 0 зависят от типа пакета.
Version: Версия QUIC - это 32-битное поле, которое следует за первым байтом. Это поле указывает, какая версия QUIC используется, и определяет интерпретацию остальных полей протокола.
DCID Len: байт, следующий за версией, содержит длину в байтах поля DCID, следующего за ним. Эта длина кодируется как 8-разрядное целое число без знака. В версии 1 QUIC это значение НЕ ДОЛЖНО превышать 20. Конечные точки, которые получают длинный заголовок версии 1 со значением больше 20, ДОЛЖНЫ отбрасывать пакет. Серверы ДОЛЖНЫ иметь возможность считывать более длинные идентификаторы соединений из других версий QUIC, чтобы правильно сформировать пакет согласования версий.
Destination Connection ID:  Раздел 7.2 описывает использование этого поля более подробно.
SCID Len: байт, следующий за идентификатором целевого соединения, содержит длину в байтах поля идентификатора исходного соединения, которое следует за ним. Эта длина кодируется как 8-разрядное целое число без знака. В версии QUIC 1 это значение НЕ ДОЛЖНО превышать 20 байтов. Конечные точки, которые получают длинный заголовок версии 1 со значением больше 20, ДОЛЖНЫ отбрасывать пакет. Серверы ДОЛЖНЫ иметь возможность считывать более длинные идентификаторы соединений из других версий QUIC, чтобы правильно сформировать пакет согласования версий.
Source Connection ID: Раздел 7.2 описывает использование этого поля более подробно.
В этой версии QUIC определены следующие типы пакетов с длинными заголовками:
+------+-----------+----------------+
| Type | Name      | Section        |
+------+-----------+----------------+
|  0x0 | Initial   | Section 17.2.2 |
|      |           |                |
|  0x1 | 0-RTT     | Section 17.2.3 |
|      |           |                |
|  0x2 | Handshake | Section 17.2.4 |
|      |           |                |
|  0x3 | Retry     | Section 17.2.5 |
+------+-----------+----------------+

Table 5: Long Header Packet Types

Биты Header Form, байты длин и поля DCID и SCID, и поле Version не зависят от версии протокола. Другие поля в первом байте зависят от версии. См. [QUIC-INVARIANTS] для получения подробной информации о том, как интерпретируются пакеты из разных версий QUIC.
Интерпретация полей и полезной нагрузки зависит от версии и типа пакета. Специфичная для типа семантика описана в следующих разделах, несколько пакетов с длинными заголовками в этой версии QUIC содержат дополнительные поля:
Reserved Bits (R): два бита (с маской 0x0c) байта 0 зарезервированы для нескольких типов пакетов. Эти биты защищены с помощью защиты заголовка (Раздел 5.4 [QUIC-TLS]). Значение, включенное до защиты, ДОЛЖНО быть установлено на 0. Конечная точка ДОЛЖНА обрабатывать получение пакета, который имеет ненулевое значение этих битов, после удаления защиты как пакета, так и заголовка, как ошибку соединения типа PROTOCOL_VIOLATION. Отбрасывание такого пакета только после снятия защиты заголовка может подвергнуть конечную точку атакам (Раздел 9.3 [QUIC-TLS]).
Packet Number Length (P): В типах пакетов, которые содержат поле номера пакета, младшие два бита (маска 0x03) байта 0 содержат длину номера пакета, закодированную как беззнаковое, двухразрядное целое число. Это на единицу меньше длины поля номера пакета в байтах. То есть длина поля номера пакета равна значению этого поля плюс один. Эти биты защищены с помощью защиты заголовка (Раздел 5.4 [QUIC-TLS]).
Length: длина оставшейся части пакета (то есть поля «Packet Number» и «Payload») в байтах, закодированная как целое число переменной длины (Раздел 16).
Packet Number: поле номера пакета имеет длину от 1 до 4 байт. Номер пакета имеет защиту конфиденциальности отдельно от защиты пакета, как описано в Разделе 5.4 [QUIC-TLS]. Длина поля номера пакета кодируется в битах длины номера пакета байта 0 (см. выше).

17.2.1 Пакет согласования версий
Пакет согласования версий не зависит от версии. После получения клиентом он будет идентифицирован как пакет согласования версии на основе поля версии, имеющего значение 0.
Пакет согласования версий - это ответ на пакет клиента, который содержит версию, которая не поддерживается сервером и отправляется только серверами.
Структура пакета согласования версий:
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+
   |1|  Unused (7) |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Version (32)                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | DCID Len (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Destination Connection ID (0..2040)           ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | SCID Len (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Source Connection ID (0..2040)              ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Supported Version 1 (32)                 ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   [Supported Version 2 (32)]                ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                  ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   [Supported Version N (32)]                ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                   Рисунок 10: Пакет согласования версий
Значение в поле Unused выбирается сервером случайным образом. Клиенты ДОЛЖНЫ игнорировать значение этого поля. Серверы ДОЛЖНЫ установить старший значимый бит этого поля (0x40) в 1, чтобы пакеты согласования версий имели поле Fixed Bit.
Поле Version пакета согласования версий ДОЛЖНО быть установлено в 0x00000000.
Сервер ДОЛЖЕН включать значение из поля SCID пакета, который он получает, в поле DCID. Значение для SCID ДОЛЖНО быть скопировано из DCID полученного пакета, который изначально выбирается клиентом случайным образом. Повторение обоих идентификаторов соединения дает клиентам некоторую уверенность в том, что сервер получил пакет и что пакет согласования версий не был создан off-path злоумышленником.
Поскольку будущие версии QUIC могут поддерживать идентификаторы соединений, превышающие ограничение версии 1, пакеты согласования версий поддерживают идентификаторы соединений, длина которых превышает 20 байт.
Оставшаяся часть пакета согласования версий представляет собой список 32-разрядных версий, которые поддерживает сервер.
Пакет согласования версии не может быть подтвержден клиентом в кадре ACK. Получение другого Initial пакета неявно подтверждает пакет согласования версий.
Пакет согласования версий не включает в себя поля Packet Number  и Length, присутствующие в других пакетах, которые используют форму длинного заголовка. Следовательно, пакет согласования версий использует всю дейтаграмму UDP.
Сервер НЕ ДОЛЖЕН отправлять более одного пакета согласования версий в ответ на одну дейтаграмму UDP.
См. Раздел 6 для описания процесса согласования версии.

17.2.2 Пакет Initial
Пакет Initial использует длинные заголовки со значением типа 0x0. Он переносит первые кадры CRYPTO, отправленные клиентом и сервером для выполнения обмена ключами, и ACK в любом направлении.
   +-+-+-+-+-+-+-+-+
   |1|1| 0 |R R|P P|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Version (32)                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | DCID Len (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Destination Connection ID (0..160)            ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | SCID Len (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Source Connection ID (0..160)               ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Token Length (i)                    ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            Token (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Length (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Packet Number (8/16/24/32)               ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Payload (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                         Рисунок 11: Пакет Initial
Пакет Initial содержит длинный заголовок, а также поля Length и Packet Number. Первый байт содержит зарезервированные биты и биты длины номера пакета. Между полями SCID и Length есть два дополнительных поля, специфичных для Initial пакета.
Token Length: целое число переменной длины, определяющее длину поля токена в байтах. Это значение равно нулю, если токена нет. Отправленные сервером пакеты Initial ДОЛЖНЫ установить нулевое значение поля Token Length. Клиенты получившие Initial пакет с ненулевым полем Token Length, ДОЛЖНЫ либо отбросить пакет, либо сгенерировать ошибку соединения типа PROTOCOL_VIOLATION.
Token: значение токена, который был ранее предоставлен в пакете Retry или кадре NEW_TOKEN.
Payload: полезная нагрузка пакета.
Для предотвращения несанкционированного вмешательства в middlebox, пакеты Initial защищаются ключами, зависящими от соединения и версии (начальные ключи), как описано в [QUIC-TLS]. Эта защита не обеспечивает конфиденциальность или целостность от атак on-path злоумышленников, но обеспечивает некоторый уровень защиты от off-path атакующих.
Клиент и сервер используют тип пакета Initial для любого пакета, содержащего начальное криптографическое сообщение рукопожатия. Включая в себя все случаи, когда необходимо создать новый пакет, содержащий исходное криптографическое сообщение. Например, пакеты отправленные после получения пакета Retry (Раздел 17.2.5).
Сервер отправляет первый Initial пакет в ответ клиентскому. Сервер может отправить несколько Initial пакетов. Обмен криптографическим ключом может потребовать многократных циклов передачи или повторной передачи этих данных.
Полезная нагрузка начального пакета включает в себя кадр (или кадры) CRYPTO, содержащий криптографическое сообщение рукопожатия, кадры ACK или оба. Также разрешены кадры PADDING и CONNECTION_CLOSE. Конечная точка получившая Initial пакет, содержащий другие кадры, может либо отбросить пакет как ложный, либо обработать его как ошибку соединения.
Первый пакет, отправленный клиентом, всегда включает в себя кадр CRYPTO, который содержит первое криптографическое сообщение рукопожатия. Этот пакет и криптографическое сообщение рукопожатия ДОЛЖНЫ помещаться в одну дейтаграмму UDP (см. Раздел 7). Первый отправленный кадр CRYPTO всегда начинается со смещения 0 (см. Раздел 7).
Обратите внимание, что если сервер отправляет HelloRetryRequest, клиент отправит второй Initial пакет. Этот пакет продолжит криптографическое квитирование и будет содержать кадр CRYPTO со смещением, совпадающим с размером кадра CRYPTO, отправленного в первом Initial пакете. Криптографические сообщения рукопожатия, следующие за первым, не должны помещаться в одну дейтаграмму UDP.

17.2.2.1 Отказ от Initial пакета
Клиент прекращает отправку и обработку Initial пакетов, когда он отправляет свой первый пакет рукопожатия. Сервер прекращает отправку и обработку Initial пакетов, когда он получает свой первый пакет рукопожатия. Хотя пакеты могут все еще находиться в пути или ожидать подтверждения, в дальнейшем не должно происходить обмена Initial пакетами. Начальные ключи защиты пакетов отбрасываются (Раздел 4.9.1 [QUIC-TLS]) вместе с любым состоянием восстановления потерь и контроля перегрузки (Раздел 6.5 в [QUIC-RECOVERY]).
Любые данные в кадрах CRYPTO отбрасываются - и больше не передаются - когда отбрасываются начальные ключи.

17.2.3 0-RTT
Пакет 0-RTT использует длинные заголовки со значением типа 0x1, за которым следуют поля  Length и Packet Number. Первый байт содержит зарезервированные биты и длину Packet Number. Он используется для передачи «ранних» данных от клиента на сервер как часть первого отправления до завершения рукопожатия. Как часть рукопожатия TLS, сервер может принять или отклонить эти ранние данные.
См. Раздел 2.3 [TLS13] для обсуждения данных 0-RTT и их ограничений.
   +-+-+-+-+-+-+-+-+
   |1|1| 1 |R R|P P|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Version (32)                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | DCID Len (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Destination Connection ID (0..160)            ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | SCID Len (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Source Connection ID (0..160)               ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Length (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Packet Number (8/16/24/32)               ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Payload (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                               0-RTT Packet
Номера для защищенных 0-RTT пакетов, используют то же пространство, что и пакеты защищенные 1-RTT.
После того, как клиент получит пакет Retry, 0-RTT-пакеты, вероятно, будут потеряны или отброшены сервером. Клиент МОЖЕТ попытаться повторно отправить данные в пакетах 0-RTT после отправки нового Initial пакета.
Клиент НЕ ДОЛЖЕН сбрасывать номер пакета, который он использует для пакетов 0-RTT, поскольку ключи, используемые для защиты пакетов 0-RTT, не изменятся в результате ответа на пакет Retry. Отправка пакетов с одинаковым номером пакета в этом случае может поставить под угрозу защиту для всех пакетов 0-RTT, поскольку один и тот же ключ и одноразовый номер могут использоваться для защиты разных данных.
Клиент получает подтверждения для своих пакетов 0-RTT только после завершения рукопожатия. Следовательно, сервер может ожидать, что пакеты 0-RTT начнутся с номера пакета 0. Поэтому при определении длины кодирования номера пакета для пакетов 0-RTT клиент ДОЛЖЕН предположить, что все пакеты до текущего номера пакета являются в полете, начиная с номера пакета 0. Таким образом, для пакетов 0-RTT может потребоваться кодирование с более длинным номером пакета.
Клиент НЕ ДОЛЖЕН отправлять пакеты 0-RTT, как только он начинает обработку пакетов 1-RTT с сервера. Это означает, что пакеты 0-RTT не могут содержать ответа на кадры из пакетов 1-RTT. Например, клиент не может отправить кадр ACK в пакете 0-RTT, поскольку он может подтвердить только пакет 1-RTT. Подтверждение для пакета 1-RTT ДОЛЖНО передаваться в пакете 1-RTT.
Серверу СЛЕДУЕТ рассматривать нарушение запомненных пределов как ошибку соединения соответствующего типа (например, FLOW_CONTROL_ERROR для превышения пределов данных потока).

17.2.4 Пакет Handshake
Пакет рукопожатия использует длинные заголовки со значением типа 0x2, за которым следуют поля  Length и Packet Number. Первый байт содержит зарезервированные биты и длину Packet Number. Он используется для передачи подтверждений и криптографических рукопожатий от сервера и клиента.
   +-+-+-+-+-+-+-+-+
   |1|1| 2 |R R|P P|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Version (32)                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | DCID Len (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Destination Connection ID (0..160)            ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | SCID Len (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Source Connection ID (0..160)               ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Length (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Packet Number (8/16/24/32)               ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Payload (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                   Figure 12: Handshake Protected Packet
Как только клиент получил пакет Handshake от сервера, он использует пакеты Handshake для отправки последующих криптографических сообщений рукопожатия и подтверждений на сервер.
Поле DCID в пакете Handshake содержит идентификатор соединения, выбранный получателем пакета. SCID включает в себя идентификатор соединения, который отправитель пакета желает использовать (Раздел 7.2).
У пакетов Handshake собственное пространство номеров пакетов. Таким образом, первый отправленный сервером пакет Handshake, содержит номер пакета 0.
Полезная нагрузка этого пакета содержит кадры CRYPTO и может содержать кадры PADDING или ACK. Пакеты рукопожатия МОГУТ содержать кадры CONNECTION_CLOSE. Конечные точки ДОЛЖНЫ трактовать получение пакетов рукопожатия с другими кадрами как ошибку соединения.
Подобно Initial пакетам (Раздел 17.2.2.1), данные в кадрах CRYPTO на уровне шифрования рукопожатия отбрасываются - и больше не передаются - когда отбрасываются ключи защиты рукопожатия.

17.2.5 Пакет Retry
Пакет Retry использует длинный заголовок пакета со значением типа 0x3. Он содержит маркер проверки адреса, созданный сервером. Он используется сервером, который желает повторить попытку (Раздел 8.1).
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+
   |1|1| 3 | Unused|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Version (32)                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | DCID Len (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Destination Connection ID (0..160)            ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | SCID Len (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Source Connection ID (0..160)               ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | ODCID Len (8) |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Original Destination Connection ID (0..160)        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Retry Token (*)                      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                          Figure 13: Retry Packet
Пакет Retry (показанный на рисунке 13) не содержит никаких защищенных полей. Значение в поле Unused выбирается сервером случайным образом. В дополнение к длинному заголовку он содержит следующие дополнительные поля:
ODCID Len:  содержит длину поля ODCID в байтах, которое следует за ним. Кодируется как 8-разрядное целое число без знака. В версии QUIC 1 это значение НЕ ДОЛЖНО превышать 20 байтов. Клиенты, которые получают пакет повторных попыток версии 1 со значением больше 20, ДОЛЖНЫ отбросить пакет.
Original Destination Connection ID: Содержит значение DCID из пакета Initial, на который отвечает эта повторная попытка. Длина этого поля указана в ODCID Len.
Retry Token: токен, который сервер может использовать для проверки адреса клиента.
Сервер заполняет DCID идентификатором соединения, который клиент включил в SCID пакета Initial.
Сервер устанавливает идентификатор соединения по своему выбору в поле SCID. Это значение НЕ ДОЛЖНО быть равным полю DCID отправленного клиентом пакета. Клиент ДОЛЖЕН использовать этот ИД соединения в DCID последующих отправляемых пакетах.
Клиент устанавливает поле DCID пакета Initial значением SCID пакета Retry. Изменение DCID приводит к изменению ключей, используемых для защиты пакета Initial. Также устанавливает в поле Token токен, указанный в Retry. Клиент НЕ ДОЛЖЕН изменять SCID, поскольку сервер может включать ID соединения в качестве части своей логики проверки токена (Раздел 8.1.3).
Следующий Initial пакет от клиента использует идентификатор соединения и значения токена из пакета Retry (см. Раздел 7.2). Помимо этого,  отправленный клиентом пакет Initial, подчиняется тем же ограничениям, что и первый Initial пакет. Клиент ДОЛЖЕН использовать то же криптографическое сообщение рукопожатия, которое он включает в этот пакет. Сервер МОЖЕТ рассматривать пакет, который содержит другое криптографическое рукопожатие, как ошибку соединения или отклонять ее.
Клиент МОЖЕТ предпринять попытку 0-RTT после получения пакета Retry, отправив пакеты 0-RTT на предоставленный сервером ID соединения. Клиент НЕ ДОЛЖЕН изменять криптографическое сообщение рукопожатия, которое он отправляет в ответ на получение Retry.
Клиент НЕ ДОЛЖЕН сбрасывать номер пакета для любого пространства номеров пакетов после обработки пакета Retry. Раздел 17.2.3 содержит дополнительную информацию.
Сервер подтверждает использование пакета Retry для соединения, используя транспортный параметр original_connection_id (Раздел 18.1). Если сервер отправляет пакет Retry, он ДОЛЖЕН включить значение поля ODCID в пакете Retry (то есть поле DCID из первого Initial пакета клиента) в транспортный параметр.
Если клиент получил и обработал пакет Retry, он ДОЛЖЕН проверить, что транспортный параметр original_connection_id присутствует и правильный. В противном случае он ДОЛЖЕН проверить, что транспортный параметр отсутствует. Клиент ДОЛЖЕН рассматривать неудачную проверку как ошибку соединения типа TRANSPORT_PARAMETER_ERROR.
Пакет Retry не включает номер пакета и не может быть подтвержден клиентом.

17.3 Короткий заголовок пакетов
Эта версия QUIC определяет один тип пакета использующий короткий заголовок пакета.
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+
   |0|1|S|R|R|K|P P|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                Destination Connection ID (0..160)           ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Packet Number (8/16/24/32)              ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Protected Payload (*)                   ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                   Figure 14: Формат короткого заголовка пакета
Короткий заголовок можно использовать после согласования версии и ключей 1-RTT. Пакеты, которые используют короткий заголовок, содержат следующие поля:
Header Form: самый старший бит (0x80) байта 0 устанавливается в 0 для короткого заголовка.
Fixed Bit: следующий бит (0x40) байта 0 установлен в 1. Пакеты, содержащие нулевое значение для этого бита, являются не действительными пакетами в этой версии и ДОЛЖНЫ быть отброшены.
Spin Bit (S): третий значимый бит (0x20) байта 0 является битом задержки, установленным, как описано в разделе 17.3.1.
Reserved Bits (R): следующие два бита (с маской 0x18) байта 0 зарезервированы. Эти биты защищены с помощью защиты заголовка (Раздел 5.4 [QUIC-TLS]). Значение, включенное до защиты, ДОЛЖНО быть установлено на 0. Конечная точка ДОЛЖНА обрабатывать получение пакета, который имеет ненулевое значение для этих битов, после удаления защиты как пакета, так и заголовка, как ошибку соединения типа PROTOCOL_VIOLATION. Отказ от такого пакета только после снятия защиты заголовка может подвергнуть конечную точку атакам (Раздел 9.3 [QUIC-TLS]).
Key Phase (K): следующий бит (0x04) байта 0 указывает ключевую фазу, которая позволяет получателю пакета идентифицировать ключи защиты пакета используемые для защиты пакета. Смотрите [QUIC-TLS] для деталей. Этот бит защищен с помощью защиты заголовка (Раздел 5.4 [QUIC-TLS]).
Packet Number Length (P):два младших значащих бита (маска 0x03) байта 0 содержат длину номера пакета, закодированную как беззнаковое двухбитовое целое число, которое на один меньше, чем длина пакета числовое поле в байтах. То есть длина поля номера пакета равна значению этого поля плюс один. Эти биты защищены с помощью защиты заголовка (см. Раздел 5.4 [QUIC-TLS]).
Destination Connection ID: DCID - это идентификатор соединения, выбранный предполагаемым получателем пакета. Смотри Раздел 5.1 для более подробной информации.
Packet Number: поле номера пакета имеет длину от 1 до 4 байт. Номер пакета имеет защиту конфиденциальности отдельно от защиты пакета, как описано в Разделе 5.4 [QUIC-TLS]. Длина поля номера пакета кодируется в поле длины номера пакета. Смотрите Раздел 17.1 для деталей.
Protected Payload: пакеты с коротким заголовком всегда включают защищенную полезную нагрузку 1-RTT.
269/5000
Бит  header form и connection ID пакета с коротким заголовком не зависят от версии. Остальные поля относятся к выбранной версии QUIC. См. [QUIC-INVARIANTS] для получения подробной информации о том, как интерпретируются пакеты из разных версий QUIC.

17.3.1 Lincy Spin Bit
Spin бит позволяет осуществлять пассивный мониторинг задержек из точек наблюдения на пути сети в течение всего времени соединения. Бит  присутствует только в коротком заголовке пакета, поскольку можно измерить начальный RTT соединения, наблюдая рукопожатие. Следовательно, spin бит доступен после согласования версии и установления соединения. Измерение на пути и использование spin бита дополнительно обсуждается в [QUIC-MANAGEABILITY].
Spin бит является ОПЦИОНАЛЬНОЙ особенностью QUIC. Стек QUIC, который выбирает поддержку Spin бита, ДОЛЖЕН реализовывать его, как указано в этом разделе.
Каждая конечная точка в одностороннем порядке решает, включен ли Spin бит для соединения. Реализации ДОЛЖНЫ позволять администраторам клиентов и серверов отключать Spin бит глобально или отдельно для каждого соединения. Даже если  Spin бит не отключен администратором, реализации ДОЛЖНЫ отключить Spin бит для данного соединения с определенной вероятностью. Процесс случайного выбора ДОЛЖЕН быть спроектирован таким образом, чтобы в среднем Spin бит был отключен по меньшей мере для одной восьмой части сетевых путей. Процесс выбора, выполняемый в начале соединения, ДОЛЖЕН применяться ко всем путям, используемым соединением.
В случае, если несколько соединений используют один и тот же сетевой путь, что определяется наличием одного и того же IP-адреса источника и назначения и портов UDP, конечные точки должны пытаться координировать действия всех соединений, чтобы обеспечить четкий сигнал для любых точек измерения на пути.
Когда Spin бит отключен, конечные точки МОГУТ установить бит на любое значение и ДОЛЖНЫ игнорировать любое входящее значение. РЕКОМЕНДУЕТСЯ, чтобы конечные точки устанавливали Spin бит на случайное значение, либо выбранное независимо для каждого пакета, либо выбранное независимо для каждого идентификатора соединения.
Если для соединения активирован Spin бит, конечная точка сохраняет значение spin'a и устанавливает Spin бит в коротком заголовке на текущее сохраненное значение при отправке пакета с коротким заголовком. Значение spin'a инициализируется 0 в начале подключения. Каждая конечная точка также запоминает наибольший номер пакета, видимый от его партнера по соединению.
Когда сервер получает пакет с коротким заголовком увеличивающем наивысший номер пакета, он устанавливает значение Spin'a равным Spin биту в принятом пакете.
Когда клиент получает пакет с коротким заголовком увеличивающим наивысший номер пакета, он устанавливает значение Spin'a равным инверсному значению Spin бита в принятом пакете.
Конечная точка сбрасывает свое значение Spin'a до нуля при отправке первого пакета данного соединения с новым идентификатором соединения. Это снижает риск того, что переходное состояние Spin бита может использоваться для связи потоков через миграцию соединения или изменение идентификатора.
С помощью этого механизма сервер отражает полученное Spin значение, в то время как клиент «вращает» его после одного RTT. Наблюдатели на трассе могут измерять время между двумя событиями переключения битов спина для оценки сквозного RTT соединения.

18. Кодирование транспортных параметров
Формат транспортных параметров - это структура TransportParameters из рисунка 15. Это описано с использованием языка представления из Раздела 3 [TLS13].

enum {
         original_connection_id(0),
         idle_timeout(1),
         stateless_reset_token(2),
         max_packet_size(3),
         initial_max_data(4),
         initial_max_stream_data_bidi_local(5),
         initial_max_stream_data_bidi_remote(6),
         initial_max_stream_data_uni(7),
         initial_max_streams_bidi(8),
         initial_max_streams_uni(9),
         ack_delay_exponent(10),
         max_ack_delay(11),
         disable_migration(12),
         preferred_address(13),
         active_connection_id_limit(14),
         (65535)
      } TransportParameterId;

      struct {
         TransportParameterId parameter;
         opaque value<0..2^16-1>;
      } TransportParameter;

      TransportParameter TransportParameters<0..2^16-1>;

               Figure 15: Definition of TransportParameters

Поле extension_data расширения quic_transport_parameters, определенного в [QUIC-TLS], содержит значение TransportParameters. Поэтому правила кодирования TLS используются для описания кодирования транспортных параметров.
QUIC кодирует транспортные параметры в последовательность байтов, которые затем включаются в криптографическое рукопожатие.

18.1 определения транспортных параметров
В разделе подробно описаны транспортные параметры, определенные в этом документе.
Многие перечисленные здесь транспортные параметры имеют целочисленные значения. Те транспортные параметры, которые определены как целые числа, используют целочисленное кодирование переменной длины (Раздел 16) и имеют значение по умолчанию 0 при отсутствии транспортного параметра, если не указано иное.
Определены следующие транспортные параметры:
original_connection_id (0x0000): значение поля DCID из первого Initial пакета, отправленного клиентом. Этот транспортный параметр отправляется только сервером. Сервер ДОЛЖЕН включать транспортный параметр original_connection_id, если он отправил пакет Retry.
idle_timeout (0x0001): время простоя - это значение в миллисекундах, которое кодируется как целое число; см. (раздел 10.2). Если этот параметр отсутствует или равен нулю, то время простоя отключено.
stateless_reset_token (0x0002): токен сброса без сохранения состояния используется при проверке сброса без сохранения состояния (Раздел 10.4). Этот параметр представляет собой последовательность из 16 байт. Этот транспортный параметр НЕ ДОЛЖЕН отправляться клиентом, но МОЖЕТ быть отправлен сервером. Сервер, который не отправляет этот параметр транспорта, не может использовать сброс без сохранения состояния (Раздел 10.4) для идентификатора соединения, согласованного во время рукопожатия.
max_packet_size (0x0003): параметр максимального размера пакета является целочисленным значением ограничивающим размер пакетов, которые конечная точка желает получить. Параметр указывает, что пакеты, превышающие этот предел, будут отброшены. Значение по умолчанию для этого параметра - максимально допустимая полезная нагрузка UDP, равная 65527. Значения ниже 1200 недопустимы. Ограничение применяется только к защищенным пакетам (раздел 12.1).
initial_max_data (0x0004): начальный максимальный размер данных - это целочисленное значение, которое содержит начальное значение для максимального объема данных, которые могут быть отправлены по соединению. Это эквивалентно отправке MAX_DATA (раздел 19.9) для соединения сразу после завершения рукопожатия.
initial_max_stream_data_bidi_local (0x0005): параметр является целочисленным значением, определяющим начальный предел управления потоком для локально инициируемых двунаправленных потоков. Это ограничение применяется к вновь созданным двунаправленным потокам, открытым конечной точкой, которая отправляет транспортный параметр. В транспортных параметрах клиента параметр относится к потокам с идентификатором, для которого младшие два бита установлены в 0x0. Транспортные параметры сервера ограничение применяется к потокам с двумя младшими значащими битами, установленными в 0x1.
initial_max_stream_data_bidi_remote (0x0006): параметр является целочисленным значением, определяющим начальный предел управления потоком для инициируемых узлами двунаправленных потоков. Это ограничение применяется к вновь созданным двунаправленным потокам, открытым конечной точкой, которая получает транспортный параметр. В транспортных параметрах клиента ограничение применяется к потокам с идентификатором с двумя младшими значащими битами, установленными в 0x1. Транспортные параметры сервера ограничение применяется к потокам с двумя младшими значащими битами, установленными в 0x0.
initial_max_stream_data_uni (0x0007): параметр является целочисленным значением, определяющим начальный предел управления потоком для однонаправленных потоков. Это ограничение применяется к вновь созданным однонаправленным потокам, открытым конечной точкой, которая получает транспортный параметр. В транспортных параметрах клиента ограничение применимо к потокам с идентификатором с двумя младшими значащими битами, установленными в 0x3. Транспортные параметры сервера ограничение применяется к потокам с двумя младшими значащими битами, установленными в 0x2.
initial_max_streams_bidi (0x0008): параметр является целочисленным значением, которое содержит начальное максимальное количество двунаправленных потоков, которые может инициировать узел. Если этот параметр отсутствует или равен нулю, узел не может открывать двунаправленные потоки до тех пор, пока не будет отправлен кадр MAX_STREAMS. Установка этого параметра эквивалентна отправке MAX_STREAMS (раздел 19.11) соответствующего типа с тем же значением.
initial_max_streams_uni (0x0009): параметр целочисленным значением, которое содержит начальное максимальное количество однонаправленных потоков, которые может инициировать узел. Если этот параметр отсутствует или равен нулю, узел не может открывать однонаправленные потоки, пока не будет отправлен кадр MAX_STREAMS. Установка этого параметра эквивалентна отправке MAX_STREAMS (раздел 19.11) соответствующего типа с тем же значением.
ack_delay_exponent (0x000a): параметр является целочисленным значением, указывающим показатель степени, используемый для декодирования поля задержки ACK в кадре ACK (раздел 19.3). Если это значение отсутствует, предполагается значение по умолчанию 3 (указывающее множитель 8). Значения выше 20 недействительны.
max_ack_delay (0x000b): максимальная задержка ACK является целочисленным значением, указывающим максимальное количество времени в миллисекундах, на которое конечная точка будет задерживать отправку подтверждений. Это значение ДОЛЖНО включать ожидаемые задержки получателя при срабатывании сигнализации. Например, если получатель устанавливает таймер на 5 мс, а аварийные сигналы обычно запускаются с задержкой до 1 мс, то он должен отправить max_ack_delay 6 мс. Если это значение отсутствует, предполагается значение по умолчанию 25 миллисекунд. Значения 2^14 или выше недопустимы.
disable_migration (0x000c): включение параметр транспорта отключения миграции, если конечная точка не поддерживает миграцию подключения (Раздел 9). Узлы конечной точки, которая устанавливает этот транспортный параметр, НЕ ДОЛЖНЫ отправлять какие-либо пакеты, включая проверочные пакеты (Раздел 9.1), с локального адреса или порта, отличного от того, который использовался для выполнения рукопожатия. Этот параметр является значением нулевой длины.
preferred_address (0x000d): предпочтительный адрес сервера используется для изменения адреса сервера в конце рукопожатия, как описано в разделе 9.6. Формат этого транспортного параметра - это структура PreferredAddress, показанная на рисунке 16. Этот транспортный параметр отправляется только сервером. Серверы МОГУТ выбрать отправку только предпочтительного адреса одного семейства адресов путем отправки адреса с нулевым адресом и порта (0.0.0.0:0 или ::. 0) для другого семейства.
      struct {
        opaque ipv4Address[4];
        uint16 ipv4Port;
        opaque ipv6Address[16];
        uint16 ipv6Port;
        opaque connectionId<0..18>;
        opaque statelessResetToken[16];
      } PreferredAddress;

                    Рисунок 16: Формат предпочтительного адреса

active_connection_id_limit (0x000e): максимальное количество идентификаторов соединения от узла, которое конечная точка готова сохранить. Это значение включает только идентификаторы соединения, отправленные в кадрах EW_CONNECTION_ID. Если этот параметр отсутствует, предполагается значение по умолчанию 0.
Если присутствуют транспортные параметры, устанавливающие начальные лимиты управления потоком (initial_max_stream_data_bidi_local, initial_max_stream_data_bidi_remote и nitial_max_stream_data_uni), то они эквивалентны отправке кадра MAX_STREAM_DATA (Раздел 19.10) в каждый поток соответствующего типа сразу после открытия. Если транспортный параметр отсутствует, потоки этого типа начинаются с ограничения управления потоком 0.
Клиент НЕ ДОЛЖЕН включать original connection ID,  stateless   reset token, или preferred address. Сервер ДОЛЖЕН трактовать получение любого из этих транспортных параметров как ошибку соединения типа TRANSPORT_PARAMETER_ERROR.

19. Типы и форматы кадров
Как описано в разделе 12.4, пакеты содержат один или несколько кадров. В этом разделе описываются формат и семантика основных типов кадров QUIC.

19.1 Кадр PADDING
Кадр PADDING (тип = 0x00) не имеет семантического значения. Кадры PADDING могут использоваться для увеличения размера пакета. Заполнение  использоваться для увеличения начального клиентского пакета до минимально необходимого размера или для обеспечения защиты от анализа трафика для защищенных пакетов.
Кадр PADDING не имеет содержимого. Таким образом, кадр PADDING состоит из одного байта, который идентифицирует кадр как кадр PADDING.

19.2 Кадр PING
Конечные точки могут использовать кадры PING (тип = 0x01), для проверить доступности узла. Кадр PING не содержит дополнительных полей.
Получатель кадра PING должен подтвердить пакет, содержащий этот кадр.
Кадр PING можно использовать для поддержания соединения в активном состоянии, когда приложение или протокол приложения хотят предотвратить тайм-аут соединения. Протокол приложения ДОЛЖЕН содержать руководство по условиям, при которых рекомендуется генерировать PING. Это руководство ДОЛЖНО указывать, должен ли клиент или сервер отправлять PING. Если обе конечные точки отправляют кадры PING без координации, это может привести к чрезмерному количеству пакетов и снижению производительности.
Время соединения истечет, если в течение периода, превышающего время, указанное в транспортном параметре idle_timeout (см. Раздел 10) не будут отправлены или получены пакеты. Однако, состояние в промежуточных точках может истечь раньше. Хотя REQ-5 в [RFC4787] рекомендует 2-минутный интервал ожидания, опыт показывает, что отправка пакетов каждые 15–30 секунд необходима для предотвращения потери состояния middlebox для потоков UDP.

19.3 Кадр ACK
Получатели отправляют кадры ACK (типы 0x02 и 0x03) для информирования отправителей о полученых и обработаных пакетах. Кадр ACK содержит один или несколько диапазонов ACK. Диапазоны ACK идентифицируют подтвержденные пакеты. Если тип кадра 0x03, кадры ACK также содержат сумму пакетов QUIC с соответствующими метками ECN, полученными по соединению вплоть до этой точки. Реализации QUIC ДОЛЖНЫ должным образом обрабатывать оба типа. Если реализации включили ECN для отправляемых пакетов, они ДОЛЖНЫ использовать информацию в разделе ECN для управления своим состоянием перегрузки.
Подтверждения QUIC являются безотзывными. После подтверждения пакет остается подтвержденным, даже если он не появляется в будущем кадре ACK. Это не похоже на TCP SACKs ([RFC2018]).
Ожидается, что отправитель будет повторно использовать один и тот же номер пакета в разных пространствах номеров пакетов. Кадры ACK подтверждают только те номера пакетов, которые были переданы отправителем в том же пространстве номеров пакетов, в котором был принят ACK.
Пакеты согласования версии и Retry не могут быть подтверждены, поскольку они не содержат номер пакета. Вместо того чтобы полагаться на кадры ACK, эти пакеты неявно подтверждаются следующим начальным пакетом, отправленным клиентом.
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Largest Acknowledged (i)                ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          ACK Delay (i)                      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       ACK Range Count (i)                   ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       First ACK Range (i)                   ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          ACK Ranges (*)                     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          [ECN Counts]                       ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                        Figure 17: Формат кадра ACK

Кадры ACK содержат следующие поля:
Largest Acknowledged: целое число переменной длины, представляющее наибольший номер пакета, который подтверждает узел. Обычно это самый большой номер пакета, который узел получил до генерации кадра ACK. В отличие от номера пакета в длинном или коротком заголовке QUIC, значение в кадре ACK не усекается.
ACK Delay: целое число переменной длины, представляющее дельту времени в микросекундах между тем, когда этот ACK был отправлен, и когда этот узел получил самый большой подтвержденный пакет, как указано в поле "Largest Acknowledged". Значение поля задержки ACK масштабируется путем умножения кодированного значения на 2 до степени значения транспортного параметра "ack_delay_exponent", установленного отправителем кадра ACK (см. Раздел 18.1). Такое масштабирование позволяет использовать больший диапазон значений с более коротким кодированием за счет более низкого разрешения. Поскольку получатель не использует задержку ACK для начальных пакетов и пакетов рукопожатия, отправителю СЛЕДУЕТ отправить значение 0.
ACK Range Count: Целое число переменной длины, определяющее количество полей Gap и ACK Range в кадре.
First ACK Range: целое число переменной длины, указывающее количество смежных пакетов, предшествующих наибольшему подтвержденному. Первый диапазон ACK кодируется как диапазон ACK (см. Раздел 19.3.1), начиная с самого большого подтвержденного. Таким образом, самый маленький пакет, подтвержденный в диапазоне, определяется путем вычитания значения первого диапазона ACK из самого большого подтвержденного значения.
ACK Ranges: Содержит дополнительные диапазоны пакетов, которые поочередно не подтверждаются (Gap) и подтверждаются (ACK Range) (Раздел 19.3.1.)
ECN Counts: три отсчета ECN (Раздел 19.3.2.).

19.3.1 ACK Ranges
Поле ACK Ranges состоит из чередующихся значений Gap и ACK Range в порядке убывания номера пакета. Количество значений Gap и ACK Range определяется полем ACK Range Count. Одно значения присутствует для каждого значения в поле ACK Range Count.
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           [Gap (i)]                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          [ACK Range (i)]                    ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           [Gap (i)]                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          [ACK Range (i)]                    ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                  ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           [Gap (i)]                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          [ACK Range (i)]                    ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                           Рисунок 18: ACK Ranges
Поля формирующие диапазоны ACK:
Gap (repeated):  целое число переменной длины, указывающее количество смежных неподтвержденных пакетов, предшествующих пакету, номер которого на один меньше, чем наименьшее в предыдущем диапазоне ACK.
ACK Range (repeated): целое число переменной длины, указывающее количество смежных подтвержденных пакетов, предшествующих наибольшему номеру пакета, как определено предыдущим Gap.
Значения Gap и ACK Range используют относительное целочисленное кодирование для эффективности. Хотя каждое закодированное значение является положительным, значения вычитаются, так что каждый диапазон ACK описывает постепенно уменьшающиеся номера пакетов.
Каждый диапазон ACK подтверждает непрерывный диапазон пакетов, указывая количество подтвержденных пакетов, которые предшествуют наибольшему пакету в этом диапазоне. Нулевое значение указывает, что подтверждается только самый большой номер пакета. Большие значения ACK Range указывают на больший диапазон с соответствующими более низкими значениями для наименьшего номера пакета в диапазоне. Таким образом, учитывая наибольшее количество пакетов для диапазона, наименьшее значение определяется по формуле:
smallest = largest - ack_range
Диапазон ACK подтверждает все пакеты между наименьшим номером пакета и наибольшим включительно.
Наибольшее значение для диапазона ACK определяется путем кумулятивного вычитания размера всех предыдущих диапазонов и разрывов ACK.
Каждый разрыв указывает на диапазон пакетов, которые не подтверждаются. Количество пакетов в промежутке на один больше, чем закодированное значение поля Gap.
Значение поля Gap устанавливает наибольшее значение номера пакета для последующего диапазона ACK, используя следующую формулу:
largest = previous_smallest - gap - 2
Если какой-либо вычисленный номер пакета является отрицательным, конечная точка ДОЛЖНА генерировать ошибку соединения типа FRAME_ENCODING_ERROR, указывающую на ошибку в кадре ACK.

19.3.2 Счетчики ECN
Кадр ACK использует младший значащий бит (тип 0x03) для указания обратной связи ECN и сообщения о получении пакетов QUIC со связанными ECN-кодами ECT (0), ECT (1) или CE в заголовке IP пакета. Счетчик ECN присутствует только в том случае, если тип кадра ACK равен 0x03.
Счетчик ECN анализируется только тогда, когда тип кадра ACK равен 0x03. Есть 3 счета ECN, как показано ниже:
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        ECT(0) Count (i)                     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        ECT(1) Count (i)                     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        ECN-CE Count (i)                     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
Три счетчика ECN:
ECT (0) Count: целое число переменной длины, представляющее общее количество пакетов, полученных с помощью кодовой точки ECT (0).
ECT (1) Count: целое число переменной длины, представляющее общее количество пакетов, полученных с помощью кодовой точки ECT (1).
Счетчик CE: целое число переменной длины, представляющее общее количество пакетов, полученных с помощью кодовой точки CE.
Подсчет ECN поддерживается отдельно для каждого темпа номера пакета.

19.4  Кадр RESET
Конечная точка использует кадр RESET_STREAM (тип = 0x04) для завершения отправляющей части потока.
После отправки RESET_STREAM конечная точка прекращает передачу и повторную передачу кадров STREAM в идентифицированном потоке. Получатель RESET_STREAM может отбросить любые данные, которые он уже получил в этом потоке.
Конечная точка, которая принимает кадр RESET_STREAM для отправляющего потока, ДОЛЖНА разорвать соединение с ошибкой STREAM_STATE_ERROR.
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Stream ID (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                  Application Error Code (i)                 ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Final Size (i)                       ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
Кадры RESET_STREAM содержат следующие поля:
Stream ID: кодированное целочисленное переменной длины значение идентификатора завершаемого потока.
Application Protocol Error Code: целое число переменной длины, содержащее код ошибки протокола приложения (Раздел 20.1), указывающий причину закрытия потока.
Final Size: целое число переменной длины, указывающее конечный размер потока отправителем RESET_STREAM в единицах байт.

19.5 Кадр STOP_SENDING
Конечная точка использует кадр STOP_SENDING (тип = 0x05) для сообщения, что входящие данные отбрасываются при получении по запросу приложения. STOP_SENDING запрашивает, чтобы узел прекратил передачу в потоке.
Кадр STOP_SENDING может быть отправлен для потоков в состояниях Recv или Size Known (Раздел 3.1). Получение кадра STOP_SENDING для локально инициируемого потока, который еще не был создан, ДОЛЖЕН рассматриваться как ошибка соединения типа STREAM_STATE_ERROR. Конечная точка, которая получает кадр STOP_SENDING для только принимающего потока, ДОЛЖНА разорвать соединение с ошибкой STREAM_STATE_ERROR.
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Stream ID (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                  Application Error Code (i)                 ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
Кадры STOP_SENDING содержат следующие поля:
Stream ID: целое число переменной длины, содержащее идентификатор потока игнорируемого потока.
Application Error Code: целое число переменной длины, содержащее указанную приложением причину, по которой отправитель игнорирует поток (Раздел 20.1).

19.6 Кадр CRYPTO
Кадр CRYPTO (тип = 0x06) используется для передачи криптографических сообщений рукопожатия. Он может быть отправлен во всех типах пакетов. Кадр CRYPTO предлагает криптографическому протоколу упорядочный поток байт. Кадры CRYPTO функционально идентичны кадрам STREAM, за исключением того, что они не несут идентификатор потока. Они не контролируются потоком и они не несут маркеры для необязательного смещения, необязательной длины и конца потока.
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Offset (i)                         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Length (i)                         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Crypto Data (*)                      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 19: Формат кадра CRYPTO
Кадр CRYPTO содержит следующие поля:
Offset: целое число переменной длины, указывающее смещение байта в потоке для данных в кадре CRYPTO.
Length: целое число переменной длины, определяющее длину поля Crypto Data в кадре CRYPTO.
Crypto Data: данные криптографического сообщения.
Существует отдельный поток криптографических данных рукопожатия на каждом уровне шифрования, каждый из которых начинается со смещением 0. Это означает, что каждый уровень шифрования обрабатывается как отдельный поток данных CRYPTO.
В отличие от кадров STREAM, которые включают идентификатор потока, указывающий, к какому потоку принадлежат данные, кадр CRYPTO переносит данные для одного потока на уровень шифрования. Поток не имеет явного окончания, поэтому кадры CRYPTO не имеют бита FIN.

19.7 Кадр NEW_TOKEN
Сервер отправляет кадр NEW_TOKEN (тип = 0x07), чтобы предоставить клиенту токен для отправки в заголовке Initial пакета для будущего соединения.
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Token Length (i)                     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            Token (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


Кадры NEW_TOKEN содержат следующие поля:
Token Length:: целое число переменной длины, указывающее длину токена в байтах.
Token: непрозрачный большой двоичный объект, который клиент может использовать с будущим Initial пакетом.

19.8 Кадр STREAM
Кадры STREAM неявно создают поток и переносят данные потока. Кадр STREAM принимает форму 0b00001XXX (или набор значений от 0x08 до 0x0f). Значение трех младших битов типа кадра определяет поля, которые присутствуют в кадре.
o Бит OFF (0x04) в типе кадра установлен, чтобы указать, что присутствует поле Offset. Если установлено значение 1, поле смещения присутствует. При значении 0 поле «Смещение» отсутствует, и данные потока начинаются со смещения 0 (то есть кадр содержит первые байты потока или конец потока, который не содержит данных).
o Бит LEN (0x02) в типе кадра установлен, чтобы указывать на наличие поля длины. Если этот бит установлен в 0, поле длины отсутствует, а поле данных потока продолжается до конца пакета. Если этот бит установлен в 1, поле длины присутствует.
o Бит FIN (0x01) типа кадра устанавливается только для кадров, которые содержат окончательный размер потока. Установка этого бита указывает, что кадр отмечает конец потока.
Конечная точка, которая принимает кадр STREAM для потока, предназначенного только для отправки, ДОЛЖНА разорвать соединение с ошибкой STREAM_STATE_ERROR.
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Stream ID (i)                       ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         [Offset (i)]                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         [Length (i)]                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Stream Data (*)                      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 20: STREAM Frame Format
Кадры STREAM содержат следующие поля:
Stream ID: целое число переменной длины, обозначающее идентификатор потока (Раздел 2.1).
Offset: целое число переменной длины, определяющее смещение байта в потоке для данных в этом кадре STREAM. Это поле присутствует, когда бит OFF установлен в 1. Когда поле Offset отсутствует, смещение равно 0.
Length: целое число переменной длины, определяющее длину поля данных потока в этом кадре STREAM. Это поле присутствует, когда бит LEN установлен в 1. Когда бит LEN установлен в 0, поле Stream Data потребляет все оставшиеся байты в пакете.
Stream Data: байты из назначенного потока для доставки.
Когда поле Stream Data имеет длину 0, смещение в кадре STREAM является смещением следующего байта, который будет отправлен.
Первый байт в потоке имеет смещение 0. Наибольшее смещение потока, сумма смещения и длины данных, не может превышать 2^62-1, так как невозможно предоставить лемит управления потоком для этих данных. Получение кадра, превышающего этот предел, будет рассматриваться как ошибка соединения типа FLOW_CONTROL_ERROR.

19.9 Кадр MAX_DATA
Кадр MAX_DATA (тип = 0x10) используется в управлении потоком, для информирования узела о максимальном объеме данных, которые могут быть отправлены по соединению в целом.
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Maximum Data (i)                     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
Кадры MAX_DATA содержат одно поле:
Maximum Data: целое число переменной длины, указывающее максимальный объем данных, которые могут быть отправлены по всему соединению, в байтах.
Все данные, отправленные в кадрах STREAM, учитываются в этом пределе. Сумма наибольших принятых смещений во всех потоках, включая потоки в терминальных состояниях, НЕ ДОЛЖНА превышать значение, объявленное получателем. Конечная точка ДОЛЖНА разорвать соединение с ошибкой FLOW_CONTROL_ERROR, если она получает больше данных, чем отправленное максимальное значение данных, если только это не является результатом изменения начальных пределов (Раздел 7.3.1).

19.10 Кадр MAX_STREAM_DATA
Кадр MAX_STREAM_DATA (тип = 0x11) используется в управлении потоком для информирования узел о максимальном объеме данных, которое может быть отправлено в потоке.
Кадр MAX_STREAM_DATA может быть отправлен для потоков в состоянии Recv (Раздел 3.1). Получение кадра MAX_STREAM_DATA для локально инициируемого потока, который еще не был создан, ДОЛЖЕН рассматриваться как ошибка соединения типа STREAM_STATE_ERROR. Конечная точка, которая принимает кадр MAX_STREAM_DATA для только принимающего потока, ДОЛЖНА разорвать соединение с ошибкой STREAM_STATE_ERROR.
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Stream ID (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Maximum Stream Data (i)                  ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
Кадры MAX_STREAM_DATA содержат следующие поля:
Stream ID: Идентификатор потока, кодируется как целое число переменной длины.
Maximum Stream Data: целое число переменной длины, указывающее максимальный объем данных в байтах, которые могут быть отправлены в указанном потоке.
При подсчете данных до этого предела конечная точка учитывает наибольшее полученное смещение данных, отправленных или полученных в потоке. Потеря или переупорядочение может означать, что наибольшее смещение принятого в потоке может быть больше, чем общий размер данных, полученных в этом потоке. Прием кадров STREAM может не увеличивать наибольшее полученное смещение.
Данные, передаваемые в потоке, НЕ ДОЛЖНЫ превышать максимальное максимальное значение данных потока, объявленное получателем. Конечная точка ДОЛЖНА прервать соединение с ошибкой FLOW_CONTROL_ERROR, если она получает больше данных, чем максимальное значение которое она отправила для потока. Если только это не является результатом изменения начальных пределов (Раздел 7.3.1).

19.11 Кадр MAX_STREAMS
Кадры MAX_STREAMS (type = 0x12 и 0x13) информируют узел о совокупном количестве потоков данного типа, которые ему разрешено открывать. Кадр MAX_STREAMS с типом 0x12 применяется к двунаправленным потокам, а кадр MAX_STREAMS с типом 0x13 применяется к однонаправленным потокам.
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Maximum Streams (i)                     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
Кадры MAX_STREAMS содержат следующее поле:
Maximum Streams: количество накопленных потоков соответствующего типа, которые можно открыть за время существования соединения.
Потеря или переупорядочение может привести к получению кадра MAX_STREAMS, в котором указывается более низкий предел потока, чем ранее полученная конечная точка. Кадры MAX_STREAMS, которые не увеличивают ограничение потока, ДОЛЖНЫ игнорироваться.
Конечная точка НЕ ​​ДОЛЖНА открывать больше потоков, чем разрешено текущим ограничением потока, установленным узлом. Например, серверу, который получает ограничение однонаправленного потока в 3, разрешено открывать поток 3, 7 и 11, но не поток 15. Конечная точка ДОЛЖНА завершать соединение с ошибкой STREAM_LIMIT_ERROR, если узел открывает больше потоков, чем было разрешено.
Обратите внимание, что эти кадры (и соответствующие транспортные параметры) не описывают количество потоков, которые могут быть открыты одновременно. Ограничение включает в себя потоки, которые были закрыты, а также те, которые открыты.

19.12 Кадр DATA_BLOCKED
Отправителю СЛЕДУЕТ отправить кадр DATA_BLOCKED (тип = 0x14), когда он хочет отправить данные, но не может из-за управления потоком на уровне соединения (Раздел 4). Кадры DATA_BLOCKED могут использоваться в качестве входных данных для настройки алгоритмов управления потоком (Раздел 4.2).
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Data Limit (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Data Limit: целое число переменной длины, указывающее уровень ограничения соединения, при котором произошла блокировка.

19.13 Кадр STREAM_DATA_BLOCKED
Отправителю СЛЕДУЕТ отправить кадр STREAM_DATA_BLOCKED (тип = 0x15), когда он хочет отправить данные, но не может из-за управления потоком на уровне потока. Этот кадр аналогичен DATA_BLOCKED (Раздел 19.12).
Конечная точка, которая получает кадр STREAM_DATA_BLOCKED для потока только для отправки, ДОЛЖНА разорвать соединение с ошибкой STREAM_STATE_ERROR.
Кадр STREAM_DATA_BLOCKED выглядит следующим образом:
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Stream ID (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Stream Data Limit (i)                    ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Кадры STREAM_DATA_BLOCKED содержат следующие поля:
Stream ID: целое число переменной длины, указывающее поток, который заблокирован для управления потоком.
Stream Data Limit: целое число переменной длины, указывающее смещение потока, при котором произошла блокировка.

19.14 Кадр STREAMS_BLOCKED
Отправителю СЛЕДУЕТ отправить кадр STREAMS_BLOCKED (тип = 0x16 или 0x17), когда он хочет открыть поток, но не может этого сделать из-за максимального ограничения потока, установленного узлом (Раздел 19.11). Кадр STREAMS_BLOCKED типа 0x16 используется для указания достижения предела двунаправленного потока, а кадр STREAMS_BLOCKED типа 0x17 указывает достижение предела однонаправленного потока.
Кадр STREAMS_BLOCKED не открывает поток, но информирует одноранговый узел о том, что необходим новый поток, и ограничение потока препятствовало созданию потока.
Кадры STREAMS_BLOCKED имеют следующий вид:
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Stream Limit (i)                     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
Кадры STREAMS_BLOCKED содержат следующие поля:
Stream Limit: целое число переменной длины, указывающее ограничение потока на момент отправки кадра.

19.15 Кадр NEW_CONNECTION_ID
Конечная точка отправляет кадр NEW_CONNECTION_ID (тип = 0x18), чтобы предоставить своему партнеру альтернативные идентификаторы соединений, которые можно использовать для нарушения связности при миграции соединений (Раздел 9.5).
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Sequence Number (i)                    ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Retire Prior To (i)                    ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Length (8)  |                                               |
   +-+-+-+-+-+-+-+-+       Connection ID (8..160)                  +
   |                                                             ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                   Stateless Reset Token (128)                 +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   
Кадры NEW_CONNECTION_ID содержат следующие поля:
Sequence Number: порядковый номер, назначенный идентификатору соединения отправителем (Раздел 5.1.1).
Retire Prior To: целое число переменной длины, указывающее, какие идентификаторы соединений должны быть удалены (Раздел 5.1.2).
Length: 8-разрядное целое число без знака, содержащее длину идентификатора соединения. Значения меньше 1 и больше 20 недопустимы и ДОЛЖНЫ рассматриваться как ошибка соединения типа PROTOCOL_VIOLATION.
Connection ID: Идентификатор соединения указанной длины.
Stateless Reset Token: 128-битное значение, которое будет использоваться для сброса без сохранения состояния при использовании соответствующего идентификатора соединения (см. Раздел 10.4).
Конечная точка НЕ ​​ДОЛЖНА отправлять этот кадр, если она в данный момент требует, чтобы узлы отправляли пакеты с DCID нулевой длины. Изменение длины идентификатора соединения с нулевой длиной затрудняет определение, когда значение идентификатора соединения изменилось. Конечная точка, которая отправляет пакеты с DCID нулевой длины, ДОЛЖНА трактовать получение кадра NEW_CONNECTION_ID как ошибку соединения типа PROTOCOL_VIOLATION.
Ошибки передачи, тайм-ауты и повторные передачи могут привести к тому, что один и тот же кадр NEW_CONNECTION_ID будет получен несколько раз. Получение одного и того же кадра несколько раз НЕ ДОЛЖНО рассматриваться как ошибка соединения. Получатель может использовать порядковый номер, указанный в кадре NEW_CONNECTION_ID, чтобы идентифицировать новые идентификаторы соединения из старых.
Если конечная точка получает кадр NEW_CONNECTION_ID, который повторяет ранее выданный идентификатор соединения с другим токеном сброса без сохранения состояния или другим порядковым номером, или если порядковый номер используется для разных идентификаторов соединения, конечная точка МОЖЕТ рассматривать кадр ​​как ошибку соединения типа PROTOCOL_VIOLATION.
Поле «Retire Prior To» - это запрос на то, чтобы узел удалил все идентификаторы соединения с порядковым номером, меньшим указанного значения. Это включает в себя исходные и предпочтительные идентификаторы соединения с транспортным параметром. Узел ДОЛЖЕН удалить соответствующие идентификаторы соединения и своевременно отправить соответствующие кадры RETIRE_CONNECTION_ID.
Поле «Retire Prior To» ДОЛЖНО быть меньше или равно полю порядкового номера. Получение значения, большего, чем порядковый номер, ДОЛЖНО рассматриваться как ошибка соединения типа ROTOCOL_VIOLATION.
Как только отправитель указывает значение «Retire Prior To», меньшие значения, отправленные в последующих кадрах NEW_CONNECTION_ID, не действуют. Получатель ДОЛЖЕН игнорировать все поля «Retire Prior To», которые не увеличивают наибольшее полученное значение «Retire Prior To».