quic: базирующийся на UDP мультиплексный и безопасный транспортный протокол.

Анотация
Документ определяющий ядро транспортного протокола QUIC. Сопутствующий документ описывает QUIC детекцию потерь пакетов и контроль переполнения и использования обмена ключей TLS.

Введение
QUIC мультиплексируемый и безопасный транспортный протокол общего назначения и обеспечивает:
мультиплексирование потоков
управление потоком на уровне соединения
малая задержка на установку соединения
миграция соединения и устойчивость к NAT пересоединениям
аутентификация и шифрования заголовков и полезной нагрузки

Структура документа
Документ описывает ядро протокола QUIC и состоит из следующих частей.
Потоки как базовые абстракции предоставляемые QUIC:
	Секция 2 описывает основные понятия связаные с потоками.
	Секция 3 предоставляет базовую модель состояний потоков.
	Секция 4 основные операции контроля потока.
Соединения - контекст, в котором взаимодействую конечные точки QUIC.
	Секция 5 описывает основные понятия связаные с соединениями.
	Секция 6 описывает версии согласования.
	Секция 7 детальный процесс установки соединения.
	Секция 8 особености критических механизмов предотвращиения отказов в обслуживании.
	Секция 9 описывает каким образом конечные точки мигрирую соединения в новом сетевом окружении.
	Секция 10 список опций для завершения и открытия соединения.
	Секция 11 предоставляет основное руководство для обраблотки ошибок.
Пакеты и кадры основные еденицы используемы в соединениях QUIC.
	Секция 12 описывает понятия связаные с пакетами и фреймами.
	Секция 13 определяет модель для передачи, ретрянсляции и подтверждения данных.
	Секция 14 спецификация правил для управления размером пакета.
Детальная расшифровка элементов протокола QUIC, описывает:
	Секция 15 версии.
	Секция 16 целочисленное кодирование.
	Секция 17 заголовки пакета.
	Секция 18 транспортные параметры.
	Секция 19 кадры.
	Секция 20 ошибки.

Дополнительные документы описывают детектирование потери пакетов и управления перегрузкой (QUIC-RECOVERY) и использование ЕДЫ для обмена ключами (QUIC-TLS).

1.2. Термины и определения.

Обычно используемые термины в документе описаны ниже.

QUIC: Транспортный протокол описаный в документе. QUIC это название, a не акроним.
Пакет QUIC: Полноценно обрабатываемая единица QUIC инкапсулированная в UDP датаграму. Множество пакетов QUIC могут быть инкапсулированы в одну UDP датаграму.
Конечная точка: субьект, который может участвовать в установлении QUIC соединения, приеме и обработки пакетов. Существуют только два вида конечных точек QUIC: клиент и сервер.
Клиент: конечная точка инициализирующая соединение.
Сервер: конечная точка принимающая входящее QUIC соединение.
ID соединения: непрозрачный идентификатор используемый для идентификации QUIC соединенияв конечной точке. Каждая конечная точка устанавливает значения для своего партнера и включает его в пакет отправляемый к конечной точке.
Поток: однонаправленный или двунаправденный канал для обмена байтами в QUIC соединении. QUIC соединение несет множество одновленыенных потоков.
Приложение: объект использующий QUIC для передачи и приема данных.

1.3 national conventions
Диаграммы пакетов и фреймов в этом документеиспользуют формат описаный в Секции 3.1 RFC2360, с следованием дополнительных соглашений:
[x]: указанный х опционален.
х (А): указанный х длинной А бит.
х (А/В/С): указанный х длинной А, В или С бит.
х (i): указанный х длинной переменное количество бит, расшифровка в Секции 16.
х (*): указанный х длинной переменное число бит.

2. Потоки
Потоки в QUIC предоставляют легкие, ориентированные на упорядоченый поток байт абстранции для приложений. Потоки могут быть однонаправленные и двунаправленные. Альтернативное представлений однонаправленных потоков в QUIC есть "сообщение" практически неограниченной длинны.
Потоки могут быть созданы для передачи даннных. Остальные процессы связанные с управлением потоком - окончание, отмена и управление потоком - разработаны с целью уменьшения накладных расходов. Для примера, одиночный потоковый фрейм  может быть открыт, передать данные и закрыть поток. Потоки могут быть долгоживущими и могут длинтся все время соединения.
Потоки могут создавать все конечные точки, могут однновременно передавать данные с другими потоками и могут быть отменены. QUIC не обеспечивает порядок байт между разными потоками.
QUIC допускает одновременно произвольное число потоков и передавать произвольное количество данных в любом потоке, с учетом ограничей накладываемых управление потоком(смотри Секцию 4).

2.1 Типы потоков и идентификаторов.
Потоки могут быть однонаправленными и двунаправленными. Однонаправленный поток передает данные только в одном направлении: от инициатора потока к получателю. Двунаправленный поток может передавать данные в обоих направлениях.
Потоки идентифицируются в соединении с помощью цифрового значения, называемым ID потока. ID потока это 62-х битное целое (от 0 до 2^62-1) иникальное для всех потоков данного соединения. ID потока записывается в целое переменой длинны(Секция 16). Конечная точка QUIC не имеет права переиспользовать ID потока в соединении.
Первый значащий бит (0х1) в ID потока идентифицирует инициатора потока. Инициируемый клиентом поток имеет четный номер(бит установлен в 0), а инициируемый сервером нечетный(бит установлен в 1).
Второй значащий бит (0х2) в ID потока отличает двунаправленный поток(бит установлен в 0) от однонаправленного (бит установлен в 1).
Два первых значащих бита в ID потока идентифицируют поток как один из четырех типов представленных в таблице 1

Биты	Тип потокам
0х0		Инициализировано клиентом, Двунаправленный
0х1		Инициализированный сервером, Двунаправленный
0х2		Инициализированный клиентом, Однонаправленный
0х3		Инициализированный сервером, Однонаправленный

Внутри каждого типа, потоки создаются с числовым увеличением ID потока. ID потока, используемый не по порядку, приводит к тому, что будут открыты все потоки с меньшими порядковыми номерами.
Первый двунаправленный поток открываемый клиентом имеет ID потока 0.

2.2 Отправка и прием данных.
Фрейм потока(Секция 19.8) инкапсулирует данные отправленные приложением. Конечная точка использует ID потока и поле смещения в фрейме для размещения данных.
Конечная точка может быть в состоянии доставить данные приложению в порядке потока байтов. Доставка потока байтов требует от конечной точки буферизировать любые данные полученые не по порядку, до достижения лимита управления потока.
QUIC не делает никаких специальных указаний для доставки потоком данных не по порядку. Тем не менее, реализация может предлагать возможность доставки приложению данных пришедших не по порядку.
Конечная точка может получать данные для потока с одинаковым смещением несколько раз. Данные которые были уже получены отбрасываются. Данные с данным смещением не могут быть изменены, если они были отправлены несколько раз. Конечная точка может воспринимать получение разных данных с одинаковым смещением в одном потоке как ошибку соединения типа PROTOCOL_VIOLATION.
Потоки - абстракция упорядоченого потока байтов, с не видимой структурой для QUIC. Фрейм потока не сохраняет границы данных при передаче, ретрансляции потеряного пакета и доставки до приложения на стороне приемника.
Конечная точка не может отправить данные в поток без обеспечения в пределах лимита управления потоком установленым второй стороной. Управление потоком детально описывается в Секции 4.

2.3 Приоритизация потоков.
Мультиплексирование потоков может оказать существенное влияние на производительность приложений, если ресурсы, выделеные потокам, имеют правильный приоритет.
QUIC не предоставляет механизм для обмена информацией о приоритетах. Вместо этого, полагается на получение информации о приоритетах от приложения использующего QUIC.
Рализация QUIC ДОЛЖНА предоставлять пути которые позволят приложению узнать относительные приоритеты потоков. При решении каким потокам выделять ресурсы, реализация ДОЛЖНА использовать информацию предоставленую приложением.

3. Состояние потоков.
Эта секция описывает потоки в терминах компонентов приема и передачи. Описываются два конечных автомата: один для описания передающмх потоков конечной точки(Секция 3.1), другой для принимающих потоков конечной точки(Секция 3.2).
Однонаправленные потоки используют соответствующий конечный автомат. Двунапрвленные потоки используют оба конечных автомата. По большей части использование этих конечных автоматов одинаковое является ли поток однонаправленным или двунаправленным. Условия для открытия двунаправленного потока немного сложнее, потому что, отправляющая и принимающая сторона открывают поток в двух направлениях.
Конечная точка ДОЛЖНА открывать потоки того же типа в порядке ввозрастания ID потока.
Замечание: Эти состояния являются во многом информативными. Этот документ использует состояния потока для описания правил отправки разных типов кадров, и реакции на получение разных типов кадров. Хотя конечный автомат реализовывать QUIC, эти состояния не должны стеснять реализацию.Реализация может обьявлять различные конечные автоматы до тех пор, пока его поведение соответсвует реализации, реализующей эти состояния.

3.1 Состояния потока передачи.
На Рисунке 1 показаны состояния передающей части потока отправляющей данные узлу.
 o
          | Create Stream (Sending)
          | Peer Creates Bidirectional Stream
          v
      +-------+
      | Ready | Send RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Send STREAM /             |
          |      STREAM_DATA_BLOCKED  |
          |                           |
          | Peer Creates              |
          |      Bidirectional Stream |
          v                           |
      +-------+                       |
      | Send  | Send RESET_STREAM     |
      |       |---------------------->|
      +-------+                       |
          |                           |
          | Send STREAM + FIN         |
          v                           v
      +-------+                   +-------+
      | Data  | Send RESET_STREAM | Reset |
      | Sent  |------------------>| Sent  |
      +-------+                   +-------+
          |                           |
          | Recv All ACKs             | Recv ACK
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Recvd |                   | Recvd |
      +-------+                   +-------+

               Рисунок 1: Состояния передающей части потоков.

Передающая часть потока конечной точки начинает (тип 0 и 2 для клиента, 1 и 3 для сервера) с открывается приложением. Состояние "Ready" представляет собой вновт созданный поток в состоянии принять данные от приложения. Данные потока могут быть помещены в буфер пля подготовки к отправлению.
Передав первым кадры STREAM и STREAM_DATA_BLOCKED передающая часть потока входит в состояние "Send". Реализация может отложить выделение ID потока, пока не отправит первый кадр STREAM и войти в это состояние, что позволит лучше использовать приоритезащию потоков.
Передающая часть двунаправленного потока инициированная удаленным узлом(тип 0 для сервера, тип 1 для клиента) входит в состояние "Ready" и немедленно переходит в состояние "Send" если принимающая часть переходит в состояние "Recv" (Секция 3.2)
В состоянии "Send" конечная точка  передает - и ретранслирует если необходимо, - в потоке кадр STREAM. Конечная точка соблюдает лимитыы управления потоком установленые удаленным участниуком, и продолжает принимать м обрабатывать кадры MAX_STREAM_DATA. Конечная точка в состоянии "Send" генерирует кадры STREAM_DATA_BLOCKED, если лимины управления потоком блокируют передачу потока или соединения (Секция 4.1).
После того, как приложение указало, что все данные потока были переданы и отправлен кадр STRERAM содержащий бит FIN, передающая часть потока переходит в состояние "Data Send". В этом состоянии, конечная точка только повторяет передачу данных если необходимо. Конечная точка не нуждается в проверке лимитов управления потоком или отправки кадров STREAM_DATA_BLOCKED для потока в этом состоянии. Кадры MAX_STREAM_DATA могут приниматься до тех пор пока удаленный участник не примет конец смещения потока. Конечная точка может безопасно игнорировать все MAX_STREAM_DATA кадры полученые от удаленного участника для потока в этом состоянии.
Когда все данные потока успешно подтвердятся, передающая часть потока переходит в состояние "Data Recvd", которое является конечным состоянием.
Для любого состояния "Ready","Send" и "Data Send", приложение может послать сигная с требованием закончить передачи данных. Конечная точка также может принять кадр STOP_SENDING от удаленного участника. В любом случае, конечная точка передает кадр RESET_STREAM, что приводит поток к переходу в сотояние "Reset Send"
Конечная точка МОЖЕТ послать RESET_STREAM в качестве первого кадра упоминаемого в потоке; в этом случае передающая часть открывает поток и немедленно переходит в состояние "Reset Sent".
Когда пакет включает RESET_STREAM успешно подтверждены, передающая часть потока переходит в состояние "Reset Recvd"? кторое является конечным состоянием.

3.2 Состояние потока приема
Рисунок 2 показывает состояния для принимающей части потока от удаленного узла. Принимающая часть отражает только некоторые состояния передающей части удаленного узла. Принимающая часть не отслеживает состояние отправителя которые нельзя наблюдать, такие как состояние "Ready". Вместо этого, принимающая часть отслеживает доставку данных приложению, некоторые из которых не могут быть отслежены отправителем.

          o
          | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM
          | Create Bidirectional Stream (Sending)
          | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)
          | Create Higher-Numbered Stream
          v
      +-------+
      | Recv  | Recv RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Recv STREAM + FIN         |
          v                           |
      +-------+                       |
      | Size  | Recv RESET_STREAM     |
      | Known |---------------------->|
      +-------+                       |
          |                           |
          | Recv All Data             |
          v                           v
      +-------+ Recv RESET_STREAM +-------+
      | Data  |--- (optional) --->| Reset |
      | Recvd |  Recv All Data    | Recvd |
      +-------+<-- (optional) ----+-------+
          |                           |
          | App Read All Data         | App Read RST
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Read  |                   | Read  |
      +-------+                   +-------+

              Рисунок 2: Состояния принимающей частии потокам

Принимающая часть потока инициализируется удаленным узлом (тип 1 и 3 для клиента, и 0 и 2 для сервера), получением кадра STREAM, STREAM_DATA_BLOCKED или RESET_STREAM. Для двунаправленнй потоков инициируемых удаленным узелом, получением кадра MAX_STREAM_DATA или STOP_SENDING, и для отправляющей части части также создается принимающая. Начальное состояние принимаюшей части "Recv".
Принимающая часть вводится в состояние "Recv" когда, созданная передающая часть двунаправленного потока (тип 0 для клиента и тип 1 для сервера)переходит в состояние "Ready".
Конечная точка открывает двунаправленный поток когда получает от удаленного узла кадр MAX_STREAM_DATA или STOP_SENDING. Полученный кадр MAX_STREAM_DATA для закрытого потока указывает, что удаленный узел открыл поток и предоставил управление потоком. Получение кадра STOP_SENDING для неоткрытого потока от удаленного узла означает, что он больше не желает получать данные данные из этого потока. Любой другой кадр прибывший до STREAM или STREAM_DATA_BLOCKED может быть кадром из переупорядоченого пакета.
Перед создание потока, все потоки этого типа с меньшим номером ID потока ДОЛЖНЫ быть созданы. Это гарантирует создание согласованых потоков в конечных точках.
В состоянии "Recv", конечная точка получает кадр STREAN или STREAM_DATA_BLOCKED. Поступающие данные буферизируются и могут быть пересобраны для корректной доставки приложению. Поскольку данные потребляются приложением и имеется пространство в буффере, конечная точка отправляет кадр MAX_STREAM_DATA разрешающий отправить удаленному узлу больше данных.
Когда кадр STREAM с установленным бито FIN получен, финальный размер потока известен (смотри Секцию 4.4). Принимающая часть потока переходит в состояние "Size Known". В этом состоянии, конечной точке больше не нужно отправлять кадр MAX_STREAM_DATA, только принимать все передаваемые данные.
Когда все данные для потока были приняты, принимающая часть переходит в состояние "Data Recvd". Может произойти переход в состояние "Size Known" в результате получения кадра STREAM. После того как все данные получены, любой кадр STREAM или STREAM_DATA_BLOCKED для потока отбрасывается.
Состояние "Data Recvd" сохраняется до тех пор пока данные доставляются приложению. Когда данные потока доставлены, поток переходит в состояние "Data Read", являющемся конечным состоянием.
Получение кадра RESET_STREAM в состоянии "Recv" или "Size Known" является причиной для перехода в состояние "Reset Recvd". Это может привести к прерыванию доставки данных в примложение.
Возможно, что все данные потока получены, когда прибыл кадр RESET_STREAM(то есть, в состоянии "Data Recvd"). Так же возможно, что остальные данные потока прибудут после получения кадра RESET_STREAM(в состоянии "Reset Recvd"). Выбор как поступить в данной ситуации отдается конкретной реализации.
Отправка RESET_STREAM означает, что конечная точка не может гарантировать доставку данных потока; однако, нет требования , что данные потока не доставляются если получено RESET_STREAM. Реализация МОЖЕТ прервать доставку данных, отбросить все непотребленные данные и сигнал RESET_STREAM. Сигнал RESET_STREAM можно подавить или задержать если данные полностью получены и буферизированы для чтения приложением. Если RESET_STREAM подавлен, то принимающая часть остается в состоянии "Data Recvd".