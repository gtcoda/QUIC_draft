quic: базирующийся на UDP мультиплексный и безопасный транспортный протокол.

Аннотация
Документ определяющий ядро транспортного протокола QUIC. Сопутствующий документ описывает QUIC детекцию потерь пакетов и контроль переполнения и использования обмена ключей TLS.

Введение
QUIC мультиплексируемый и безопасный транспортный протокол общего назначения и обеспечивает:
мультиплексирование потоков
управление потоком на уровне соединения
малая задержка на установку соединения
миграция соединения и устойчивость к NAT rebinding
аутентификация и шифрования заголовков и полезной нагрузки

Структура документа
Документ описывает ядро протокола QUIC и состоит из следующих частей.
Потоки как базовые абстракции предоставляемые QUIC:
	Раздел 2 описывает основные понятия связанные с потоками.
	Раздел 3 предоставляет базовую модель состояний потоков.
	Раздел 4 основные операции контроля потока.
Соединения - контекст, в котором взаимодействую конечные точки QUIC.
	Раздел 5 описывает основные понятия связанные с соединениями.
	Раздел 6 описывает версии согласования.
	Раздел 7 детальный процесс установки соединения.
	Раздел 8 особенности критических механизмов предотвращения отказов в обслуживании.
	Раздел 9 описывает каким образом конечные точки мигрирую соединения в новом сетевом окружении.
	Раздел 10 список опций для завершения и открытия соединения.
	Раздел 11 предоставляет основное руководство для обработки ошибок.
Пакеты и кадры основные единицы используемы в соединениях QUIC.
	Раздел 12 описывает понятия связанные с пакетами и фреймами.
	Раздел 13 определяет модель для передачи, ретрансляции и подтверждения данных.
	Раздел 14 спецификация правил для управления размером пакета.
Детальная расшифровка элементов протокола QUIC, описывает:
	Раздел 15 версии.
	Раздел 16 целочисленное кодирование.
	Раздел 17 заголовки пакета.
	Раздел 18 транспортные параметры.
	Раздел 19 кадры.
	Раздел 20 ошибки.

Дополнительные документы описывают детектирование потери пакетов и управления перегрузкой (QUIC-RECOVERY) и использование ЕДЫ для обмена ключами (QUIC-TLS).

1.2. Термины и определения.

Обычно используемые термины в документе описаны ниже.

QUIC: Транспортный протокол описанный в документе. QUIC это название, a не акроним.
Пакет QUIC: Полноценно обрабатываемая единица QUIC инкапсулированная в UDP датаграмму. Множество пакетов QUIC могут быть инкапсулированы в одну UDP датаграмму.
Конечная точка: субъект, который может участвовать в установлении QUIC соединения, приеме и обработки пакетов. Существуют только два вида конечных точек QUIC: клиент и сервер.
Клиент: конечная точка инициализирующая соединение.
Сервер: конечная точка принимающая входящее QUIC соединение.
ID соединения: непрозрачный идентификатор используемый для идентификации QUIC соединения в конечной точке. Каждая конечная точка устанавливает значения для своего партнера и включает его в пакет отправляемый к конечной точке.
Поток: однонаправленный или двунаправленный канал для обмена байтами в QUIC соединении. QUIC соединение несет множество одновленыенных потоков.
Приложение: объект использующий QUIC для передачи и приема данных.

1.3 national conventions
Диаграммы пакетов и фреймов в этом документе используют формат описанный в Секции 3.1 RFC2360, с следованием дополнительных соглашений:
[x]: указанный х опционален.
х (А): указанный х длинной А бит.
х (А/В/С): указанный х длинной А, В или С бит.
х (i): указанный х длинной переменное количество бит, расшифровка в Секции 16.
х (*): указанный х длинной переменное число бит.

2. Потоки
Потоки в QUIC предоставляют легкие, ориентированные на упорядоченный поток байт абстракции для приложений. Потоки могут быть однонаправленные и двунаправленные. Альтернативное представлений однонаправленных потоков в QUIC есть "сообщение" практически неограниченной длинны.
Потоки могут быть созданы для передачи данных. Остальные процессы связанные с управлением потоком - окончание, отмена и управление потоком - разработаны с целью уменьшения накладных расходов. Для примера, одиночный потоковый фрейм  может быть открыт, передать данные и закрыть поток. Потоки могут быть долгоживущими и могут длится все время соединения.
Потоки могут создавать все конечные точки, могут одновременно передавать данные с другими потоками и могут быть отменены. QUIC не обеспечивает порядок байт между разными потоками.
QUIC допускает одновременно произвольное число потоков и передавать произвольное количество данных в любом потоке, с учетом ограничен накладываемых управление потоком(смотри Секцию 4).

2.1 Типы потоков и идентификаторов.
Потоки могут быть однонаправленными и двунаправленными. Однонаправленный поток передает данные только в одном направлении: от инициатора потока к получателю. Двунаправленный поток может передавать данные в обоих направлениях.
Потоки идентифицируются в соединении с помощью цифрового значения, называемым ID потока. ID потока это 62-х битное целое (от 0 до 2^62-1) уникальное для всех потоков данного соединения. ID потока записывается в целое переменой длинны(Раздел 16). Конечная точка QUIC не имеет права переиспользовать ID потока в соединении.
Первый значащий бит (0х1) в ID потока идентифицирует инициатора потока. Инициируемый клиентом поток имеет четный номер(бит установлен в 0), а инициируемый сервером нечетный(бит установлен в 1).
Второй значащий бит (0х2) в ID потока отличает двунаправленный поток(бит установлен в 0) от однонаправленного (бит установлен в 1).
Два первых значащих бита в ID потока идентифицируют поток как один из четырех типов представленных в таблице 1

Биты	Тип потокам
0х0		Инициализировано клиентом, Двунаправленный
0х1		Инициализированный сервером, Двунаправленный
0х2		Инициализированный клиентом, Однонаправленный
0х3		Инициализированный сервером, Однонаправленный

Внутри каждого типа, потоки создаются с числовым увеличением ID потока. ID потока, используемый не по порядку, приводит к тому, что будут открыты все потоки с меньшими порядковыми номерами.
Первый двунаправленный поток открываемый клиентом имеет ID потока 0.

2.2 Отправка и прием данных.
Фрейм потока(Раздел 19.8) инкапсулирует данные отправленные приложением. Конечная точка использует ID потока и поле смещения в фрейме для размещения данных.
Конечная точка может быть в состоянии доставить данные приложению в порядке потока байтов. Доставка потока байтов требует от конечной точки буферизировать любые данные полученные не по порядку, до достижения лимита управления потока.
QUIC не делает никаких специальных указаний для доставки потоком данных не по порядку. Тем не менее, реализация может предлагать возможность доставки приложению данных пришедших не по порядку.
Конечная точка может получать данные для потока с одинаковым смещением несколько раз. Данные которые были уже получены отбрасываются. Данные с данным смещением не могут быть изменены, если они были отправлены несколько раз. Конечная точка может воспринимать получение разных данных с одинаковым смещением в одном потоке как ошибку соединения типа PROTOCOL_VIOLATION.
Потоки - абстракция упорядоченного потока байтов, с не видимой структурой для QUIC. Фрейм потока не сохраняет границы данных при передаче, ретрансляции потерянного пакета и доставки до приложения на стороне приемника.
Конечная точка не может отправить данные в поток без обеспечения в пределах лимита управления потоком установленным второй стороной. Управление потоком детально описывается в Секции 4.

2.3 Приоритизация потоков.
Мультиплексирование потоков может оказать существенное влияние на производительность приложений, если ресурсы, выделенные потокам, имеют правильный приоритет.
QUIC не предоставляет механизм для обмена информацией о приоритетах. Вместо этого, полагается на получение информации о приоритетах от приложения использующего QUIC.
Реализация QUIC ДОЛЖНА предоставлять пути которые позволят приложению узнать относительные приоритеты потоков. При решении каким потокам выделять ресурсы, реализация ДОЛЖНА использовать информацию предоставленную приложением.

3. Состояние потоков.
Эта Раздел описывает потоки в терминах компонентов приема и передачи. Описываются два конечных автомата: один для описания передающих потоков конечной точки(Раздел 3.1), другой для принимающих потоков конечной точки(Раздел 3.2).
Однонаправленные потоки используют соответствующий конечный автомат. Двунаправленные потоки используют оба конечных автомата. По большей части использование этих конечных автоматов одинаковое является ли поток однонаправленным или двунаправленным. Условия для открытия двунаправленного потока немного сложнее, потому что, отправляющая и принимающая сторона открывают поток в двух направлениях.
Конечная точка ДОЛЖНА открывать потоки того же типа в порядке возрастания ID потока.
Замечание: Эти состояния являются во многом информативными. Этот документ использует состояния потока для описания правил отправки разных типов кадров, и реакции на получение разных типов кадров. Хотя конечный автомат реализовывать QUIC, эти состояния не должны стеснять реализацию. Реализация может объявлять различные конечные автоматы до тех пор, пока его поведение соответствует реализации, реализующей эти состояния.

3.1 Состояния потока передачи.
На Рисунке 1 показаны состояния передающей части потока отправляющей данные узлу.
          o
          | Create Stream (Sending)
          | Peer Creates Bidirectional Stream
          v
      +-------+
      | Ready | Send RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Send STREAM /             |
          |      STREAM_DATA_BLOCKED  |
          |                           |
          | Peer Creates              |
          |      Bidirectional Stream |
          v                           |
      +-------+                       |
      | Send  | Send RESET_STREAM     |
      |       |---------------------->|
      +-------+                       |
          |                           |
          | Send STREAM + FIN         |
          v                           v
      +-------+                   +-------+
      | Data  | Send RESET_STREAM | Reset |
      | Sent  |------------------>| Sent  |
      +-------+                   +-------+
          |                           |
          | Recv All ACKs             | Recv ACK
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Recvd |                   | Recvd |
      +-------+                   +-------+

Рисунок 1: Состояния передающей части потоков.

Передающая часть потока конечной точки начинает (тип 0 и 2 для клиента, 1 и 3 для сервера) с открывается приложением. Состояние "Ready" представляет собой вновь созданный поток в состоянии принять данные от приложения. Данные потока могут быть помещены в буфер для подготовки к отправлению.
Передав первым кадры STREAM и STREAM_DATA_BLOCKED передающая часть потока входит в состояние "Send". Реализация может отложить выделение ID потока, пока не отправит первый кадр STREAM и войти в это состояние, что позволит лучше использовать приоритезацию потоков.
Передающая часть двунаправленного потока инициированная удаленным узлом(тип 0 для сервера, тип 1 для клиента) входит в состояние "Ready" и немедленно переходит в состояние "Send" если принимающая часть переходит в состояние "Recv" (Раздел 3.2)

В состоянии "Send" конечная точка  передает - и ретранслирует если необходимо, - в потоке кадр STREAM. Конечная точка соблюдает лимиты управления потоком установленные удаленным участником, и продолжает принимать м обрабатывать кадры MAX_STREAM_DATA. Конечная точка в состоянии "Send" генерирует кадры STREAM_DATA_BLOCKED, если лимиты управления потоком блокируют передачу потока или соединения (Раздел 4.1).
После того, как приложение указало, что все данные потока были переданы и отправлен кадр STRERAM содержащий бит FIN, передающая часть потока переходит в состояние "Data Send". В этом состоянии, конечная точка только повторяет передачу данных если необходимо. Конечная точка не нуждается в проверке лимитов управления потоком или отправки кадров STREAM_DATA_BLOCKED для потока в этом состоянии. Кадры MAX_STREAM_DATA могут приниматься до тех пор пока удаленный участник не примет конец смещения потока. Конечная точка может безопасно игнорировать все MAX_STREAM_DATA кадры полученные от удаленного участника для потока в этом состоянии.
Когда все данные потока успешно подтвердятся, передающая часть потока переходит в состояние "Data Recvd", которое является конечным состоянием.
Для любого состояния "Ready","Send" и "Data Send", приложение может послать сигнал с требованием закончить передачи данных. Конечная точка также может принять кадр STOP_SENDING от удаленного участника. В любом случае, конечная точка передает кадр RESET_STREAM, что приводит поток к переходу в состояние "Reset Send"
Конечная точка МОЖЕТ послать RESET_STREAM в качестве первого кадра упоминаемого в потоке; в этом случае передающая часть открывает поток и немедленно переходит в состояние "Reset Sent".
Когда пакет включает RESET_STREAM успешно подтверждены, передающая часть потока переходит в состояние "Reset Recvd", которое является конечным состоянием.

3.2 Состояние потока приема
Рисунок 2 показывает состояния для принимающей части потока от удаленного узла. Принимающая часть отражает только некоторые состояния передающей части удаленного узла. Принимающая часть не отслеживает состояние отправителя которые нельзя наблюдать, такие как состояние "Ready". Вместо этого, принимающая часть отслеживает доставку данных приложению, некоторые из которых не могут быть отслежены отправителем.

          o
          | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM
          | Create Bidirectional Stream (Sending)
          | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)
          | Create Higher-Numbered Stream
          v
      +-------+
      | Recv  | Recv RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Recv STREAM + FIN         |
          v                           |
      +-------+                       |
      | Size  | Recv RESET_STREAM     |
      | Known |---------------------->|
      +-------+                       |
          |                           |
          | Recv All Data             |
          v                           v
      +-------+ Recv RESET_STREAM +-------+
      | Data  |--- (optional) --->| Reset |
      | Recvd |  Recv All Data    | Recvd |
      +-------+<-- (optional) ----+-------+
          |                           |
          | App Read All Data         | App Read RST
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Read  |                   | Read  |
      +-------+                   +-------+

    Рисунок 2: Состояния принимающей части потока

Принимающая часть потока инициируемая удаленным узлом (ти 1 и 3 для клиента, 0 и 2 для сервера), создается при получении первого STREAM, STREAM_DATA_BLOCKED или RESET_STREAM. Для двунаправленного потока, инициируемого удаленным узлом, получение кадра MAX_STREAM_DATA или STOP_SENDING также инициирует создание принимающей части. Начальное состояние принимающей части "Recv".
Принимающая часть потока переходит в состояние "Recv" когда отправляющая часть двунаправленного потока, инициируемого конечной точкой (тип 0 для клиента и 1 для сервера), переходит в состояние "Ready".
Конечная точка открывает двунаправленные поток, когда от удаленного узла получен кадр MAX_STREAM_DATA или STOP_SENDING. Получение кадра MAX_STREAM_DATA для неоткрытого потока указывает, что удаленный узел открыл поток и предоставил лимит управления потоком. Получение кадра STOP_SENDING для неоткрытого потока указывает, что удаленный узел больше не желает получать данные в этом потоке. Любой кадр может прибыть до кадра STREAM или STREAM_DATA_BLOCKED, если пакеты потеряны или переупорядочены.
Перед созданием потока ДОЛЖНЫ быть созданы все потоки этого типа с меньшими номерами идентификаторов потоков. Это гарантирует, что создание потоков согласованы на обеих конечных точках.
В состоянии "Recv" конечная точка получает кадры STREAM и STREAM_DATA_BLOCKED. Поступающие данные буферизируются и могут быть собраны в правильном порядке для доставки в приложение. Когда данные используются приложением и освобождается буферное пространство, конечная точка отправляет MAX_STREAM_DATA, чтобы удаленный узел мог отправлять больше данных.
Когда получен кадр STREAM с битом FIN, то становится известен конечный размер потока (Раздел 4.4). Принимающая часть переходит в состояние "Size Known". В этом состоянии конечной точке не нужно отправлять кадры MAX_STREAM_DATA, jyfjyf только получает любые переданные в потоке данные.
Как только все данные потока получены, принимающая часть переходит в состояние "Data Recv". Это может произойти при получении того же кадра "STREAM", что вызывает переход в состояние "Size Known". После получения всех данных любые кадры STREAM или STREAM_DATA_BLOCKED для этого потока могут быть отброшены.
Состояние "Data Recvd" сохраняется до тех пор, пока данные не будут доставлены приложению. Как только данные потока доставлены приложению, поток переходит в конечное состояние "Data Read".
При получении кадра RESET_STREAM в состояниях "Recv" или "Size Known" поток переходит в "Reset Recvd". Это может привести к прерыванию доставки данных в приложение.
Возможно, что все данные потока будут получены, когда поступил RESET_STREAM(то есть в состоянии "Data Recvd"). Аналогично, оставшиеся данные могут поступить после получения кадра RESET_STREAM(в состоянии Reset Recvd). Выбор как поступить в данной ситуации отдается на усмотрение реализации.
Отправка RESET_STREAM означает, что конечная точка не в состоянии гарантировать доставку данных; однако не требуется что бы данные потока не доставлялись, если получено RESET_STREAM. Реализация МОЖЕТ прервать доставку данных, отбросить все неиспользуемые данные и сигнализировать о получении RESET_STREAM. Сигнал RESET_STREAM может быть подавлен или скрыт, если все данные потока полностью получены и буферизированы для чтения приложением. Если сигнал RESET_STREAM подавлен, принимающая часть потока остается в состоянии "Data Recvd".
Как только приложение получает сигнал о сбросе потока, принимающая часть переходит в конечное состояние "Reset Read".

3.3 Разрешенные типы кадров.
Отправитель потока отправляет три типа кадров, что влияют на состояние потока отправителя или получателя: STREAM(Раздел 19.8), STREAM_DATA_BLOCKED( Раздел 19.13) и RESET_STREAM(Раздел 19.4).
Отправитель НЕ ДОЛЖЕН отправлять все эти кадры в конечном состоянии("Data Recvd" или "Reset Recvd"). Отправитель НЕ ДОЛЖЕН отправлять STREAM или STREAM_DATA_BLOCKED после отправки RESET_STREAM; то есть, в конечных состояниях или в состоянии "Reset Sent". Получатель может принять любой из трех кадров в любом состоянии, из-за возможности задержки доставки пакетов несущих их.
Получатель отправляет кадры MAX_STREAM_DATA(Раздел 19.10) и STOP_SENDING(Раздел 19.5).
Получатель отправляет MAX_STREAM_DATA только в состоянии "Recv". Получатель может отправить STOP_SENDING в любом состоянии, если не получено RESET_STREAM; то есть в состоянии отличном от "Reset Recvd" или "RESET Read". Однако не имеет значения отправка STOP_SENDING в состоянии "Data Recvd", поскольку все данные потока были получены. Отправитель может принять любой из двух кадров в любом состоянии, из-за отложенной доставки пакетов.

3.4 Состояния двунаправленного потока.
Двунаправленный поток состоит из отправляющей и принимающей части. Реализация может представлять состояния двунаправленного потока как состоящее из состояний отправляющей и принимающей части. Простоя модель представляет поток как "open" когда отправляющая и принимающая часть находятся не в конечном состоянии и "closed" когда отправитель и получатель потока находятся в конечном состоянии.
Таблица 2 показывает полную карту состояний двунаправленного потока неполно соответствующею состояниям потока HTTP/2[HTTP2]. Здесь показаны объединенные состояния отправителя и получателя состоящие из объединенных состояний. Эта запись одно из возможных отображений; оно требует подтверждение данных до перехода в состоние "closed" или "half-closed".

   +-----------------------+---------------------+---------------------+
   | Sending Part          | Receiving Part      | Composite State     |
   +-----------------------+---------------------+---------------------+
   | No Stream/Ready       | No Stream/Recv *1   | idle                |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Recv/Size Known     | open                |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Data Recvd/Data     | half-closed         |
   |                       | Read                | (remote)            |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Reset Recvd/Reset   | half-closed         |
   |                       | Read                | (remote)            |
   |                       |                     |                     |
   | Data Recvd            | Recv/Size Known     | half-closed (local) |
   |                       |                     |                     |
   | Reset Sent/Reset      | Recv/Size Known     | half-closed (local) |
   | Recvd                 |                     |                     |
   |                       |                     |                     |
   | Reset Sent/Reset      | Data Recvd/Data     | closed              |
   | Recvd                 | Read                |                     |
   |                       |                     |                     |
   | Reset Sent/Reset      | Reset Recvd/Reset   | closed              |
   | Recvd                 | Read                |                     |
   |                       |                     |                     |
   | Data Recvd            | Data Recvd/Data     | closed              |
   |                       | Read                |                     |
   |                       |                     |                     |
   | Data Recvd            | Reset Recvd/Reset   | closed              |
   |                       | Read                |                     |
   +-----------------------+---------------------+---------------------+
	Таблица 2: Возможное отображение состояний потока на HTTP/2
   
3.5 Запросы на переход состояний.

Если конечная точка больше не заинтересована в данных которая получает, она МОЖЕТ послать кадр STOP_SENDING для закрытия потока. Обычно это означает, что принимающее приложение больше не читает данные получаемые в потоке, но не гарантируется, что входящие данные будут игнорироваться.
Кадры STREAM полученные после отправки STOP_SENDING, по прежнему учитываются для соединения и управления потоком, даже если они могут быть отброшены при получении.
Кадр STOP_SENDING запрашивает, что бы принимающая конечная точка отправила кадр RESET_STREAM. Конечная точка принявшая STOP_SENDING, ДОЛЖНА отправить кадр RESET_STREAM, если поток находится в состоянии "Ready" или "Send". Если поток находится в "Data Sent" и все оставшиеся данные объявляются потерянными, конечной точке СЛЕДУЕТ отправить RESET_STREAM вместо повторной передачи.
Конечной точке СЛЕДУЕТ скопировать код ошибки из кадра STOP_SENDING в кадр RESET_STREAM который она отправляет, но МОЖЕТ использовать любой код ошибки приложения. Конечная точка отправляющая STOP_SENDING МОЖЕТ игнорировать код ошибки содержащийся в любом полученном кадре RESET_STREAM.
Если кадр STOP_SENDING получен в потоке находящимся в состоянии "Data Sent", конечная точка желающая прекратить повторную передачу ранее отправленных кадров STREAM, ДОЛЖНА сначала отправить RESET_STREAM.
STOP_SENDING СЛЕДУЕТ отправлять только для потоков, в состоянии не reset. STOP_SENDING наиболее полезен для потоков в состоянии "Recv" или "Size Known".
Ожидается, что конечная точка отправит еще один STOP_SENDING  если предыдущий пакет содержащий STOP_SENDING был утерян. Однако, как только получены все данные потока или кадр RESET_STREAM, то есть поток находится в состоянии отличном от "Recv" или "Size Known", отправка кадра STOP_SENDING не требуется.
Конечная точка желающая завершить оба направления двунаправленного потока, может завершить одно направление отправив RESET_STREAM, и стимулировать быстрое завершение другого направления отправив STOP_SENDING.

4 Контроль потока.
Необходимо ограничивать объем данных, которое может буферизировать получатель, чтобы не дать быстрому отправителю перегрузить медленного получателя или чтобы злонамеренный отправитель не занял большой объем памяти у получателя. Чтобы позволить получателю ограничить выделение памяти и оказывать давление на отправителя, потоки контролируются как индивидуально так и в совокупности. Получатель QUIC контролирует какой объем данных может передать отправитель, как описано в Разделе 4.1 и Разделе 4.2.
Аналогично, что бы ограничить параллелизм внутри соединения, конечная точка QUIC контролирует максимальное число потоков которое может инициировать удаленный узел, как описано в Разделе 4.5.
Данные отправляемые в кадрах CRYPTO, не подчиняются контролю потока, как данные потока. QUIC полагается на реализацию криптографического протокола, чтобы избежать чрезмерной буферизации данных.(см. [QUIC-TLS]). Реализация ДОЛЖНА предоставить интерфейс для QUIC, сообщающий о его пределах буферизации, что бы избежать чрезмерной буферизации на нескольких уровнях.

4.1 Управление потоком данных.
QUIC использует схему управления потоком на основе кредитов, аналогичную схеме HTTP\2, где получатель объявляет количество байтов которое он готов принять в данном потоке и для всего соединения. Это приводит к двум уровням управления потоком в QUIC:
	Управление потоком, предотвращающее использование одним потоком всего буфера приема соединения, путем ограничения объема данных, которое может быть отправлено в любом соединении.
	Управление соединением, которое не позволит отправителям превысить емкость буфера получателя для соединения, путем ограничения общего количества байт отправляемых в кадрах STREAM всех потоков.
Получатель устанавливает начальные лимиты для всех потоков, отправляя параметры во время квитирования (Раздел 7.3). Получатель отправляет отправителю кадры MAX_STREAM_DATA (Раздел 19.10) или MAX_DATA (Раздел 19.9) для установки дополнительных лимитов.
Получатель объявляет лимит для потока, отправляя кадр MAX_STREAM_DATA с соответствующим образом установленным полем идентификатора потока. Кадр MAX_STREAM_DATA указывает максимальное абсолютное байтовое смещение потока. Приемник используя текущее смещение, определить объявленный лимит управление потоком. Получатель МОЖЕТ отправлять кадры MAX_STREAM_DATA в нескольких пакетах, чтобы удостоверится, что отправитель получит обновление лимита управления потоком, доже если один из пакетов утерян.
Получатель объявляет лимит для соединения, отправляя кадр MAX_DATA, который указывает максимум суммы абсолютных смещений всех байтов всех потоков. Приемник сохраняет накопленную сумму байт, полученных во всех потоках, используя ее для проверки нарушения управления потоком. Получатель может использовать сумму байт, полученную во всех потоках, для определения и объявления максимального предела данных.
Получатель может объявить большее смещение отправляя кадры MAX_STREAM_DATA или MAX_DATA. КАК только получатель объявил смещение, он МОЖЕТ отправить кадр с меньшим смещением, но это не имеет эффекта.
Получатель ДОЛЖЕН закрыть поток с ошибкой FLOW_CONTROL_ERROR (Раздел 11), если отправитель нарушает лимиты соединения или потока.
Отправитель ДОЛЖЕН игнорировать любые кадры MAX_DATA или MAX_STREAM_DATA которые не увеличивают лимиты управления потоком.
Если отправителю не хватает лимита управления потоком, он не может передавать новые данные и считается заблокированным. Отправителю СЛЕДУЕТ отправить кадр STREAM_DATA_BLOCKED или DATA_BLOCKED, чтобы указать, что у него есть данные для отправки, но он заблокирован ограничениями управления потоком. Ожидается, что эти кадры в обычных случаях будут отправляться нечасто, но они полезны для целей мониторинга и отладки.
Отправителю не следует отправлять несколько кадров STREAM_DATA_BLOCKED или DATA_BLOCKED для одного и того же лимита данных, только если кадр не будет определен как потерянный. Еще один кадр STREAM_DATA_BLOCKED или DATA_BLOCKED может быть отправлен после увеличения лимита данных.

4.2 Увеличение лимита управления потоком.
Этот документ оставляет на усмотрение реализации когда и сколько байт обьявлять в кадрах MAX_STREAM_DATA или MAX_DATA, но предлагает несколько соображений. Эти кадры привносят издержки в соединение. Поэтому нежелательна частая отправка кадров с небольшими изменениями. В то же время необходимы большие приращения лимитов, чтобы избежать блокировок, если обновление выполняется редко, что в сою очередь требует наличия больших ресурсов у получателя. Таким образом, следует искать компромисс между выделение ресурсов и накладными расходами при определении лимита управляя потоком.
Приемник может использовать автоматический механизм настройки частоты и размера объявленного добавления лимита на основе оценки времени круговой задержки и скорости, ч какой принимающее приложение потребляет данные, аналогично обычным реализациям TCP. В качестве оптимизации, отправка кадров связанных с управление потоком, осуществляется только тогда, когда есть другие кадры для отправки или когда удаленный узел заблокирован. Это гарантирует, что управление потоком не вызовет отправку дополнительных пакетов.
Если отправителю не хватает лимита управления потоком, он не сможет передавать новые данные и считается заблокированным. Обычно считается, что отправитель не должен блокироваться. Чтобы избежать блокировки отправителя и учесть возможность потери кадров, получатель должен отправить кадр MAX_DATA или MAX_STREAM_DATA минимум за два RTT, до ожидаемого момента блокировки.
Получатель НЕ ДОЛЖЕН дожидаться STREAM_DATA_BLOCKED или DATA_BLOCKED перед отправкой MAX_STREAM_DATA или MAX_DATA, так как это означает, что отправитель будет заблокирован, по крайней мере на один цикл RTT, и возможно на более длительный срок, если партнер решит не отправлять STREAM_DATA_BLOCKED или DATA_BLOCKED.

4.3 Обработка отмены потока.
Конечные точки должны в конечном итоге договорится о сумме лимитов, который будет использоваться, чтобы избежать превышения лимитов или взаимоблокировки.
После получения RESET_STREAM конечная точка завершает работу для соответствующего потока и игнорирует другие данные поступающее в этот поток. Без смещения включенного в RESET_STREAM, количество байт которое учитывается при управлении потоком может не совпадать.
Чтобы устранить эту проблему кадр RESET_STREAM(Раздел 19.4) включает в себя окончательный размер данных передаваемый в потоке. Получив кадр RESET_STREAM получатель точно знает сколько байт было отправлено в этом потоке до кадра RESET_STREAM. Получатель ДОЛЖЕН использовать окончательный размер потока, для учета всех отправленных байт, в управлении потоком уровня соединения. 
RESET_STREAM завершает одно направление потока. Для двунаправленного потока RESET_STREAM не влияет на поток в противоположном направлении. Обе конечные точки ДОЛЖНЫ поддерживать состояние управления потоком для потока в незавершенном направлении, пока это направление не завершится или одна из конечных точек не отправит кадр CONNECTION_CLOSE.

4.4 Окончательный размер потока.
Окончательный размер это сумма лимита управления потоком.  Если предположить, что каждый байт в потоке был отправлен один раз, то окончательный размер равен количеству отправленных байт. В более общем случае, ky равен на единицу больше, чем смещение последнего байта отправленного в потоке или ноль, если не было ни одного байта.
Для потока в состоянии RESET окончательный размер явно берется из кадра RESET_STREAM. В противном случае окончательный размер это всещение плюс длинна кадра STREAM с флагом FIN, или 0 в случае входящих однонаправленных потоков.
Конечная точка будет знать окончательный размер потока, когда принимающая часть перейдет в состояние "Size Known" или "Reset Recvd" (Раздел 3).
Конечная точка НЕ ДОЛЖНА отправлять данные в поток за пределами конечного размера.
Как только окончательный размер потока известен, он не может изменится. Если получен кадр RESET_STREAM или STREAM, указывающий на изменение конечного размера, конечная точка ДОЛЖНА ответить ошибкой FINAL_SIZE_ERROR (Раздел 11). Получателю СЛЕДУЕТ обработать получение данных окончательного размера или за его пределами как ошибку FINAL_SIZE_ERROR даже после закрытия потока. Генерирование этих ошибок не является обязательным, только потому, что требуются ресурсы, чтобы конечная точка должна поддерживать состояние финального размера для закрытых потоков.

4.5 Контроль согласованности.
Конечная точка ограничивает общее количество входящих потоков, которое может открыть удаленный узел. Открыты могут быть только потоки с идентификатором меньше чем (max_stream * 4 + initial_stream_id_for_type)(Таблица 5). Начальные ограничения устанавливаются транспортными параметрами (Раздел 18.1), а затем объявляются с использованием кадров MAX_STREAMS(раздел 19.11). Отдельные ограничения для однонаправленных и двунаправленных потоков.
Если транспортный параметр max_stream или кадр MAX_STREAMS получен со значением превышающем 2^60, что является максимальным идентификатором, который может быть выражен целым числом переменной длинны. (Раздел 16). Если такой идентификатор получен соединение ДОЛЖНО быть немедленно закрыто с ошибкой STREAM_LIMIT_ERROR (Раздел 10.3)
Конечные точки НЕ ДОЛЖНЫ превышать ограничения установленные удаленными узлами. Конечная точка получившая кадр с идентификатором потока превышающем установленный ею лимит, ДОЛЖНА трактовать это как ошибку соединения типа STREAM_LIMIT_ERROR (Раздел 11).
Как только получатель объявляет ограничение потока с помощью кадра MAX_STREAMS, объявление меньшего ограничения не имеет никакого эффекта. Приемник ДОЛЖЕН игнорировать любой кадр  MAX_STREAMS, который не увеличивает лимит.
Этот документ оставляет выбор реализации когда и сколько открывать потоков через MAX_STREAMS. Реализация может увеличивать предел по мере того, как потоки закрываются, чтобы количество потоков для удаленного узла было примерно одинаковым.
Конечная точка, которая не может открыть новый поток из-за ограничения, ДОЛЖНА отправить кадр STREAMS_BLOCKED (Раздел 19.14) Этот сигнал считается полезным для отладки. Конечная точка НЕ ДОЛЖНА ждать получения этого сигнал, прежде чем увеличить лимит. Поскольку это означает, что удаленный узел будет заблокирован, по крайней мере на один цикл RTT, и возможно на более длительный срок, если удаленный узел решит не отправлять кадр STREAMS_BLOCKED.

5. Соединения
QUIC соединение сочетает согласование версии с криптографическим и транспортным рукопожатием для уменьшение задержки установки соединения, как описано в Разделе 7. После установления соединения конечная точка может менять IP или порт, как описано в разделе 9. Соединение может быть прервано любой конечной точкой, как описано в разделе 10.

5.1 ID соединения.
Каждое соединение обладает набором идентификаторов, или ID соединения, каждый из которых может идентифицировать соединение. Идентификаторы независимо выбираются двумя конечными точками, каждая конечная точка выбирает идентификаторы соединения которые использует удаленный узел.
Основная функция ID соединения заключается в обеспечении того, чтобы изменение на более низких уровнях протокола(UDP, IP) не приводили к доставке пакетов соединения QUIC в неправильную конечную точку. Каждая конечная точка выбирает идентификаторы соединения, используя метод специфичный для реализации, который позволит маршрутизировать пакеты с этим идентификатор обратно к конечной точке и идентифицировать конечную точку при получении.
ID соединения НЕ ДОЛЖНЫ содержать информацию, которая может использоваться внешним наблюдателем для сопоставления их с другими ID соединения этого же соединения. В качестве тривиального примера, один и то же ID НЕ ДОЛЖЕН выдаваться более одного раза для одного и того же соединения.
Пакеты с длинными заголовками включают поля "Sourse Connection ID" и "Destination Connection ID". Эти поля используются для установки идентификаторов новых соединений, см Раздел 7.2.
Пакеты с короткими заголовками(Раздел 17.3) включают только "Destination Connection ID" и явно опускают длину. Ожидается, что длинна поля "Destination Connection ID" известна конечным точкам. Конечные точки, использующие балансировщик нагрузки маршрутизирующий на основе ID соединения, могут согласовать с балансировщиком фиксированную длину идентификатора, или согласовать схему кодирования.
В пакете Согласования (Раздел 17.2.1), повторяются идентификаторы соединения выбранные клиентом, чтобы гарантировать правильность маршрутизации к клиенту и позволит ему проверить, что данный пакет является ответом на начальный пакет.
ID соединения нулевой длинны МОЖЕТ использоваться, когда ID соединения не нужен для маршрутизации, а набор адрес/порт пакета достаточно для идентификации. Конечная точка, чей удаленный узел выбрал ID нулевой длинны, ДОЛЖНА продолжать использовать такой ID в течении всего времени существования соединения, и НЕ ДОЛЖНА отправлять пакеты с любого другого локального адреса.
Когда конечная точка запросила ID ненулевой длинны, она должна убедится, что удаленный узел имеет запас идентификаторов соединения, из которого можно выбрать пакеты для отправки конечной точке. Эти ID предоставляются конечной точкой с использованием кадра NEW_CONNECTION_ID (Раздел 19.15)

5.1.1 Выдача идентификаторов соединений.
Каждый ID имеет связанный порядковый номер помогающий в дедупликации сообщений. Начальный ID, выданный конечной точкой, отправляется в поле Sourse Connection ID длинного заголовка пакета (Раздел 17.2) во время квитирования. Порядковый номер исходного идентификатора равен 0. Если передан транспортный параметр preferred_address, прядкой номер предоставляемого идентификатора равен 1.
Дополнительные идентификаторы передаются удаленному узлу с помощью кадров NEW_CONNECTION_ID (Раздел 19.15). Порядковый номер каждого вновь выданного соединения ДОЛЖЕН увеличиваться на 1. ID, произвольно выбранный клиентом в исходном пакете, и любой идентификатор предоставленный пакетом Retry, не являются назначенными порядковыми номерами, только если сервер не решит сохранить их в качестве своего начального ID.
Когда конечная точка выдала ID, она ДОЛЖНА принимать все пакеты с этим ID на все время соединения или до тех пор, пока удаленный узел не сделает этот ID недействительным по средствам кадра RETIRE_CONNECTION_ID (Раздел 19.16).
Конечной точке СЛЕДУЕТ гарантировать, что удаленный узел имеет достаточное количество доступных и неиспользованный ID. Конечные точки хранят полученные идентификаторы для будущего использования и объявляют номера ID которые они готовы хранить с помощью транспортного параметра active_connection_id_limit. Конечной точке НЕ СЛЕДУЕТ представлять больше ID чем ограничение удаленного узла.
Конечной точке СЛЕДУЕТ предоставить новый идентификатор соединения, когда она получает пакет с ранее неиспользуемым ID или когда удаленный узел удаляет его, если только предоставление нового ID не превысит лимит установленный удаленным узлом. Конечная точка МОЖЕТ ограничить частоту и общее количество ID, cjolfdftvs[ для каждого соединения, чтобы избежать риска исчерпания идентификаторов соединения (Раздел 10.4.2)
Конечная точка, инициирующая миграцию и требующая идентификаторов ненулевой длинны, ДОЛЖНА гарантировать, что пул ID доступных удаленному узлу, позволит использовать новый ID при миграции, в противном случае, при исчерпании пула, соединение будет закрыто.

5.1.2 Использование и удаление идентификаторов соединения.
Конечная точка может изменить ID соединения, который она использует для удаленного узла, в любой момент соединения. Конечная точка использует ID в ответ на миграцию удаленного узла. (Раздел 9.5).
Конечная точка поддерживает набор идентификаторов, полученных от удаленного узла, любой из которых может использоваться при отправке пакетов. Когда конечная точка желает удалить идентификатор из списка используемых, она отправляет кадр RETIRE_CONNECTION_ID. Отправка кадра RETIRE_CONNECTION_ID указывает, что ID соединения больше не будет использоваться, и запрашивает, чтобы удаленный узел заменил его новым используя NEW_CONNECTION_ID.
Из обсуждения в Разделе 9.5, каждый идентификатор ДОЛЖЕН использоваться в пакетах, отправляемых ьлдбко с одного локального адреса. Конечной точке, которая мигрирует с локального адреса, СЛЕДУЕТ удалить идентификаторы, используемые для этого адреса, если она не планирует больше использовать этот адрес.
Конечная точка может запросить удаленный узел удалить ID соединения отправлением кадра NEW_CONNECTION_ID с увеличением поля "Retire Prior To". После получения удаленный узел ДОЛЖЕН удалить соответствующие идентификаторы соединения и своевременно отправить соответствующие карды RETIRE_CONNECTION_ID. Невыполнение этого требования может привести к задержкам, потерям пакетов или к тому, что исходная конечная точка отправит сброс в ответ на идентификатор, который она не может правильно маршрутизировать.
Конечная точка МОЖЕТ отбросить ID, для которого запрошено удаление, по истечению не менее 3 PTO с момента получения подтверждения для кадра NEW_CONNECTION_ID, запросившего такое удаление. Последующие входящие пакеты использующие этот ID, могут вызвать токеном сброса.

5.2 Сопоставление пакетов с соединением
Входящие пакеты классифицируются при получении. Пакеты могут быть связаны с существующим соединением или, для серверов, потенциально создавать новое соединение.
Хосты пытаются связать пакеты с существующим соединением. Если пакет имеет Destination Connection ID, соответствующий существующему соединению, QUIC обрабатывает этот пакет соответствующим образом. Обратите внимание, что с соединением может быть связано больше одного соединения, см Раздел 5.1.
Если Destination Connection ID имеет нулевую длину и пакет соответствует набору адрес\порт соединения, для которого хосту не требовалось ID, QUIC обработает пакет как часть этого соединения. Конечные точки ДОЛЖНЫ либо отклонять попытки соединения, которые используют те же адреса, что и существующие соединения, либо использовать Destination Connection ID ненулевой длинны, чтобы пакеты могли быть правильно отнесены к соединениям.
Конечные точки могут отправлять сброс без сохранения состояния (Раздел 10.4) для любых пакетов, которые нельзя отнести к существующему соединению. Сброс без сохранения состояния позволяет удаленному узлу быстрее определить, что соединение становится непригодным для использования.
Пакеты, которые соответствуют существующему состоянию, отбрасываются, если эти пакеты не соответствуют состоянию этого соединения. Например, пакеты отбрасываются, если они указывают версию протокола, отличную от версии соединения. Или если расшифровка пакета не удалась, несмотря на наличие ожидаемых ключей.
Неверные пакеты без шифрования, такие как Initial, Retry или Version Negitiation, МОГУТ быть отброшены. Конечная точка ДОЛЖНА генерировать ошибку соединения, если она фиксирует изменение состояния до обнаружения ошибки.

5.2.1 Обработка пакетов клиентом
Правильные пакеты, отправляемые клиентом, всегда содержат Destination Connection ID который соответствует значению выбранному клиентом. Клиенты, которые выбирают получение ID нулевой длинны, могут использовать набор адрес\порт для идентификации соединения. Пакеты которые не соответствуют существующему соединению отбрасываются.
Из-за переупорядочивания или потери пакетов клиент может получить пакеты зашифрованные с помощью ключа, который он еще не вычислил. Клиент МОЖЕТ отбросить эти пакеты или МОЖЕТ буферизировать их в ожидании более поздних пакетов позволяющих вычислить ключ.
Если клиент получает пакет с неподдерживаемой версией он ДОЛЖЕН отбросить пакет.

5.2.2 Обработка пакетов сервером
Если сервер получает пакет неподдерживаемой версии, но пакет достаточен для того, чтобы инициализировать новое соединение для любой версии поддерживаемой сервером, он ДОЛЖЕН отправить пакет согласования версии, как описано в разделе 6.1. Серверы МОГУТ контролировать эти пакеты, чтобы избежать пакетных штормов. В противном случае серверы ДОЛЖНЫ отбрасывать пакеты, которые указывают неподдерживаемые версии.
Первый пакет неподдерживаемой версии может использовать различную семантику и кодирование для любого поля, зависящего от версии. В частности, от версии могут различаться ключи шифрования пакетов. Серверы, не поддерживающие конкретную версию, вряд ли смогут расшифровать содержимое пакета. Серверы НЕ ДОЛЖНЫ пытаться декодировать или дешифровывать пакет неизвестной версии, но вместо этого отправляют пакет согласования версий при условии, что пакет достаточно длинный.
Пакеты поддерживаемой версии или без поля версии сопоставляются соединению, используя ID или - для пакетов с ID нулевой длинный - набор адрес\порт. Если пакет не соответствует соединению, сервер продолжает работать с ним как описано ниже.
Если пакет является Начальным и полностью соответствует спецификации, сервер продолжает рукопожатие. Сервер фиксирует версию, которую выбрал клиент.
Если сервер не принимает новые соединения, он ДОЛЖЕН отправить исходный пакет содержащий кадр CONNECTION_CLOSE с кодом ошибки SERVER_BUSY.
Если полученный пакет является 0-RTT, сервер МОЖЕТ буферизировать ограниченное число пакетов в ожидании запоздавшего Начального пакета. Клиенты не могут отправлять пакеты для рукопожатия до получения ответа сервера, поэтому сервер ДОЛЖЕН игнорировать любые такие пакеты.
Серверы ДОЛЖНЫ отбрасывать входящие пакеты при любых других обстоятельствах.

5.3 Срок жизни QUIC соединения.
Подлежит определению.

6. Согласование версий.
Согласование версий гарантирует, что клиент и сервер согласятся на взаимно поддерживаемую версию QUIC. Сервер отправляет пакет согласования в ответ на каждый пакет, который может инициировать соединение (Раздел 5.2)
Размер первого пакета отправленного клиентом, определяет отправляет ли сервер пакет согласования версий. Клиенты, поддерживающие несколько версий QUIC, ДОЛЖНЫ дополнять первый отправляемый пакет наибольшим из минимальных размеров пакетов во всех версиях которые они поддерживают. Это гарантирует, что сервер ответит, если существует взаимоподдерживаемая версия.

6.1 Отправка пакета согласования версий.
Если выбранная клиентом версия неприемлема для сервера, он отвечает пакетом согласования версий (Раздел 17.2.1). Он включает в себя список поддерживаемых сервером версий. Конечная точка НЕ ДОЛЖНА отвечать пакетом согласования на пакет согласования.
Такая система позволяет серверу обрабатывать пакеты с неподдерживаемой версией без сохранения состояния. Несмотря на то, что исходный пакет или пакет согласования версий может быть потерян, клиент будет отправлять новые пакеты до тех пор пока не получит ответ или не откажется от попытки подключения. В результате клиент сбрасывает все состояния подключения и не отправляет больше пакетов на соединение.
Сервер МОЖЕТ ограничить количество отправляемых пакетов согласования версий. Например, сервер который может распознавать 0-RTT  пакеты, может предпочесть не отправлять пакеты согласования версий в ответ на такие пакеты, ожидая получить в конечном итоге начальный пакет.

6.2 Обработка пакета согласования версий.
Когда клиент получает пакет согласования версий, он ДОЛЖЕН отказаться от текущей попытки подключения. Пакеты согласования версий предназначены для возможности будущий версий QUIC согласовывать используемые версии между конечными точками. Будущие версии QUIC могут изменить реализацию реагирования на пакеты согласования версий данной версии. Определение реализации согласования версий оставляется для будущий версий QUIC. В частности, будущие реализации должны обеспечить устойчивость к атакам понижения версии (Раздел 21.9).

6.3 Использование зарезервированных версий.
Для того, чтобы сервер мог использовать в будущем новую версию, клиенты должны правильно обрабатывать неподдерживаемые версии. Чтобы гарантировать это, сервер ДОЛЖЕН включать версию, зарезервированную для принудительного согласования версий(0x?a?a?a?a, как определено в Разделе 15), при генерации пакета согласования версии.
Такая конструкция согласования версий позволяет сервера избегать сохранения состояния для отклоненных таким образом пакетов.
Клиент МОЖЕТ отправить пакет, используя зарезервированную версию. Это может использоваться для получения от сервера списка поддерживаемых версий.

7. Криптографическое и транспортное рукопожатие.
QUIC использует комбинированное криптографическое и транспортное рукопожатие для минимизации задержки установления соединения. QUIC использует кадр CRYPTO (Раздел 19.6) для передачи криптографического рукопожатия. Версия 0x00000001  QUIC использует TLS[QUIC-TLS]. Другой номер версии QUIC может указывать на использование другого криптографического протокола.
QUIC обеспечивает надежную, упорядоченную доставку данных криптографического рукопожатия. Защита пакетов QUIC используется для шифрования как можно больше части протокола рукопожатия. Криптографическое рукопожатие ДОЛЖНО обеспечивать следующие свойства:
o аутентифицированный обмен ключами, где
	* сервер всегда аутентифицирован,
	* клиент может быть дополнительно аутентифицирован,
	* каждое соединение создает отдельные и несвязанные ключи,
	* ключевой материал пригоден для защиты пакетов 0-RTT, 1-RTT и т.д.
	* ключи 1-RTT имеют прямую секретность.
o аутентифицирование значения для транспортных параметров удаленного узла (Раздел 7.3)
o аутентифицируемое согласование протокола приложения (для этой цели TLS использует ALPN[RFC7301])
Первый кадр CRYPTO  от клиента ДОЛЖЕН быть отправлен в одном пакете. Любая другая попытка инициировать проверку адреса (Раздел 8.1) ДОЛЖНА также отправляется в одном пакете. Это позволяет избежать сборки сообщения из нескольких пакетов.
Первый клиентский пакет протокола криптографического квитирования ДОЛЖЕН уместится в полезную нагрузку 1232-байтного пакета QUIC. Эта нагрузка включает в себя служебные данные уменьшающие пространство доступное для протокола криптографического квитирования.
Конечная точка может проверить поддержку явного уведомления о перегрузке (ECN) в первых отправленных ей пакетах(Раздел 13.3.2).
Кадр CRYPTO может быть отправлен в разных пространствах номеров пакетов. Порядковые номера используемые кадрами CRYPTO для обеспечения упорядоченной доставки данных рукопожатия, начинаются с нуля в каждом пространстве пакетов.
Конечные точки ДОЛЖНЫ явно согласовать протоком приложения. Это позволит избежать разногласия по поводу используемого протокола.

7.1 Пример рукопожатия.
Подробная информация о том как ЕДЫ интегрирован в QUIC представлена в [QUIC-TLS], но некоторые примеры приведены здесь. Расширение этого обмена для поддержки проверки адреса клиента показано в разделе 8.1.1.
После завершения любой проверки адресов, криптографическое подтверждение используется для согласования криптографических ключей. Криптографическое рукопожатие передается в пакетах Initial (Раздел 17.2.2) и Handshake (раздел 17.2.4).
На рисунке 3 представлен обзор рукопожатия 1-RTT. Каждая строка показывает пакет QUIC с типом и номером от начала, и сопровождаемыми кадрами которые обычно содержаться в этом пакете. Например, первый кадр имеет тип Initial с номером 0 и содержит кадр CRYPTO переносящий ClientHello.
Обратите внимание, что несколько пакетов, даже с разными уровнями шифрования, могут быть объединены в одну дейтаграмму UDP (Раздел 12.2). Поэтому, рукопожатие может состоять всего из 4 дейтаграмм UDP или любого другого числа. Например, первый ответ сервера содержит пакеты с начального уровня шифрования(обфускации), уровня рукопожатия и уровня 1-RTT с данными "0,5-RTT".
   Client                                                  Server

   Initial[0]: CRYPTO[CH] ->

                                    Initial[0]: CRYPTO[SH] ACK[0]
                          Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                    <- 1-RTT[0]: STREAM[1, "..."]

   Initial[1]: ACK[0]
   Handshake[0]: CRYPTO[FIN], ACK[0]
   1-RTT[0]: STREAM[0, "..."], ACK[0] ->

                               1-RTT[1]: STREAM[3, "..."], ACK[0]
                                          <- Handshake[1]: ACK[0]

 Figure 3: Пример 1-RTT Handshake

На рисунке 4 представлен пример соединения с рукопожатием 0-RTT и одним пакетом данных 0-RTT. Обратите внимание, как описано в разделе 12.3, сервер подтверждает данные 0-RTT на уровне шифрования 1-RTT и клиент отправляет пакеты 1-RTT в том же пространстве номеров пакетов.
   Client                                                  Server

   Initial[0]: CRYPTO[CH]
   0-RTT[0]: STREAM[0, "..."] ->

                                    Initial[0]: CRYPTO[SH] ACK[0]
                                     Handshake[0] CRYPTO[EE, FIN]
                             <- 1-RTT[0]: STREAM[1, "..."] ACK[0]

   Initial[1]: ACK[0]
   Handshake[0]: CRYPTO[FIN], ACK[0]
   1-RTT[1]: STREAM[0, "..."] ACK[0] ->

                               1-RTT[1]: STREAM[3, "..."], ACK[1]
                                          <- Handshake[1]: ACK[0]

 Figure 4: Пример 0-RTT Handshake
					 
7.2 Согласование идентификаторов соединения.
Идентификатор соединения используется для обеспечения согласованной маршрутизации пакетов, как описано в разделе 5.1. Длинный заголовок содержит два идентификатора соединения:
Destination Connection ID(DCID) - выбирается получателем пакета и используется для согласованной маршрутизации;
Source Connection ID(SCID) - используется для установки DCID используемого удаленным узлом.
Во время рукопожатия используются пакеты с длинными заголовка для установления идентификатора соединения, который использует каждая конечная точка. Каждая конечная точка использует поле SCID для указания DCID который используется для отправки им пакетов. После получения пакета каждая конечная точка устанавливает DCID для отправки, чтобы соответствовать SCID для получения.
Когда пакет Initial отправляется клиентом, который ранее не получал пакет Initial или Retry от сервера, он заполняет поле DCID случайным значением. Это значение ДОЛЖНО быть длиной не менее 8 байт. Пока от сервера не получен пакет, клиент ДОЛЖЕН использовать одно и то же значение, если только он не откажется от попытки соединения и не начнет новое. Исходный DCID используется для выработки защитных ключей для Initial пакетов.
Клиент заполняет поле SCID значение по своему выбору и устанавливает поле SCID Len для указания длины. В первой фазе пакеты 0-RTT используют те же значения DCID и SCID что и первый Initial пакет.
При первом получении пакета Initial или Retry от сервера клиент использует SCID предоставленный сервером в качестве DCID для последующих пакетов, включая любые последующие пакеты 0-RTT. Это означает, что клиент может изменить DCID дважды во время установления соединения, один раз в ответ на Retry и один раз во время получения Initial пакета от сервера. Как только клиент получил Initial пакет от сервера, он ДОЛЖЕН отбрасывать любой пакет, который он получает с другим SCID.
Клиент ДОЛЖЕН изменить только значение отправляемое в DCID в ответ на первый пакет любого типа полученного от сервера (Retry или Initial). Сервер ДОЛЖЕН установить свое значение DCID на основе начального пакета от клиента. Любые дополнительные изменения не допускаются, если последующие пакеты этих типов включают в себя другой SCID они ДОЛЖНЫ быть отброшены. Это позволяет избежать проблем которые могут возникнуть в результате обработки множества Initial пакетов с разными идентификаторами соединений.
Идентификатор соединения может изменяться в течении срока жизни соединения, особенно в ответ на миграцию (Раздел 9. Раздел 5.1.1).

7.3 Транспортные параметры.
Во время установки соединения обе конечные точки делают аутентифицированные декларации своих транспортных параметров. Эти декларации делаются каждой конечной точкой в одностороннем порядке. Конечные точки должны соответствовать ограничениям, налагаемыми этими параметрами. Описание параметра включает в себя правила его обработки.
Кодирование транспортных параметров подробно описано в Разделе 18.
QUIC включает закодированные транспортные параметры в криптографическое рукопожатие. Как только рукопожатие завершается, становятся доступны транспортные параметры объявленные узлом. Каждая конечная точка проверяет предоставленные узлом транспортные параметры.
Определения для каждого определенного параметра включены в Раздел 18.1.
Конечная точка ДОЛЖНА трактовать получение транспортного параметра с недопустимым значением как ошибку соединения типа TRANSPORT_PARAMETER_ERROR.
Сервер ДОЛЖЕН включить транспортный параметр original_connection_id (Раздел 18.1), если он отправляет пакет Retry, чтобы включить проверку Retry, как описано в Разделе 17.2.5.

7.3.1 Значения транспортного параметра для 0-RTT.
Обе конечные точки хранят значения транспортных параметров сервера из соединения и применяют их ко всем 0-RTT пакетам которые отправляются этому узлу, за исключением явно исключенных параметров. Сохраненные транспортные параметры применяются к новому соединению до тех пор, пока рукопожатие не завершится, и клиент не начнет отправлять 1-RTT пакеты. Как только рукопожатие завершается, клиент использует транспортные параметры установленные в рукопожатии.
Определение новых транспортных параметров (Раздел 7.3.2) ДОЛЖНО указывать ДОЛЖНЫ, МОГУТ или НЕ ДОЛЖНЫ сохранятся для 0-RTT. Клиенты не нужно хранить транспортный параметр который он не может обработать.
Клиент НЕ ДОЛЖЕН использовать сохранение значений для следующих параметров: original_connection_id, preferred_address, stateless_reset_token, ack_delay_exponent и active_connection_id_limit. Вместо этого клиент ДОЛЖЕН использовать новые серверные значения в рукопожатии, а если они отсутствуют, то значения по умолчанию.
Клиент который пытается отправить значения 0-RTT ДОЛЖЕН помнить все другие транспортные параметры используемые сервером. Сервер может запомнить эти транспортные параметры или сохранить integrity-protected копию значений в ticket и восстановить информацию при приеме пакета 0-RTT. Сервер использует транспортные параметры при определении принимать или нет 0-RTT данные.
Если сервер принимает данные 0-RTT он НЕ ДОЛЖЕН уменьшать какие либо лимиты или изменять другие значения, которые могут быть не согласованы с клиентскими данными 0-RTT. В частности, сервер которые принимает данные 0-RTT НЕ ДОЛЖЕН устанавливать значения меньше чем запомненные для следующих параметров (Раздел 18.1):
initial_max_data
initial_max_stream_data_bidi_local
initial_max_stream_data_bidi_remote
initial_max_stream_data_uni
initial_max_streams_bidi
initial_max_streams_uni
Пропуск или установка нулевого значения транспортных параметром может привести к тому, что данные 0-RTT будут включены, но не будут использоваться. Подмножество транспортных параметров разрешающих отправку данных приложения ДОЛЖНЫ быть установлены в ненулевое значение для 0-RTT. Включая параметры initial_max_data и initial_max_streams_bidi и initial_max_stream_data_bidi_remote или initial_max_streams_uni и initial_max_stream_data_uni.
Сервер ДОЛЖЕН отклонить данные 0-RTT или прервать квитирование, если не поддерживаются подразумеваемые значения для транспортных параметров.
При отправке кадров в 0-RTT пакетах клиент ДОЛЖЕН использовать только запомненные транспортные параметры. Важно, клиент НЕ ДОЛЖЕН использовать обновленные значения параметров, извлекаемые из обновленных транспортных параметров сервера или кадров 1-RTT. Обновленные транспортные параметры полученные в ходе рукопожатия применяются только к пакетам 1-RTT. Например, лимиты управления потоком применяются из запомненных транспортных параметров применяются ко всем пакетам 0-RTT, даже если эти значения увеличены при рукопожатии или в пакетах 1-RTT. Сервер МОЖЕТ рассматривать использование обновленных параметров в пакетах 0-RTT как ошибку соединения типа PROTOCOL_VIOLATION.

7.3.2 Новые транспортные параметры.
Новые транспортные параметры могут использоваться для согласования нового поведения протокола. Конечная точка ДОЛЖНА игнорировать неподдерживаемые транспортные параметры. Отсутствие транспортного параметра отключает необязательную функцию протокола использующую этот параметр.
Новые транспортные параметры могут быть зарегистрированы в соответствии с правилами описанными в Разделе 22.1

7.4 Буферизация криптографических сообщений
Реализации должны поддерживать буферизацию полученных не по-порядку данных CRYPTO. Поскольку отсутствует управление потоком кадров CRYPTO конечная точка может заставить своего партнера буферизировать неограниченное количество данных.
Реализации ДОЛЖНЫ поддерживать буферизацию не менее 4096 байт данных CRYPTO полученных не по порядку. Конечные точки МОГУТ разрешить буферизацию дополнительных данных во время рукопожатия. Большой лимит во время рукопожатия может позволить обменяться большими ключами или учетными данными. Размер буфера конечной точки не должен оставаться постоянным в течении всего соединения.
Невозможность буферизировать кадры CRYPTO во время рукопожатия может привести к сбою соединения. Если во время рукопожатия превышен буфер конечной точки, этот буфер может быть расширен до конца рукопожатия. Если конечная точка не расширила свой буфер, она ДОЛЖНА закрыть соединение с кодом ошибки CRYPTO_BUFFER_EXCEEDED.
Как только рукопожатие завершается, если конечная точка не может буферизировать данные в кадре CRYPTO, она МОЖЕТ отбросить кадр CRYPTO и все кадры полученные в будущем, или МОЖЕТ закрыть соединение с кодом ошибки CRYPTO_BUFFER_EXCEEDED. Пакеты, содержащие отброшенные кадры CRYPTO, должны быть подтверждены, поскольку пакет был принят и обработан транспортом.

8. Проверка адресов.
Проверка адресов используется QUIC, чтобы избежать использование протокола для атаки усиления трафика. При этой атаке пакет отправляется на сервер с поддельной информацией об адресе источника. Если сервер генерирует большое количество трафика или пакетов в ответ на этот пакет, злоумышленник может использовать сервер, чтобы отправлять жертве больше данных, чем он мог отправить самостоятельно.
Основой защитой от атак на усиление трафика является проверка того, что конечная точка способна принимать пакеты по требуемому транспортному адресу. Проверка адреса выполняется во время установки соединения (Раздел 8.1), так и во время миграции соединения (Раздел 8.2)

8.1 Проверка адреса во время установки соединения
Установление соединения неявно обеспечивает проверку адреса обеих конечных точек. В частности, получения пакета защищенного ключами рукопожатия, подтверждает, что клиент получил начальный пакет с сервера. Как только сервер успешно обработал пакет от клиент, он может считать, что адрес клиент проверен.
Для проверки клиентского адреса сервера НЕ ДОЛЖНЫ  отправлять более чем в три раза больше байт, чем количество полученных ими байт от клиента. Это ограничивает масштаб любой атаки на усиление с использованием поддельных адресов источников.  При определении этого предела сервер учитывает только размер успешно обработанных пакетов.
Клиенты ДОЛЖНЫ гарантировать, что UDP-датаграммы, содержащие начальные пакеты, имеют размер не менее 1200 байт, добавляя заполнение к пакетам по мере необходимости. Отправка дополненных датаграмм гарантирует, что сервер не будет чрезмерно стеснен ограничением усиления.
Потеря пакета, в частности пакета рукопожатия от сервера, может вызвать ситуацию, когда сервер не может отправить данные в ситуации когда у клиенты нет данных для передачи и достигнут предел ограничения усиления. Чтобы избежать взаимоблокировки рукопожатия, клиенты ДОЛЖНЫ отправить пакет по истечению времени повторной передачи, как описано в [QUIC-RECOVERY]. Если клиент не имеет данных для повторной передачи и не имеет ключей рукопожатия, он ДОЛЖЕН послать исходный пакет в дейтаграмме размеров не менее 1200 байт. Если у клиента есть ключи рукопожатия, он ДОЛЖЕН отправить пакет рукопожатия.
Сервер может захотеть проверить адрес клиента перед началом криптографического подтверждения связи. QUIC использует токен в исходной пакете для проверки адреса перед завершением рукопожатия. Этот токен доставляется клиенты во время установки соединения с пакетом Retry (Раздел 8.1.1) или в предыдущем соединении с использование кадра NEW_TOKEN (Раздел 8.1.2)
Серверы помимо ограничений устанавливаемых проверкой адресов, также ограничены контроля перегрузки. Клиенты ограничен только механизмами контроля перегрузки.

8.1.1 Проверка адреса с использование пакета Retry.
После получения пакета Initial сервер может запросить подтверждение адреса, отправив пакет Retry(Раздел 17.2.5) содержащий токен. Этот токен ДОЛЖЕН быть повторен клиентом во всех Initial пакетах, которые от отправляет для этого соединения после получения пакета Retry. В ответ на обработку Initial пакетов сервер может прервать соединение или разрешить его продолжить.
Не представляется возможным атакующему сгенерировать действительный токен для своего собственного адреса (Раздел 8.1.3) и заставить клиента вернуть этот токен, чтобы доказать серверу его получение.
Сервер также может использовать пакет Retry отложить затраты на установку соединения. Представляя клиенты другой ID соединения, сервер может направить подключение к другому экземпляру с большим количество ресурсов.
Использование пакета Retry показано на рисунке 5.
   Client                                                  Server

   Initial[0]: CRYPTO[CH] ->

                                                   <- Retry+Token

   Initial+Token[1]: CRYPTO[CH] ->

                                    Initial[0]: CRYPTO[SH] ACK[1]
                          Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                    <- 1-RTT[0]: STREAM[1, "..."]

   Figure 5: Пример рукопожатия с пакетом Retry


8.1.2 Проверка адреса для будущего соединения
Сервер МОЖЕТ предоставить клиентам токен проверки адреса в текущем соединении для использования в последующих соединения. Проверка адреса особенно важна для 0-RTT, поскольку сервер потенциально отправляет большое количество данных в ответ на 0-RTT.
Сервер использует кадры NEW_TOKEN(Раздел 19.7) для предоставления клиенты токена провери адреса используемый для будущих соединений. Клиент включает этот токен в Initial пакеты для проверки адреса будущих соединений. Клиент ДОЛЖЕН включать токен во все Initial пакеты, если только Retry не заменит токен более новым. Клиент НЕ ДОЛЖЕН использовать токен, предоставленный Retry для будущих соединений. Серверы МОГУТ отбросить любой Initial пакет не содержащий ожидаемый токен.
Токен ДОЛЖЕН быть создан таким, чтобы сервер легко мог отличить его от токенов отправленных в пакетах Retry, поскольку они  переносятся в одном поле.
Токен НЕ ДОЛЖЕН содержать информацию, которая позволила бы наблюдателю связать его с соединением для которого он был создан. Например, он не может включать идентификатор соединения или информацию об адресации, если эти значения не зашифрованы.
В отличии от токена созданного для пакета Retry, этот токен может иметь некоторое время между создание и использованием. Таким образом, токен ДОЛЖЕН иметь время действия. Это может быть любая явно указанное время либо временная отметка выдачи используемая для динамического расчета время действия. Сервер может хранить время действия или включить его в зашифрованном виде в токен.
Маловероятно, что номер порта клиента будет одинаков в двух разных соединениях, поэтому проверка порта едва ли будет успешной.
Если у клиента есть токен полученный в кадре NEW_TOKEN во время предыдущего соединения с тем же сервером, он ДОЛЖЕН включить это значение в толе Token своего Initial пакета. Включение токена позволит серверу проверить адрес клиента без дополнительной обратной передачи.
Токен позволяет серверу соотнести активность между соединением, где был выдан токен и другим соединение, где он используется. Клиенты, которые желают не допустить такой идентификации, МОГУТ сбросить токены полученные с использованием кадра NEW_TOKEN. Токен полученный  в пакете Retry должен быть использован сразу во время попытки соединения и не может использоваться в последующих попытках.
Клиент НЕ ДОЛЖЕН повторно использовать токен в разных соединениях. Повторное использование токена позволяет связать сущности соединений (Раздел 9.5). Клиент НЕ ДОЛЖЕН повторно использовать токен если он считает, что его точка подключения к сети изменилась с момента последнего подключения. То есть, если изменился его локальный IP-адрес или сетевой интерфейс. Клиент должен начать процесс подключения заново, если он мигрирует до завершения рукопожатия.
Когда сервер получает Initial пакет с токена проверки адреса, он ДОЛЖЕН попытаться поверить адрес, если только он уже не завершил проверку адреса. Если токен недействительный, то сервер ДОЛЖЕН действовать так, как если бы клиента не было проверенного адреса, включая отправку Retry. Если проверка прошла успешно, сервер ДОЛЖЕН разрешить рукопожатие.
Примечание.  Обоснование того, что клиент считается не проверенным, а не отбрасываются его пакеты, заключается в том, что клиент мог получить токен в предыдущем соединении с использованием кадра NEW_TOKEN. Если сервер потерял состояние, то он не сможет проверить токен вовсе, что приведет к сбою соединения, если пакет отбрасывать. Сервер ДОЛЖЕН по-разному кодировать токены, отправляемые кадрами NEW_TOKEN и пакетами Retry и проверять последние более строго.
В схеме без сохранения состояния сервер может использовать зашифрованные и аутентифицированные токены для передачи клиентам информации, которую сервер последствии сможет восстановить и использовать для проверки адреса клиента. Токены не интегрированы в криптографическое рукопожатие и поэтому не аутентифицируются. Например, клиент может повторно использовать токен. Чтобы избежать атак использующих это свойство, сервер может ограничить использование токенов только информацией, необходимой для проверки адреса клиента.
Злоумышленники могут воспроизводить токены, для использования серверов в качестве усилителей в DDOS атаках. Для защиты от таких атак серверы ДОЛЖНЫ гарантировать, что токены отправленные в пакетах Retry будут приниматься только в течении короткого времени. Токены предоставленные в кадрах NEW_TOKEN (Раздел 19.7) должны приниматься дольше, но НЕ ДОЛЖНЫ приниматься несколько раз подряд за короткий период. Серверы должны разрешить использование токенов только один раз если это возможно.

8.1.3 Целостность токена проверки адреса.
Токен проверки адреса ДОЛЖЕН быть трудно угадываемым. Включение в токен большого случайного значения должно быть достаточно, в зависимости от того, запоминает ли сервер отправляемое значения.
Схема на основе токенов позволяет серверу разгрузить клиента от любой проверки. Чтобы такая схема работала, токен ДОЛЖЕН быть защищен от модификации и фальсификации клиентом. Без защиты целостности злоумышленник может генерировать или угадывать значения токенов, которые будут приняты сервером. Только сервер должен обладать доступом к ключу защиты целостности токенов.
Нет необходимости в одном четко определенном формате токенов, поскольку сервер использующий токен сам генерирует его. Токен может содержать информацию о заявленном клиентом адресе(IP и порт), метку времени и любую другую полезную информацию нужную серверу для проверки токена в будущем.

8.2 Проверка пути
проверка пути используется во время миграции конечной точки (Раздел 9 и Раздел 9.6), чтобы проверить доступность узла с нового локального адреса. При проверки пути конечные точки проверяют доступность между конкретным локальным адресом и узлом, где адрес двойной набор IP-адреса и порта
Проверка пути проверяет, что пакеты (PATH_CHALLENGE) могут быть отправлены и получены (PATH_RESPONSE) от узла. Важно, что проверка пути  проверяет пакеты полученные от мигрирующей точки на поддельный адрес источника.
Проверка пути может использоваться в любой время любой конечной точкой. Например, конечная точка может проверить, что узел по прежнему владеет локальным адресом после периода простоя.
Проверка пути не разработана как механизм обхода NAT. Несмотря на то, что описанный механизм эффективен для создания NAT bindings, поддерживающих обход NAT, ожидается возможность передачи пакета от узла к узлу без предварительной отправки пакета по этому пути. Для эффективного обхода NAT требуются дополнительные механизмы синхронизации, которые здесь не представлены.
Конечная точка МОЖЕТ объединить кадры PATH_CHALLENGE и PATH_RESPONSE с другими кадрами. В частности, конечная точка может дополнить пакет содержащий PATH_CHALLENGE для обнаружения PMTU или может связать PATH_RESPONSE с собственным PATH_CHALLENGE.
При поиске нового узла конечная точка может захотеть убедится, что узел имеет неиспользованный идентификатор соединения для ответа. Конечная точка может отправить кадр NEW_CONNECTION_ID и PATH_CHALLENGE в одном пакете. Это гарантирует, что неиспользованный ID соединения будет доступен узлу для отправки ответа.

8.3 Инициирование проверки пути
Чтобы инициировать проверку пути  конечная точка отправляет кадр PATH_CHALLENGE содержащий случайную полезную нагрузку по проверяемому пути.
Конечная точка МОЖЕТ отправить несколько кадров PATH_CHALLENGE для защиты от потери пакетов. Однако, конечной точке НЕ СЛЕДУЕТ отправлять несколько PATH_CHALLENGE в одном пакете. Конечной точке НЕ СЛЕДУЕТ отправлять PATH_CHALLENGE чаще, чем Initial пакет. Это гарантирует, что миграция соединения не вызывает большую загрузку пути чем установка нового соединения.
Конечная точка ДОЛЖНА использовать непредсказуемые данные в каждом кадре PATH_CHALLENGE, чтобы была возможность связать ответ сервера с конкретным PATH_CHALLENGE.

8.4 Ответ проверки пути.
Конечная точка при получении кадра PATH_CHALLENGE ДОЛЖНА немедленно ответить повторив данные содержащиеся в полученном кадре в кадре PATH_RESPONSE.
Конечная точка НЕ ДОЛЖНА отправлять более одного кадра PATH_RESPONSE в ответ на один кадр PATH_CHALLENGE (Раздел 13.2). Ожидается, что узел отправит кадр PATH_CHALLENGE по мере необходимости.

8.5 Успех проверки пути
Когда получен кадр PATH_RESPONSE содержащий данные отправленные в предыдущем PATH_CHALLENGE, новый адрес считается действительным. Получение подтверждения для кадра PATH_CHALLENGE не является адекватной проверкой, так как может быть подделано злоумышленником.
Обратите внимание, что получение по другому локальному адресу не приводит с сбою проверки пути, так как это может быть результатом пересылки пакета (Раздел 9.3.3) или сбоем маршрутизации. Возможно, что в будущем будет получен действительный PATH_RESPONSE.

8.6 Неудача проверки пути
Проверка пути завершается неудачей, когда конечная точка пытающееся проверить путь отказывается от проверки.
Конечные точки ДОЛЖНЫ отказаться от проверки пути на основании таймера. При настройке этого таймера реализацией [QUIC-RECOVERY] рекомендует, что время поиска нового пути должно быть в три раза больше текущего Probe Timeout(PTO) или больше начального тайм-аута (kinitialRtt * 2).
validation_timeout = max (3 * PTO, 6 * kInitialRtt)
Обратите внимание, что конечная точка может принимать содержимое других кадров из неподтвержденного пути, но для успешного подтверждение требуется кадр PATH_RESPONSE с соответствующими данными.
Когда конечная точка отказывается от проверки пути, она считает, что данный путь непригоден для использования. Это не означает сбой соединения - конечные точки могут посылать в зависимости от ситуации пакеты по другому пути. Если пути недоступны, конечная точка может дожидаться другого пути или закрыть соединение.
проверка пути может быть отменена и по другим причинам. Пряжде всего, если инициируется миграция соединения на новый путь во время проверки старого.

9. Миграция соединения
Использование идентификатора соединения позволяет конечным точкам пережить изменение адресов (IP-адрес и порт), например, вызванные переходом конечной точки в новую сеть. В этом разделе описывается процесс миграции конечной точки на новый адрес.
Дизайн QUIC основывается на том, что конечные точки сохраняют стабильный адрес на время рукопожатия. Коечная точка НЕ ДОЛЖНА начинать миграцию до подтверждения рукопожатия, как описано в Разделе 4.1.2 [QUIC-TLS].
Конечная точка НЕ ДОЛЖНА инициировать миграцию, если узел отправил транспортный параметр "disable_migration" во время рукопожатия. Конечная точка, отправившая данный параметр, но обнаружившая, что узел мигрировал в другую сеть МОЖЕТ закрыть соединение с ошибкой типа INVALID_MIGRATION. Конечная точка также НЕ ДОЛЖНА инициировать миграцию, если узел предоставил идентификатор соединения нулевой длинны. Поскольку пакеты без DCID не могут быть отнесены к соединению на основе набора адресов.
Не все изменения адреса узла являются преднамеренными миграциями. Узел может подвергаться NAT rebinding: изменение адреса из-за промежуточного устройства, например NAT, выделению нового исходящего порта или нового исходящего IP-адреса. Конечная точка ДОЛЖНА выполнить проверку пути (Раздел 8.2), когда она обнаруживает изменение в адресе узла, если только ранее не была выполнена проверка пути по этому адресу.
Когда конечная точка не имеет проверенного пути для отправки пакетов, она МОЖЕТ сбросить соединение. Конечная точка, способная к миграции, МОЖЕТ подождать пока новый путь не станет доступным, прежде чем сбросить соединение.
Этот документ ограничивает миграцию соединений только новыми клиентскими адресами. за исключением случаев описанных в Разделе 9.6. Клиенты несут ответственность за инициирование всех миграций. Сервер не отправляет non-probing пакеты по адресу клиенты, пока не увидят non-probing пакет с этого адреса. Клиент ДОЛЖЕН отбросить пакеты полученные с неизвестного адреса.

9.1 Зондирование нового пути
Конечная точка перед миграцией МОЖЕТ проверить доступность узла с нового локального адреса используя проверку пути(Раздел 8.2). Ошибка проверки пути означает невозможность его использования для этого соединения. Неспособность проверить путь не приводит к завершению соединения, если нет доступных альтернативных путей.
Конечная точка использует новый идентификатор соединения для "зондов" отправляемых с нового локального адреса(Раздел 9.5). Конечная точка, использующая новый локальный адрес, должна гарантировать доступность по крайней мере одного нового идентификатора соединения на узле. Это может быть достигнуто включение кадра NEW_CONNECTION_ID в "зондирующий" пакет.
Получение кадра PATH_CHALLENGE от узла указывает на проверку доступности пути. Конечная точка отправляет PATH_RESPONSE в ответ (Раздел 8.2).
Кадры PATH_CHALLENGE, PATH_RESPONSE, NEW_CONNECTION_ID, PADDING являются "зондирующими кадрами", а все остальные "не зондирующими". Пакет содержащий только зондирующие кадры, называется "зондирующим пакетом", а пакет содержащий любой другой кадр "не зондирующим пакетом".

9.2 Инициализации миграции соединений
Конечная точка может мигрировать на новый локальный адрес, отправляя пакеты содержащие не зондирующие кадра с этого адреса.
Конечная точка во время установки соединения проверяет адрес узла. Поэтому, мигрирующая конечная точка может отправлять пакеты узлу, зная, что узел готов получать по данному локальному адресу. Таким образом, конечная точка может мигрировать на новый локальный адрес без предварительной проверки адреса узла.
Новый путь при миграции может не поддерживать текущую скорость отправки. Поэтому контрольная точка сбрасывает контроллер перегрузки, как описано в Разделе 9.4.
Новый путь может не иметь такой же возможности ECN. Конечная точка проверяет возможность ECN, как описано в разделе 13.3.
Получение подтверждений для данных, отправленных по новому пути, служит доказательством доступности партнера. Поскольку подтверждения могут быть получены по любому пути, обратная доступность не устанавливается. Чтобы проверить обратную доступность, конечная точка МОЖЕТ инициировать проверку пути как описано в Разделе 8.2.

9.3 Ответ на миграцию соединений
Получение пакета с нового адреса содержащий не зондирующий кадр указывает, что узел мигрировал на этот адрес.
В ответ на такой пакет конечная точка ДОЛЖНА начать отправку последующих пакетов на новый адрес узла и ДОЛЖНА инициировать проверку пути(Раздел 8.2), чтобы подтвердить владение узлом нового адреса.
Конечная точка МОЖЕТ отправлять данные на непроверенный адрес, но она ДОЛЖНА защищаться от потенциальных атак, как описано в РАЗДЕЛЕ 9.2.1 и Разделе 9.3.2. Конечная точка МОЖЕТ пропустить проверку адреса, если адрес  был замечен недавно.
Конечная точка изменяет адрес только в ответ на не зондирующий пакет с наибольшим номером. Это гарантирует, что конечная точка не отправит пакеты на старый адрес в случае получения переупорядоченных пакетов.
После изменения адреса, на который отправляются не зондирующие пакеты, конечная точка может отказаться от проверки пути для других адресов.
Получение пакета с нового адреса может быть связано с NAT rebinding.
После проверки нового клиентского адреса, сервер ДОЛЖЕН отправить новые токены проверки адреса (Раздел 8.2) клиенту.

9.3.1 Подмена адреса узла
Возможно, что узел подделывает свой исходный адрес, чтобы заставить конечную точку отправить чрезмерные объемы данных нежелательному хосту. Если конечная точка отправляет значительно больше данных, чем узел-спуфер, миграция соединения может использоваться для атаки усиления.
Как описано в Разделе 9.3 конечная точка требует проверку адреса узла для подтверждения владения этим адресом. Пока адрес не будет считаться подтвержденным, конечная точка ДОЛЖНА ограничивать скорость передачи данных по этому адресу. Конечная точка НЕ ДОЛЖНА превышать объемы окна перегрузки на расчетное RTT (kMinimunWindow, как определено в [QUIC-RECOVERY]). В отсутствии этого ограничения конечная точка может быть использована для атаки типа "Отказ в обслуживании". Поскольку конечная точка не будет иметь никаких измерений времени RTT по этому адресу, оценка ДОЛЖНА быть начальным значением по умолчанию(см [QUIC-RECOVERY]).
Если конечная точка пропускает проверку адреса, как описано в Разделе 9.3, ей не нужно ограничивать скорость отправки.

9.3.2 Подмена адреса пути
Злоумышленник находящийся на пути может вызвать ложную миграцию соединения, копируя и пересылая пакет с поддельным адресом, так что он пребывает до исходного пакета. Пакет с поддельным адресом будет получен из мигрирующего соединения, а исходный пакет будет считаться дубликатом и отброшен.  После ложной миграции проверка адреса не удастся, поскольку у объекта с поддельным адресом нет необходимых криптографических ключей для чтения и ответа на PATH_CHALLENGE.
Чтобы защитить соединение от ложной миграции, конечная точка ДОЛЖНА вернуться к использованию последнего проверенного адреса узла, если проверка нового адреса не удалась.
Если конечная точка не имеет последнего подтвержденного адреса узла, она ДОЛЖНА закрыть соединение без вывода сообщения, сбрасывая все состояния соединения. Это приведет к тому, что новые пакеты будут обрабатываться по общим правилам. Например, конечная точка МОЖЕТ отправить сброс без сохранения состояния в ответ на любые дальнейшие входящие пакеты.
Получение пакетов с более высокими номерами пакетов с легитимного адреса вызовет другую миграцию соединения. Это приведет к тому, что проверка ложной миграции будет прекращена.

9.3.3 Переадресация пакета вне пути
Злоумышленник, находящийся вне пути и способный наблюдать пакеты, может пересылать копии подлинных пакетов на конечные точки. Если скопированный пакет прибывает до подлинного, это будет создавать видимость NAT rebinding. Любой подлинный пакет будет отброшен как дубликат. Если злоумышленника может продолжать пересылку пакетов, то есть возможность вызвать миграцию соединения через путь атакующего. Тем самым давая ему возможность наблюдать или отбрасывать все последующие пакеты.
В отличии от атаки описанной в Разделе 9.3.2 злоумышленник может убкдится, что новый путь успешно подтвержден.
Эта атака основана на том, что злоумышленники использует примерно такой же быстрый путь, как прямой путь между двумя точками. Успешность атаки повышается, если отправлено относительно мало пакетов или происходит потеря пакетов.
Не зондирующий пакет увеличивающий максимальный номер, полученный по исходному пути, заставит конечную точку вернуться на этот путь. выявление пакетов на этом пути увеличивает вероятность неудачной атаки. Следовательно, смягчение атаки зависит от запуска обмена пакетами.
В ответ на миграцию конечные точки ДОЛЖНЫ проверить ранее активный путь используя кадр PATH_CHALLENGE. Это вызовет отправку новых пакетов по этому пути. Если путь не жизнеспособный, проверка потерпит неудачу. Если путь  жизнеспособный, но больше не требуется, проверка будет успешной, но приведет только к отправке проверочного пакета по этому пути.
Конечная точка, получившая PATH_CHALLENGE на активном пути ДОЛЖНА отправить в ответ не зондирующий пакет. Если не зондирующий пакет прибудет до копии злоумышленника, то соединение мигрирует обратно на исходный путь. Любая последующая миграция перезапустит этот процесс.
Эта защита несовершенна, но это не считается серьезной проблемой. Если путь через атакующего быстрее исходного пути, несмотря на попытки использовать исходный путь, то невозможно провести различия между атакой и улучшением маршрутизации.
Конечная точка может использовать эвристику для обнаружения подобной атаки. Например, NAT rebinding маловероятна, если пакеты были недавно получены по старому пути. Аналогично, повторное связывание редко встречается в сетях Ipv6. И наоборот, изменение идентификатора соединения с больше вероятностью указывает на миграцию, а не на атаку.

9.4 Обнаружение потерь и контроль заторов
Объем доступный по новому пути, может не совпадать со старым путем. Пакеты отправленные по старому пути, НЕ ДОЛЖНЫ влиять на управление перегрузкой или оценку RTT для нового пути.
После подтверждения владения узлом нового адреса конечной точке СЛЕДУЕТ немедленно сбросить контроллер перегрузки и оценки времени RTT для нового пути.
Конечная точка НЕ ДОЛЖНА возвращаться к скорости отправки используемой для предыдущего пути, только если у нее нет достаточной уверенности в том, что предыдущая скорость отправки действительна для нового пути. Например, изменение номера порта клиента, вероятно, свидетельствует о повторной привязки на промежуточном узле, а не о полной смене маршрута. Определение таких ситуаций зависит от несовершенной эвристики. Если скорость нового пути значительно снижается, то контроллер перегрузки среагирует на сигналы и соответствующим образом снизит скорость передачи.
Может случаться переупорядочивание в приемнике, когда конечная точка отправляет данные и зондирующие пакеты с/на несколько адресов в течении периода миграции, поскольку два пути могут иметь различное время прохождения сигнала. Получатель пакетов по нескольким путям будет по прежнему отправлять ACK-кадры покрывающие все полученные пакеты.
Хотя во время миграции соединения используется несколько путей, может быть достаточно одного контекста контроля перегрузки и восстановления потерь (как описано в [QUIC-RECOVERY]). Например, конечная точка может задержать переключения контекста управления перегрузкой, пока не будет подтверждено, что старый путь более не нужен (как в случае описанном в Разделе 9.3.3).
Отправитель может сделать исключение для зондирующих пакетов, чтобы обнаружение их потери не приводило к чрезмерному снижению скорости отправки контроллером перегрузки. Конечная точка может установить отдельный таймер при отправке PATH_CHALLENGE, который сбросится при получении PATH_RESPONSE. Если таймер срабатывает до получения PATH_RESPONSE, конечная точка может отправить новый PATH_CHALLENGE и перезапустить таймер на более длительный период времени.

9.5 Последствия миграции соединения для конфиденциальности
Использование постоянного идентификатора соединения на нескольких путях, позволяет пассивному наблюдателю сопоставить активность между этими путями. Конечная точка, перемещаясь между разными сетями, может не захотеть, чтобы активность коррелировалась с каким либо объектом, кроме удаленного узла. Для этого при отправке с разных локальных адресов используются разные идентификаторы соединения, как описано в Разделе 5.1. Для эффективности этого действия, конечные точки должны гарантировать, что предоставляемые идентификаторы соединения не связаны с любым другим объектом.
В любое время конечные точки МОГУТ изменить отправляемый DCID, на значение, которое не используется на другом пути.
Конечная точка ДОЛЖНА использовать новый идентификатор соединения, если она инициирует миграцию. Использование нового идентификатора соединения исключает использования этого идентификатора для связывания активности одного и того же соединения в разных сетях. Защита заголовка гарантирует, что номера пакетов не могут использоваться для корреляции активности. Однако, это не мешает использовать другие свойства пакетов, такие как время и размер, для корреляции активности.
Возможны непреднамеренные изменения пути без изменения идентификатора соединения. Например, после периода бездействия сети NAT rebinding может привести к отправке пакетов по новому пути, при возобновлении передачи.
Клиент может захотеть уменьшить возможности соединения, используя новый идентификатор соединения и исходный порт UDP при отправке трафика после периода бездействия. Изменение порта UDP для отправки пакетов может вызвать появление пакета приводящего к миграции соединения. Это гарантирует, что механизмы поддерживающие миграцию, применяются даже для клиентов не испытывающих NAT rebinding или настоящих миграций. Изменение номера порта может привести к тому, что узел сбросит контекст контроля перегрузки (Раздел 9.4), поэтому порт СЛЕДУЕТ менять редко.
Конечная точка исчерпавшая идентификаторы соединения не может мигрировать. Чтобы гарантировать возможность миграции и отсутствия корреляции между путями, конечные точки ДОЛЖНЫ предоставлять новые идентификаторы соединения перед миграцией узлов.

9.6 Предпочитаемый адрес сервера
QUIC позволяет серверами принимать соединения на одном IP-адресе и пытаться перенести эти соединения на более предпочтительные адрес вскоре после квитирования. Это особенно полезно, когда клиенты первоначально подключаются в адресу совместно используемому несколькими серверами, но предпочитают использовать адрес одноадресной рассылки для обеспечения стабильности соединения. В этом разделе описывается протокол переноса соединения на предпочитаемый сервер.
Миграция соединения с новым адресом сервера, оставляет промежуточное соединение для дальнейшей работы. Если клиент получает пакете с нового адреса сервера, не указанного в транспортном параметре предпочитаемого адреса, клиент ДОЛЖЕН отбросить эти пакеты.

9.6.1 Сообщение предпочитаемого адреса
Сервер передает предпочитаемый адрес включив его в транспортный параметр preferred_address в TLS рукопожатии.
Серверы МОГУТ сообщать предпочитаемый адрес каждого семейства адресов (IPv4 и IPv6), чтобы клиенты могли выбрать тот, который наиболее подходит для их сетевого подключения.
Как только рукопожатие закончено, клиент ДОЛЖЕН выбрать один из двух предпочтительных адресов сервера и инициировать проверку пути (Раздел 8.2) этого адреса с использованием идентификатора соединения, предоставленного в транспортном параметре preferred_address.
Если проверка пути прошла успешно, клиент ДОЛЖЕН немедленно начать отправку всех будущих пакетов на новый адрес сервера с использованием нового идентификатора соединения и прекратить использование старого адреса сервера. Если проверка не удалась, клиент ДОЛЖЕН продолжить отправку всех будущих пакетов на исходный адрес сервера.

9.6.2 Ответ на миграцию соединения
Сервер может получить пакет адресованные его предпочтительному IP в любое время после принятия соединения. Если этот пакет содержит кадр PATH_CHALLENGE, сервер отправляет кадр PATH_RESPONSE в соответствии с разделом 8.2. Сервер ДОЛЖЕН отправлять другие не зондирующие кадры со своего исходного адреса до тех пор, пока не получит не зондирующий кадр на предпочтительный адрес от клиента и пока не проверит новый путь.
Сервер ДОЛЖЕН проверить путь до клиента с предпочтительного адреса. Это помогает защитится от ложной миграции инициируемой злоумышленником.
После завершения проверки пути и получения не зондирующего пакета с наибольшим номером на предпочтительном адресе, сервер начинает отправлять не зондирующие пакеты исключительно со своего предпочитаемого адреса. Он ДОЛЖЕН отбрасывать пакеты для этого соединения полученные по старому адресу, но МОЖЕТ продолжить обработку задержавшихся пакетов.

6.9.3 Взаимодействие клиентской и предпочтительного адреса
Клиенту может потребоваться выполнить миграцию прежде чем он перейдет на предпочитаемый адрес сервера. В этом случае клиент ДОЛЖЕН одновременно выполнить проверку пути как к исходному так и к предпочтительному адресу сервера с нового клиентского адреса.
Если соединение с предпочтительным адресом сервера не от того же адреса клиента, сервер ДОЛЖЕН защищаться от потенциальных атак, как описано в РАЗДЕЛЕ 9.3.1 и Разделе 9.3.2. В дополнение к преднамеренной одновременной миграции может произойти изменение NAN binding для предпочтительного адреса сервера.
Серверы ДОЛЖНЫ инициировать проверку пути по новому адресу клиента после получения зондирующего пакета с нового адреса. До завершения проверки пути серверы НЕ ДОЛЖНЫ отправлять на новый адрес больше, чем минимальное количество не запрошенных пакетов окна перегрузки.
Мигрирующий на новый адрес клиент ДОЛЖЕН использовать предпочитаемый адрес из того же семейства адресов для сервера.

9.7 Использование метку потока Ipv6 и миграция
Конечные точки, использующие для отправки данных IPv6, ДОЛЖНЫ применять метку потока в соответствии с [RFC6437], если только локальный API не позволяет установить метку потока.
Метка потока IPv6 ДОЛЖНА быть псевдослучайной функцией адреса и порта источника и приемника, а также CID назначения. Генерация метки потока ДОЛЖНА быть спроектировано так, чтобы минимизировать шансы связности с ранее использованной меткой, так как это позволило бы коррелировать активность на нескольких путях (Раздел 9.5).
Возможной реализацией является вычисление метки потока в виде криптографической хеш-функции адресов источника и приемника, портов UDP источника и приемника, CID назначения и локального секрета.
