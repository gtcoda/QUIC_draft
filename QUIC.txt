quic: базирующийся на UDP мультиплексный и безопасный транспортный протокол.

Анотация
Документ определяющий ядро транспортного протокола QUIC. Сопутствующий документ описывает QUIC детекцию потерь пакетов и контроль переполнения и использования обмена ключей TLS.

Введение
QUIC мультиплексируемый и безопасный транспортный протокол общего назначения и обеспечивает:
мультиплексирование потоков
управление потоком на уровне соединения
малая задержка на установку соединения
миграция соединения и устойчивость к NAT пересоединениям
аутентификация и шифрования заголовков и полезной нагрузки

Структура документа
Документ описывает ядро протокола QUIC и состоит из следующих частей.
Потоки как базовые абстракции предоставляемые QUIC:
	Раздел 2 описывает основные понятия связаные с потоками.
	Раздел 3 предоставляет базовую модель состояний потоков.
	Раздел 4 основные операции контроля потока.
Соединения - контекст, в котором взаимодействую конечные точки QUIC.
	Раздел 5 описывает основные понятия связаные с соединениями.
	Раздел 6 описывает версии согласования.
	Раздел 7 детальный процесс установки соединения.
	Раздел 8 особености критических механизмов предотвращиения отказов в обслуживании.
	Раздел 9 описывает каким образом конечные точки мигрирую соединения в новом сетевом окружении.
	Раздел 10 список опций для завершения и открытия соединения.
	Раздел 11 предоставляет основное руководство для обраблотки ошибок.
Пакеты и кадры основные еденицы используемы в соединениях QUIC.
	Раздел 12 описывает понятия связаные с пакетами и фреймами.
	Раздел 13 определяет модель для передачи, ретрянсляции и подтверждения данных.
	Раздел 14 спецификация правил для управления размером пакета.
Детальная расшифровка элементов протокола QUIC, описывает:
	Раздел 15 версии.
	Раздел 16 целочисленное кодирование.
	Раздел 17 заголовки пакета.
	Раздел 18 транспортные параметры.
	Раздел 19 кадры.
	Раздел 20 ошибки.

Дополнительные документы описывают детектирование потери пакетов и управления перегрузкой (QUIC-RECOVERY) и использование ЕДЫ для обмена ключами (QUIC-TLS).

1.2. Термины и определения.

Обычно используемые термины в документе описаны ниже.

QUIC: Транспортный протокол описаный в документе. QUIC это название, a не акроним.
Пакет QUIC: Полноценно обрабатываемая единица QUIC инкапсулированная в UDP датаграму. Множество пакетов QUIC могут быть инкапсулированы в одну UDP датаграму.
Конечная точка: субьект, который может участвовать в установлении QUIC соединения, приеме и обработки пакетов. Существуют только два вида конечных точек QUIC: клиент и сервер.
Клиент: конечная точка инициализирующая соединение.
Сервер: конечная точка принимающая входящее QUIC соединение.
ID соединения: непрозрачный идентификатор используемый для идентификации QUIC соединенияв конечной точке. Каждая конечная точка устанавливает значения для своего партнера и включает его в пакет отправляемый к конечной точке.
Поток: однонаправленный или двунаправденный канал для обмена байтами в QUIC соединении. QUIC соединение несет множество одновленыенных потоков.
Приложение: объект использующий QUIC для передачи и приема данных.

1.3 national conventions
Диаграммы пакетов и фреймов в этом документеиспользуют формат описаный в Секции 3.1 RFC2360, с следованием дополнительных соглашений:
[x]: указанный х опционален.
х (А): указанный х длинной А бит.
х (А/В/С): указанный х длинной А, В или С бит.
х (i): указанный х длинной переменное количество бит, расшифровка в Секции 16.
х (*): указанный х длинной переменное число бит.

2. Потоки
Потоки в QUIC предоставляют легкие, ориентированные на упорядоченый поток байт абстранции для приложений. Потоки могут быть однонаправленные и двунаправленные. Альтернативное представлений однонаправленных потоков в QUIC есть "сообщение" практически неограниченной длинны.
Потоки могут быть созданы для передачи даннных. Остальные процессы связанные с управлением потоком - окончание, отмена и управление потоком - разработаны с целью уменьшения накладных расходов. Для примера, одиночный потоковый фрейм  может быть открыт, передать данные и закрыть поток. Потоки могут быть долгоживущими и могут длинтся все время соединения.
Потоки могут создавать все конечные точки, могут однновременно передавать данные с другими потоками и могут быть отменены. QUIC не обеспечивает порядок байт между разными потоками.
QUIC допускает одновременно произвольное число потоков и передавать произвольное количество данных в любом потоке, с учетом ограничей накладываемых управление потоком(смотри Секцию 4).

2.1 Типы потоков и идентификаторов.
Потоки могут быть однонаправленными и двунаправленными. Однонаправленный поток передает данные только в одном направлении: от инициатора потока к получателю. Двунаправленный поток может передавать данные в обоих направлениях.
Потоки идентифицируются в соединении с помощью цифрового значения, называемым ID потока. ID потока это 62-х битное целое (от 0 до 2^62-1) иникальное для всех потоков данного соединения. ID потока записывается в целое переменой длинны(Раздел 16). Конечная точка QUIC не имеет права переиспользовать ID потока в соединении.
Первый значащий бит (0х1) в ID потока идентифицирует инициатора потока. Инициируемый клиентом поток имеет четный номер(бит установлен в 0), а инициируемый сервером нечетный(бит установлен в 1).
Второй значащий бит (0х2) в ID потока отличает двунаправленный поток(бит установлен в 0) от однонаправленного (бит установлен в 1).
Два первых значащих бита в ID потока идентифицируют поток как один из четырех типов представленных в таблице 1

Биты	Тип потокам
0х0		Инициализировано клиентом, Двунаправленный
0х1		Инициализированный сервером, Двунаправленный
0х2		Инициализированный клиентом, Однонаправленный
0х3		Инициализированный сервером, Однонаправленный

Внутри каждого типа, потоки создаются с числовым увеличением ID потока. ID потока, используемый не по порядку, приводит к тому, что будут открыты все потоки с меньшими порядковыми номерами.
Первый двунаправленный поток открываемый клиентом имеет ID потока 0.

2.2 Отправка и прием данных.
Фрейм потока(Раздел 19.8) инкапсулирует данные отправленные приложением. Конечная точка использует ID потока и поле смещения в фрейме для размещения данных.
Конечная точка может быть в состоянии доставить данные приложению в порядке потока байтов. Доставка потока байтов требует от конечной точки буферизировать любые данные полученые не по порядку, до достижения лимита управления потока.
QUIC не делает никаких специальных указаний для доставки потоком данных не по порядку. Тем не менее, реализация может предлагать возможность доставки приложению данных пришедших не по порядку.
Конечная точка может получать данные для потока с одинаковым смещением несколько раз. Данные которые были уже получены отбрасываются. Данные с данным смещением не могут быть изменены, если они были отправлены несколько раз. Конечная точка может воспринимать получение разных данных с одинаковым смещением в одном потоке как ошибку соединения типа PROTOCOL_VIOLATION.
Потоки - абстракция упорядоченого потока байтов, с не видимой структурой для QUIC. Фрейм потока не сохраняет границы данных при передаче, ретрансляции потеряного пакета и доставки до приложения на стороне приемника.
Конечная точка не может отправить данные в поток без обеспечения в пределах лимита управления потоком установленым второй стороной. Управление потоком детально описывается в Секции 4.

2.3 Приоритизация потоков.
Мультиплексирование потоков может оказать существенное влияние на производительность приложений, если ресурсы, выделеные потокам, имеют правильный приоритет.
QUIC не предоставляет механизм для обмена информацией о приоритетах. Вместо этого, полагается на получение информации о приоритетах от приложения использующего QUIC.
Рализация QUIC ДОЛЖНА предоставлять пути которые позволят приложению узнать относительные приоритеты потоков. При решении каким потокам выделять ресурсы, реализация ДОЛЖНА использовать информацию предоставленую приложением.

3. Состояние потоков.
Эта Раздел описывает потоки в терминах компонентов приема и передачи. Описываются два конечных автомата: один для описания передающмх потоков конечной точки(Раздел 3.1), другой для принимающих потоков конечной точки(Раздел 3.2).
Однонаправленные потоки используют соответствующий конечный автомат. Двунапрвленные потоки используют оба конечных автомата. По большей части использование этих конечных автоматов одинаковое является ли поток однонаправленным или двунаправленным. Условия для открытия двунаправленного потока немного сложнее, потому что, отправляющая и принимающая сторона открывают поток в двух направлениях.
Конечная точка ДОЛЖНА открывать потоки того же типа в порядке ввозрастания ID потока.
Замечание: Эти состояния являются во многом информативными. Этот документ использует состояния потока для описания правил отправки разных типов кадров, и реакции на получение разных типов кадров. Хотя конечный автомат реализовывать QUIC, эти состояния не должны стеснять реализацию.Реализация может обьявлять различные конечные автоматы до тех пор, пока его поведение соответсвует реализации, реализующей эти состояния.

3.1 Состояния потока передачи.
На Рисунке 1 показаны состояния передающей части потока отправляющей данные узлу.
          o
          | Create Stream (Sending)
          | Peer Creates Bidirectional Stream
          v
      +-------+
      | Ready | Send RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Send STREAM /             |
          |      STREAM_DATA_BLOCKED  |
          |                           |
          | Peer Creates              |
          |      Bidirectional Stream |
          v                           |
      +-------+                       |
      | Send  | Send RESET_STREAM     |
      |       |---------------------->|
      +-------+                       |
          |                           |
          | Send STREAM + FIN         |
          v                           v
      +-------+                   +-------+
      | Data  | Send RESET_STREAM | Reset |
      | Sent  |------------------>| Sent  |
      +-------+                   +-------+
          |                           |
          | Recv All ACKs             | Recv ACK
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Recvd |                   | Recvd |
      +-------+                   +-------+

Рисунок 1: Состояния передающей части потоков.

Передающая часть потока конечной точки начинает (тип 0 и 2 для клиента, 1 и 3 для сервера) с открывается приложением. Состояние "Ready" представляет собой вновт созданный поток в состоянии принять данные от приложения. Данные потока могут быть помещены в буфер пля подготовки к отправлению.
Передав первым кадры STREAM и STREAM_DATA_BLOCKED передающая часть потока входит в состояние "Send". Реализация может отложить выделение ID потока, пока не отправит первый кадр STREAM и войти в это состояние, что позволит лучше использовать приоритезащию потоков.
Передающая часть двунаправленного потока инициированная удаленным узлом(тип 0 для сервера, тип 1 для клиента) входит в состояние "Ready" и немедленно переходит в состояние "Send" если принимающая часть переходит в состояние "Recv" (Раздел 3.2)

В состоянии "Send" конечная точка  передает - и ретранслирует если необходимо, - в потоке кадр STREAM. Конечная точка соблюдает лимитыы управления потоком установленые удаленным участниуком, и продолжает принимать м обрабатывать кадры MAX_STREAM_DATA. Конечная точка в состоянии "Send" генерирует кадры STREAM_DATA_BLOCKED, если лимины управления потоком блокируют передачу потока или соединения (Раздел 4.1).
После того, как приложение указало, что все данные потока были переданы и отправлен кадр STRERAM содержащий бит FIN, передающая часть потока переходит в состояние "Data Send". В этом состоянии, конечная точка только повторяет передачу данных если необходимо. Конечная точка не нуждается в проверке лимитов управления потоком или отправки кадров STREAM_DATA_BLOCKED для потока в этом состоянии. Кадры MAX_STREAM_DATA могут приниматься до тех пор пока удаленный участник не примет конец смещения потока. Конечная точка может безопасно игнорировать все MAX_STREAM_DATA кадры полученые от удаленного участника для потока в этом состоянии.
Когда все данные потока успешно подтвердятся, передающая часть потока переходит в состояние "Data Recvd", которое является конечным состоянием.
Для любого состояния "Ready","Send" и "Data Send", приложение может послать сигная с требованием закончить передачи данных. Конечная точка также может принять кадр STOP_SENDING от удаленного участника. В любом случае, конечная точка передает кадр RESET_STREAM, что приводит поток к переходу в сотояние "Reset Send"
Конечная точка МОЖЕТ послать RESET_STREAM в качестве первого кадра упоминаемого в потоке; в этом случае передающая часть открывает поток и немедленно переходит в состояние "Reset Sent".
Когда пакет включает RESET_STREAM успешно подтверждены, передающая часть потока переходит в состояние "Reset Recvd", кторое является конечным состоянием.

3.2 Состояние потока приема
Рисунок 2 показывает состояния для принимающей части потока от удаленного узла. Принимающая часть отражает только некоторые состояния передающей части удаленного узла. Принимающая часть не отслеживает состояние отправителя которые нельзя наблюдать, такие как состояние "Ready". Вместо этого, принимающая часть отслеживает доставку данных приложению, некоторые из которых не могут быть отслежены отправителем.

          o
          | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM
          | Create Bidirectional Stream (Sending)
          | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)
          | Create Higher-Numbered Stream
          v
      +-------+
      | Recv  | Recv RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Recv STREAM + FIN         |
          v                           |
      +-------+                       |
      | Size  | Recv RESET_STREAM     |
      | Known |---------------------->|
      +-------+                       |
          |                           |
          | Recv All Data             |
          v                           v
      +-------+ Recv RESET_STREAM +-------+
      | Data  |--- (optional) --->| Reset |
      | Recvd |  Recv All Data    | Recvd |
      +-------+<-- (optional) ----+-------+
          |                           |
          | App Read All Data         | App Read RST
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Read  |                   | Read  |
      +-------+                   +-------+

    Рисунок 2: Состояния принимающей частии потокам

Принимающая часть потока инициируемая удаленным узлом (ти 1 и 3 для клиента, 0 и 2 для сервера), создается при получении первого STREAM, STREAM_DATA_BLOCKED или RESET_STREAM. Для двунаправленного потока, инициируемого удаленным узлом, получение кадра MAX_STREAM_DATA или STOP_SENDING также инициирует создание принимающей части. Начальное состояние принимающей части "Recv".
Принимающая часть потока переходит в состояние "Recv" когда отправляющая часть двунаправленного потока, инициируемого конечной точкой (тип 0 для клиента и 1 для сервера), переходит в состояние "Ready".
Конечная точка открывает двунаправленные поток, когда от удаленного узла получен кадр MAX_STREAM_DATA или STOP_SENDING. Получение кадра MAX_STREAM_DATA для неоткрытого потока указывает, что удаленный узел открылл поток и предоставил лимит управления потоком. Получение кадра STOP_SENDING для неоткрытого потока указывает, что удаленный узел больше не желает получать данные в этом потоке. Любой кадр может прибыть до кадра STREAM или STREAM_DATA_BLOCKED, если пакеты потеряны или переупорядочены.
Перед созданием потока ДОЛЖНЫ быть созданы все потоки этого типа с меньшими номерами идентификаторов потоков. Это грантирует, что создание потоков согласованы на обеих конечных точках.
В состоянии "Recv" конечная точка получает кадры STREAM и STREAM_DATA_BLOCKED. Поступающие данные буферизируются и могут быть собраны в правильном порядке для доставки в приложение. Когда данные успользуются приложением и освобождается буферное пространство, конечная точка отправляет MAX_STREAM_DATA, чтобы удаленный узел мог отправлять больше данных.
Когда получен кадр STREAM с битом FIN, то становится известен конечный размер потока (Раздел 4.4). Принимающая часть переходт в состояние "Size Known". В этом состоянии конечной точке не нужно отправлять кадры MAX_STREAM_DATA, jyfона только получает любые переданные в потоке данные.
Как только все данные потока получены, принимающая часть переходит в состояние "Data Recv". Это может произойти при получении того же кадра "STREAM", что вызывает переход в состояние "Size Known". После получения всех данных любые кадры STREAM или STREAM_DATA_BLOCKED для этого потока могут быть отбрашены.
Состояние "Data Recvd" сохраняется до тех пор, пока дыннфе не будут доставлены приложению. Как только данные потока доставлены приложению, поток переходит в конечное состояние "Data Read".
При получении кадра RESET_STREAM в состояниях "Recv" или "Size Known" поток переходит в "Reset Recvd". Это может привести к прерыванию доставки данных в приложение.
Возможно, что все данные потокабудут получены, когда поступил RESET_STREAM(то есть в состоянии "Data Recvd"). Аналогично, оставшиеся данные могут поступить после получения кадра RESET_STREAM(в состоянии Reset Recvd). Выбор как поступить в данной ситуации отдается на усмотрение реализации.
Отправка RESET_STREAM означает, что конечная точка не в состоянии гарантировать доставку данных; однако не требуется что бы данные потока не доставлялись, если получено RESET_STREAM. Реализация МОЖЕТ прервать доставку данных, отбросить все неиспользуемые данные и сигнализировать о получении RESET_STREAM. Сигнал RESET_STREAM может быть подавден или скрыт, есливсе данные потока полностью получены и буферизированы для чтения приложением. Если сигнал RESET_STREAM подавлен, принимающая часть потока остается в состоянии "Data Recvd".
Как только приложение получает сигнал о сбросе потока, принимающая часть переходит в конечное состояние "Reset Read".

3.3 Разрешенные типы кадров.
Отправитель потока отправляет три типа кадров, что влияют на состояние потока отправителя или получателя: STREAM(Раздел 19.8), STREAM_DATA_BLOCKED( Раздел 19.13) и RESET_STREAM(Раздел 19.4).
Отправитель НЕ ДОЛЖЕН отправлять все эти кадры в конечном состоянии("Data Recvd" или "Reset Recvd"). Отправитель НЕ ДОЛЖЕН отправлять STREAM или STREAM_DATA_BLOCKED после отправки RESET_STREAM; то есть, в конечных состояниях или в состоянии "Reset Sent". Получатель может принять любой из трех кадров в любом состоянии, из-за возможности задержки доставки пакетов несущих их.
Получатель отправляет кадры MAX_STREAM_DATA(Раздел 19.10) и STOP_SENDING(Раздел 19.5).
Получатель отправляет MAX_STREAM_DATA только в состоянии "Recv". Получатель может отправить STOP_SENDING в любом состоянии, если не получено RESET_STREAM; то есть в состоянии отличном от "Reset Recvd" или "RESET Read". Однако не имеет значения отправка STOP_SENDING в состоянии "Data Recvd", поскольку все данные потока были получены. Оправитель может принять любой из двух кадров в любом состоянии, из-за отложеной доставки пакетов.

3.4 Состояния двунаправленного потока.
Двунаправленный поток состоит из отпраляющей и принимаюзей части. Реализация может представлять состояния двунаправленного потока как состоящее из состояний отпраляюшей и принимающей части. Простоя модель представляет поток как "open" когда отправляющая и принимающая часть находятся не в конечном состоянии и "closed" когда отправитель и получатель потока находятся в конечном состоянии.
Таблица 2 показывает полную карту состояний двунаправленного потока неполно соответствующею состояниям потока HTTP/2[HTTP2]. Здесь показаны обьединенные состояния отправителя и получателясостоящие из обьединенных состояний. Эта запись одно из возможных отображений; оно требует подтверждение данных до перехода в состоние "closed" или "half-closed".

   +-----------------------+---------------------+---------------------+
   | Sending Part          | Receiving Part      | Composite State     |
   +-----------------------+---------------------+---------------------+
   | No Stream/Ready       | No Stream/Recv *1   | idle                |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Recv/Size Known     | open                |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Data Recvd/Data     | half-closed         |
   |                       | Read                | (remote)            |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Reset Recvd/Reset   | half-closed         |
   |                       | Read                | (remote)            |
   |                       |                     |                     |
   | Data Recvd            | Recv/Size Known     | half-closed (local) |
   |                       |                     |                     |
   | Reset Sent/Reset      | Recv/Size Known     | half-closed (local) |
   | Recvd                 |                     |                     |
   |                       |                     |                     |
   | Reset Sent/Reset      | Data Recvd/Data     | closed              |
   | Recvd                 | Read                |                     |
   |                       |                     |                     |
   | Reset Sent/Reset      | Reset Recvd/Reset   | closed              |
   | Recvd                 | Read                |                     |
   |                       |                     |                     |
   | Data Recvd            | Data Recvd/Data     | closed              |
   |                       | Read                |                     |
   |                       |                     |                     |
   | Data Recvd            | Reset Recvd/Reset   | closed              |
   |                       | Read                |                     |
   +-----------------------+---------------------+---------------------+
	Таблица 2: Возможное отображение состояний потока на HTTP/2
   
3.5 Запросы на переход состояний.

Если конечная точка больше не заинтересована в данных которая получает, она МОЖЕТ послать кадр STOP_SENDING для закрытия потока. Обычно это означает, что принимающее приложение больше не читает даннные получаемые в потоке, но не гарантируется, что входящие данные будут игнорироваться.
Кадры STREAM полученые после отправки STOP_SENDING, по прежнему учитываются для соединения и управления потоком, даже если они могут быть отброшены при получении.
Кадр STOP_SENDING запрашивает, что бы принимающая конечная точка отправила кадр RESET_STREAM. Конечная точка принявшая STOP_SENDING, ДОЛЖНА отправить кадр RESET_STREAM, если поток находится в состоянии "Ready" или "Send". Если поток находится в "Data Sent" и все оставшиеся данные обьявляются потеряными, конечной точке СЛЕДУЕТ отправить RESET_STREAM вместо повторной передачи.
Конечной точке СЛЕДУЕТ скопировать код ошибки из кадра STOP_SENDING в кадр RESET_STREAM который она отправляет, но МОЖЕТ использовать любой код ошибки приложения. Конечная точка отправляющая STOP_SENDING МОЖЕТ игнорировать код ошибки содержащийся в любом полученом кадре RESET_STREAM.
Если кадр STOP_SENDING получен в потоке находящимся в состоянии "Data Sent", конечная точка желающая прекратить повторную передачу ранее отправленных кадров STREAM, ДОЛЖНА сначала отправить RESET_STREAM.
STOP_SENDING СЛЕДУЕТ отправлять только для потоков, в состоянии не reset. STOP_SENDING наиболее полезен для потоков в состоянии "Recv" или "Size Known".
Ожидается, что конечная точка отправит еще один STOP_SENDING  если предыдущий пакет содержащий STOP_SENDING был утерян. Однако, как только получены все данные потока или кадр RESET_STREAM, то есть поток находится в состоянии отличном от "Recv" или "Size Known", отправка кадра STOP_SENDING не требуется.
Конечная точка желающая завершить оба направления двунаправленного потока, может завершить одно напрвление отправив RESET_STREAM, и стимулировать быстрое завершение другого направления отправив STOP_SENDING.

4 Контроль потока.
Необходимо ограничивать обьем данных, которое может буфферизировать получяатель, чтобы не дать быстрому отправителю перегрузить медленного получателя или чтобы злонамеренный отправитель не занял большой обьем памяти у получателя. Чтобы позволить получателю ограничить выделение памяти и оказывать давление на отправителя, потоки контролируются как индивидуально так и в совокупности. Получатель QUIC контролирует какой обьем данных может передать отправитель, как описано в Разделе 4.1 и Разделе 4.2.
Аналогично, что бы ограничить параллелизм внутри соединения, конечная точка QUIC контролирует максиматьное число потоков которое может нициировать удаленный узел, как описано в Разделе 4.5.
Жданные отправляемые в кадрах CRYPTO, не подчиняются контролю потока, как данные потока. QUIC полагается на реализацию криптографического протокола, чтобы избежать чрезмерной буферизации данных.(см. [QUIC-TLS]). Реализация ДОЛЖНА предоставить интерфейс для QUIC, сообщающий о его пределах буфферизации, что бы избежать чрезмерной буферизации на нескольких уровнях.

4.1 Управление потоком данных.
QUIC использует схему управления потоком на основе кредитов, аналогичную схеме HTTP\2, где получатель обьявляет количество байтов которое он готов принять в данном потоке и для всего соединения. Это приводит к двум уровням управления потоком в QUIC:
	Управление потоком, предотвращающее использование удним потоком всего буфера приема соединения, путем ограничения обьема данных, которое может быть отпраленно в любом соединении.
	Управление соединением, которое не позволит отправителям превысить емкость буфера получателя для соединения, путем ограничения общего количества байт отправляемых в кажрах STREAM всех потоков.
Получатель установливает начальные лимиты для всех потоков, отправляя параметры во время квитирования (Раздел 7.3). Получатель отправляет отправителю кадры MAX_STREAM_DATA (Раздел 19.10) или MAX_DATA (Раздел 19.9) для установки дополнительных лимитов.
Получатель обьявляет лимит для потока, отправляя кадр MAX_STREAM_DATA с соответствующим образом установленым полем идентификатора потока. Кадр MAX_STREAM_DATA указывает максимальное абсолютное байтовое смещение потока. Приемник используя текущее смещение, определить обьявленный лимит управление потоком. Получатель МОЖЕТ отправалять кадры MAX_STREAM_DATA в нескольких пакетах, чтобы удостоверится, что отправитель получит обновление лимита управления потоком, доже если один из пакетов утерян.
Получатель обьявлет лимит для сединения, отправляя кадр MAX_DATA, который указывает максимум суммы абсолютных смещений всех байтов всех потоков. Приемник сохраняет накопленную сумму байт, полученых во всех потоках, используя ее для проверки нарушения управления потоком. Получатель может использовать сумму байт, полученую во всех потоках, для определения и обьявления максимального предела данных.
Получатель может обьявить большее смещение отправля кадры MAX_STREAM_DATA или MAX_DATA. КАК только получатель обьявил смещение, он МОЖЕТ отправить кадр с меньщим смещением, но это не имеет эффекта.
Получатель ДОЛЖЕН закрыть поток с ошибкой FLOW_CONTROL_ERROR (Раздел 11), если отправитель нарушает лимиты соединения или потока.
Отправитель ДОЛЖЕН игнорировать любые кадры MAX_DATA или MAX_STREAM_DATA которые не увеличивают лимиты управления потоком.
Если отправителю не хватает лимита управления потоком, он не может передавать новые данные и считается заблокированным. Отправителю СЛЕДУЕТ отправить кадр STREAM_DATA_BLOCKED или DATA_BLOCKED, чтобы указать, что у него есть данные для отправки, но он заблокирован ограничениями управления потоком. Ожидается, что эти кадры в обычных случаях будут отправляться нечасто, но они полезны для целей мониторинга и отладки.
Отправителю не следует отправлять несколько кадров STREAM_DATA_BLOCKED или DATA_BLOCKED для одного и того же лимита данных, только если кадр не будет определен как потерянный. Еще один кадр STREAM_DATA_BLOCKED или DATA_BLOCKED может быть отправлен после увеличения лимита данных.

4.2 Увеличение лимита управления потоком.
Этот документ оставляет на усмотрение реализации когда и сколько байт обьявлять в кадрах MAX_STREAM_DATA или MAX_DATA, но предлагает несколько соображений. Эти кадры привносят издержки в соединение. Поэтому нежелательна частая отправка кадров с небольшими изменениями. В то же время необходимы большие приращения лимитов, чтобы избежать блокировок, если обновление выполняется редко, что в сою очередь требует наличия больших ресурсов у получателя. Таким образом, следует искать компромисс между выделение русурсов и накладными расходами при определении лимита управлея потоком.
Приемник может использовать автоматический механизм настройки частоты и размера обьявленного добаваления лимита на основе оценки времени круговой задержки и скорости, ч какой принимающее приложение потребляет данные, аналогично обычным реализациям TCP. В качестве оптимизации, отправка кадров связаных с управление потоком, осуществляется только тогда, когда есть другие кадры для отправки или когда удаленный узел заблокирован. Это гарантирует, что управление потоком не вызовет отправку дополнительных пакетов.
Если отправителю не хватает лимита управления потоком, он не сможет передавать новые данные и считается заблокированным. Обычно считается, что отправитель не должен блокироваться. Чтобы избежать блокировки отправителя и учесть возможность потери кадров, получатель должен отправить кадр MAX_DATA или MAX_STREAM_DATA минимум за два RTT, до ожидаемого момента блокировки.
Получатель НЕ ДОЛЖЕН дожидаться STREAM_DATA_BLOCKED или DATA_BLOCKED перед отправкой MAX_STREAM_DATA или MAX_DATA, так как это означает, что отправитель будет заблокирован, по крайней мере на один цикл RTT, и возможно на более длительный срок, если партнер решит не отправлять STREAM_DATA_BLOCKED или DATA_BLOCKED.

4.3 Обработка отмены потока.
Конечные точки должны в конечном итоге договорится о сумме лимитов, который будет использоваться, чтобы избежать превышения лимитов или взаимоблокировки.
После получения RESET_STREAM конечная точка завершает работу для соответствующего потока и игнорирует другие даннные поступающе в этот поток. Без смещения включенного в RESET_STREAM, количество байт которое учитывается при управлении потоком может не совпадать.
Чтобы устранить эту проблему кадр RESET_STREAM(Раздел 19.4) включает в себя окончательный размер данных передаваемый в потоке. Получив кадр RESET_STREAM получатель точно знает сколько байт было отправленно в этом потоке до кадра RESET_STREAM. Получатель ДОЛЖЕН использовать окончательный размер потока, для учета всех отправленных байт, в управлении потоком уровня соединения. 
RESET_STREAM завершает одно направление потока. Для двунаправленного потока RESET_STREAM не влияет на поток в противоположном направлении. Обе конечные точки ДОЛЖНЫ поддерживать состояние управления потоком для потока в незавершенном направлении, пока это направление не завершится или одна из конечных точек не отправит кадр CONNECTION_CLOSE.

4.4 Окончательный размер потока.
Окончательный размер это сумма лимита управления потоком.  Если предположить, что каждый байт в потоке был отправлен один раз, то окончательный размер равер количеству отправленных байт. В более общем случае, ky равен на еденицу больше, чем смещение последнего байта отправленного в потоке или ноль, если не было ни одного байта.
Для потока в состоянии RESET окончательный размер явно берется из кадра RESET_STREAM. В противном случае окончательный размер этовсещение плюс длинна кадра STREAM с флагом FIN, или 0 в случае входящих однонаправленных потоков.
Конечная точка будет знать окончательный размер потока, когда принимающая часть перейдет в состояние "Size Known" или "Reset Recvd" (Раздел 3).
Конечная точка НЕ ДОЛЖНА отправлять даннные в поток за пределами конечного размера.
Как только окончательный размер потока известен, он не может изменится. Если получен кадр RESET_STREAM или STREAM, указывающий на изменение конечного размера, конечная точка ДОЛЖНА ответить ошибкой FINAL_SIZE_ERROR (Раздел 11). Получателю СЛЕДУЕТ обработотать получение данных окончательного размера или за его пределами как ошибку FINAL_SIZE_ERROR даже после закрытия потока. Генерирование этих ошибок не является обязательным, только потому, что требуются ресурсы, чтобы конечная точка должна поддерживать состояние финального размера для закрытых потоков.

4.5 Контроль согласованости.
Конечная точка ограничивает общее количество входящих потоков, которое может открыть удаленный узел. Открыты могут быть только потоки с идентификатором меньше чем (max_stream * 4 + initial_stream_id_for_type)(Таблица 5). Начальные ограничения устанавливаются транспортными параметрами (Раздел 18.1), а затем обьявляются с использованием кадров MAX_STREAMS(раздел 19.11). Отдельные ограничения для однонаправленных и двунаправленных потоков.
Если транспортный параметр max_stream или кадр MAX_STREAMS получен со значением превышающем 2^60, что является максимальным идентификатором, который может быть выражен целым числом переменной длинны. (Раздел 16). Если такой идентификатор получен соединение ДОЛЖНО быть немедленно закрыто с ошибкой STREAM_LIMIT_ERROR (Раздел 10.3)
Конечные точки НЕ ДОЛЖНЫ превышать ограничения установленные удаленными узлами. Конечная точка получившая кадр с идентификатором потока превышающем установленный ею лимит, ДОЛЖНА трактовать это как ошибку соединения типа STREAM_LIMIT_ERROR (Раздел 11).
Как только получатель обьявляет ограничение потока с помощью кадра MAX_STREAMS, обьявление немьшего ограничения не имеет никакого эффекта. Приемник ДОЛЖЕН игнорировать любой кадр  MAX_STREAMS, который не увеличивает лимит.
Этот документ оставляет выбор реализации когда и сколько открывать потоков через MAX_STREAMS. Реализация может увеличивать предел по мере того, как потоки закрываются, чтобы количество потоков для удаленного узд\ла было примерно одинаковым.
Конечная точка, которая не может открыть новый поток из-за ограничения, ДОЛЖНА отправить кадр STREAMS_BLOCKED (Раздел 19.14) Этот сигнал считается полезным для отладки. Конечная точка НЕ ДОЛЖНА ждать получения этого сигнал, прежде чем увеличить лимит. Посколько это означает, что удаленный узел будет заблокирован, по крайней мере на один цикл RTT, и возможно на более длительный срок, если удаленный узел решит не отправлять кадр STREAMS_BLOCKED.

5. Соединения
QUIC соединение сочетает согласование версии с криптографическим и транспортным рукопожатием для уменьшение задержки установки соединения, как описанов Разделе 7. После установления соединения конечная точка может менять IP или порт, как описано в разделе 9. Соединение может быть прервано любой конечной точкой, как описано в разделе 10.

5.1 ID соединения.
Каждое соединение обладает набором идентификаторов, или ID соединения, аждый из которых может идентифицировать соединение. Идентификаторы независимо выбираются двумя конечными точками, каждая конечная точка выбирает идентификаторы соединения которые использует удаленный узел.
Основная функция ID соединения заключается в обеспечении того, чтобы изменение на более низких уровнях протокола(UDP, IP) не приводили к доставке пакетов соединения QUIC в неправильную конечную точку. Каждая конечная точка выбирает идентификаторы соединения, используя метод специфичный для реализации, который позволит маршрутизировать пакеты с этим идентификатор обратно к конечной точке и идентифицировать конечную точку при получении.
ID соединения НЕ ДОЛЖНЫ содержать информацию, котрая может использоваться внешним наблюдателем для сопоставления их с другими ID соединения этого же соединения. В качестве тривиального примера, один и то же ID НЕ ДОЛЖЕН выдаваться более одного раза длля одного и того же соединения.
Пакеты с длинными заголовками включают поля "Sourse Connection ID" и "Destination Connection ID". Эти поля используюся для установки идентификаторов новых соединений, см Раздел 7.2.
Пакеты с короткими заголовками(Раздел 17.3) включают только "Destination Connection ID" и явно опискают длинну. Ожидается, что длинна поля "Destination Connection ID" известна конечным точкам. Конечные точки, использующие балансировщик нагрузки маршрутизирующий на основе ID соединения, могут согласовать с балансировщиком фиксированую длинну идентификатора, или согласовать схему кодирования.
В пакете Согласования (Раздел 17.2.1), повторяются идентификаторы соединения выбранные клиентом, чтобы гарантировать правильность маршрутизации к клиенту и позволет ему проверить, что данный пакет является ответом на начальный пакет.
ID соединения нулевой длинны МОЖЕТ использоваться, когда ID соединения не нужен для маршрутизации, а набор адрес/порт пакета достаточно для идентификации. Конечная точка, чей удаленный узел выбрал ID нулевой длинны, ДОЛЖНА продолжать использовать такой ID в течении всего времени существования соединения, и НЕ ДОЛЖНА отправлять пакеты с любого другого локального адреса.
Когда конечная точка запросила ID ненулевой длинны, она должна убедится, что удаленный узел имеет запас идентификаторов соединения, из которого можно выбрать пакеты для отправки конечной точке. Эти ID предоставляются конечной точкой с использованием кадра NEW_CONNECTION_ID (Раздел 19.15)

5.1.1 Выдача идентификаторов соединений.
Каждый ID имеет свезяный порядковый номер помогающий в дедупликации сообщений. Начальный ID, выданный конечной точкой, отправляется в поле Sourse Connection ID длинного заголовка пакета (Раздел 17.2) во врмя квитирования. Порядковый номер исходного идентификатора равен 0. Если передан транспортный параметр preferred_address, порядкой номер предоставляемого идентификатора равен 1.
Дополнительные идентификаторы передаются удаленному узлу с помощью кадров NEW_CONNECTION_ID (Раздел 19.15). Порядковый номер каждлого вновь выданного соединения ДОЛЖЕН увеличиваться на 1. ID, произвольно выбранный клиентом в исходном пакете, и любой идентификатор предоставленный пакетом Retry, не являютя назначеными порядковыми номерами, только если сервер не решит сохранить их в качестве своего начального ID.
Когда конечная точка выдала ID, она ДОЛЖНА принимать все пакеты с этим ID на все время соединения или до тех пор, пока удаленный узел не сделает этот ID недействительным по средствам кадра RETIRE_CONNECTION_ID (Раздел 19.16).
Конечной точке СЛЕДУЕТ гарантировать, что удаленный узел имеет достаточное количество доступных и неиспользованныз ID. Конечные точки хранят полкченные идентификаторы для будущего использования и обьявляют номера ID которые они готовы хранить с помощью транспортного параметра active_connection_id_limit. Конечной точке НЕ СЛЕДУЕТ представлять больше ID чем ограничение удаленного узла.
Конечной точке СЛЕДУЕТ предоставить новый идентификатор соединения, когда она получает пакет с ранее неиспользуемым ID или когда удаленный узел удаляет его, если только предоставление нового ID не превысит лимит установленный удаленным узлом. Конечная точка МОЖЕТ ограничить частоту и общее количество ID, cjolfdftvs[ для каждого соединения, чтобы избежать риска исчерпания идентификаторов соединения (Раздел 10.4.2)
Конечная точка, инициирующая миграцию и требующая идентификаторов ненулевой длинны, ДОЛЖНА гарантировать, что пул ID доступных удаленному узлу, позволит использовать новый ID при миграции, в противном случае, при исчерпании пула, соединение будет закрыто.

5.1.2 Использование и удаление идентификаторов соединения.
Конечная точка может изменить ID соединения, который она использует для удаленного узла, в любой момент соединения. Конечная точка использует ID в ответ на миграцию удаленного узла. (Раздел 9.5).
Конечная точка поддерживает набор идентификаторов, полученых от удаленного узла, любой из которых может использоваться при отправке пакетов. Когда конечная точка желает удалить идентификатор из списка используемых, она отправляет кадр RETIRE_CONNECTION_ID. Отправка кадра RETIRE_CONNECTION_ID указывает, что ID соединения больше не будет использоваться, и запрашивает, чтобы удаленный узел заменил его новым используя NEW_CONNECTION_ID.
Из обсуждения в Разделе 9.5, каждый идентификатор ДОЛЖЕН использоваться в пакетах, отправляемых ьлдбко с одного локального адреса. Конеченой точке, которая мигрирует с локального адреса, СЛЕДУЕТ удалить идентификаторы, используемые для этого адреса, если она не планирует больше использовать этот адрес.
Конечная точка может запросить удаленный узел удалить ID соединения отправлением кадра NEW_CONNECTION_ID с увеличением поля "Retire Prior To". После получения удаленный узел ДОЛЖЕН удалить соответствующие идентификаторы соединения и своевременно отправить соответствующие карды RETIRE_CONNECTION_ID. Невыполнение этого требования может привести к задержкам, потерям пакетов или к тому, что исходная конечная точка отправит сброс в ответ на идентификатор, который она не может правильно маршрутизировать.
Конечная точка МОЖЕТ отбросить ID, для которого запрошено удаление, по истечению не менее 3 PTO с момента получения подтверждения для кадра NEW_CONNECTION_ID, запросившего такое удаление. Последующие входящие пакеты использующие этот ID, могут вызвать токеном сброса.

5.2 Сопоставленение пакетов с соединением
Входящие пакеты классифицируются при получении. Пакеты могут быть связаны с существующим соединением или, дя серверов, потенциально создавать новое соединение.
Хосты пытаются связать пакеты с существующим соединением. Если пакет имеет Destination Connection ID, соответствующий существующему соединению, QUIC обрабатывает этот пакет соответствующим образом. Обратите внимание, что с соединением может быть связано больше одного соединения, см Раздел 5.1.
Если Destination Connection ID имеет нулевую длину и пакет соответствует набору адрес\порт соединения, для которого хосту не требовалось ID, QUIC обработает пакет как часть этого соединения. Конечные точки ДОЛЖНЫ либо отклонять попытки соединения, которые используют те же адреса, что и существующие соединения, либо использовать Destination Connection ID ненулевой длинны, чтобы пакеты могли быть правильно отнесены к соединениям.
Конечные точки могут отправлять сброс без сохранения состояния (Раздел 10.4) для любых пакетов, которые нельзя отнести к сузествующему соединению. Сброс без сохранения состояния позволяет удаленному узлу быстрее определить, что соединение становится непригодным для использования.
Пакеты, которые соответствуют существующему состоянию, отбрасываются, если эти пакеты не соответствуют состоянию этого соединения. Например, пакеты отбрасываются, если они указывают версию протокола, отличную от версии соединения. Или если расшифровка пакета не удалась, несмотря на наличие ожидаемых ключей.
Неверные пакеты без шифрования, такие как Initial, Retry или Version Negitiation, МОГУТ быть отброшены. Конечная точка ДОЛЖНА генерировать ошибку соединения, если она фиксирует изменение состояния до обнаружения ошибки.

5.2.1 Обработка пакетов клиентом
Правильные пакеты, отправляемые клиентом, всегда содержат Destination Connection ID который соответствует значению выбранному клиентом. Клиенты, которые выбирают получение ID нулевой длинны, могут использовать набор адрес\порт для идентификации соединения. Пакеты которые не сответствуют существующему соединению отбрасываются.
Из-за переупорядосивания или потери пакеток клиент может получить пакеты зашифрованные с помощью ключа, который он еще не вычислил. Клиент МОЖЕТ отбросить эти пакеты или МОЖЕТ буфферизировать их в ожидании более позних пакетов позволяющих вычислить ключ.
Если клиент получает пакет с неподдерживаемой версией он ДОЛЖЕН отбросить пакет.

5.2.2 Обработка пакетов сервером
Если сервер получает пакет неподдерживаемой версии, но пакет достаточен для того, чтобы инициализировать новое соединение для любой версии поддерживаемой сервером, он ДОЛЖЕН отправить пакет согласования версии, как описано в разделе 6.1. Серверы МОГУТ контролировать эти пакеты, чтобы избежить пакетных штормов. В противном слечае серверы ДОЛЖНЫ отбрасывать пакеты, которые указывают неподдерживаемые версии.
Первый пакет неподдерживаемой версии может использовать различную семантику и кодирование для любого поля, зависящего от версии. В частности, от версии могут различаться ключи шифрования пакетов.Серверы, неподдерживающие конкретныую версию, вряд ли смогут расшифровать содержимое пакета. Серверы НЕ ДОЛЖНЫ пытаться декодировать или дешифровывать пакет неизвестной версии, но вместо этого отправляют пакет согласования версий при условии, что пакет достаточно длинный.
Пакеты поддерживаемой версии или без поля версии сопоставляются соединению, используя ID или - для пакетов с ID нулевой длинный - набор адрес\порт. Если пакет не соответствует соединению, сервер продолжает работать с ним как описано ниже.
Если пакет является Начальным и полностью соответствует спецификации, сервер продолжает рукопожатие. Сервер фиксиhetn версию, которую выбрал клиент.
Еслтсервер не принимает новые соединения, он ДОЛЖЕН отправить исходный пакет содержащий кадр CONNECTION_CLOSE с кодом ошибки SERVER_BUSY.
Если полученный пакет является 0-RTT, сервер МОЖЕТ буферизировать ограниченое число пакетов в ожидании запоздавшего Начального пакета. Клиенты не могут отправлять пакеты для рукопожатия до получения ответа сервера, поэтому сервер ДОЛЖЕН игнорировать любые такие пакеты.
Серверы ДОЛЖНЫ отбрасывать входящие пакеты при любых других обстаятельствах.

5.3 Срок жизни QUIC соединения.
Подлежит определению.

6. Согласование версий.
Согласование версий гарантирует, что клиент и сервер согласятся на взаимноподдерживаемую версию QUIC. Серве отправляет пакет согласования в ответ на каждый пакет, который может инициирововать соединениее (Разде 5.2)
Размер первого пакета отправленного клиентом, определяет отправляет ли сервер пакет согласования версий. Клиенты поддерживающие несколько версий QUIC, ДОЛЖНЫ дополнять первый отправляемый пакет наибольшим из минимальных размеров пакетов во всех версиях которые они поддерживают. Это гарантирует, что сервер ответит, еслисуществует взаимоподдерживаемая версия.

6.1 Отправка пакета согласования версий.
Если выбранная клиентом версия неприемлима для сервера, он отвечает пакетом согласования версий (Раздел 17.2.1). Он включает в себя список поддерживаемых сервером версий. Конечная точка НЕ ДОЛЖНА отвечать пакетом согласования на пакет согласования.
Такая система позволяет серверу обрабатывать пакеты с неподдерживаемой версией без сохранения состояния. Несмотря на то, что исходный пакет или пакет согласования версий может быть потерян, клиент будет отправлять новые пакеты до тех пор пока не получит ответ или не откажется от попытки подключения. В результате клиент сбрасывает все состояния подключения и не отправляет больше пакетов на соединение.
Сервер МОЖЕТ ограничить количество отправляемых пакетов согласования версий. Например, сервер который может распознавать 0-RTT  пакеты, может предпочесть не отправлять пакеты согласования версий в ответ на такие пакеты, ожидая получить в конечном итоге начальный пакет.

6.2 Обработка пакета согласования версий.
Когда клиент получает пакет согласования версий, он ДОЛЖЕН отказаться от текущей попытки подключения. Пакеты согласования версий предназначены для возможности будущий версий QUIC согласовывать используемые версии между конечными точками. Будущие версии QUIC могут изменить реализацию реагирования на пакеты согласования версий данной версии. Определение реализации согласования версий оставляется для будущий версий QUIC. В часности, будущие реализации должны обеспечить устойчивость к атакам понижения версии (Раздел 21.9).

6.3 Использование зарезервированных версий.
Для того, чтобы сервер мог использовать в будущем новую версию, клиенты должны правильно обрабатывать неподдерживаемые версии. Чтобы гарантировать это, сервер ДОЛЖЕН включать версию, зарезервированную для принудительного согласования версий(0x?a?a?a?a, как определено в Разделе 15), при генерации пакета согласования версии.
Такая конструкция согласования версий позволяет сервера избегать сохранения состояния для отклоненных таким образом пакетов.
Клиент МОЖЕТ отправить пакет, используя зарезервированную версию. Это может использоваться для получения от сервера списка поддерживаемых версий.

7. Криптографическое и транспортное рукоподатие.
QUIC использует комбинированное криптографическое и транспортное рукопожатие для минимизации задержки установления соединения. QUIC использует кадр CRYPTO (Раздел 19.6) для передачи криптографического рукопожатия. Версия 0x00000001  QUIC использует TLS[QUIC-TLS]. Другой номер версии QUIC можен указывать на использование другого криптографического протокола.
QUIC обеспечивает надежную, упорядоченую доставку данных криптографического рукопожатия. Защита пакетов QUIC используется для шифрования как можно больше части протокола рукопожатия. Криптографическое рукопожатие ДОЛЖНО обеспечивать следующие свойства:
o аутентифицированный обмен ключами, где
	* сервер всегда аутентифицирован,
	* клиент может быть дополнительно аутентифицирован,
	* каждое соединение создает отдельные и несвязанные ключи,
	* ключевой материал пригоден для защиты пакетов 0-RTT, 1-RTT и т.д.
	* ключи 1-RTT имеют премую секретность.
o аутентифицирование значения для транспортных параметров удаленного узла (Раздел 7.3)
o аутентифицируемое согласование протокола приложения (для этой цели TLS использует ALPN[RFC7301])
Первый кадр CRYPTO  от клиента ДОЛЖЕН быть отправлен в одном пакете. Любая другая попытка инициировать проверку адреса (Раздел 8.1) ДОЛЖНА также отправлятся в одном пакете. Это позволяет избежать сборки сообщения из нескольких пакетов.
Первый клиентский пакет протокола криптографического квитирования ДОЛЖЕН уместится в полезную нагрузку 1232-байтного пакета QUIC. Эта нагрузка включает в себя служебные данные уменьшающие пространство доступное для протокола криптографического квитирования.
Конечная точка может проверить поддержку явного уведомления о перегрузке (ECN) в первых отправленных ей пакетах(Раздел 13.3.2).
Кадр CRYPTO может быть отправлен в разных пространствах номеров пакетов. Порядковые номера используемые кадрами CRYPTO для обеспечения упорядоченой доставки дянных рукопожатия, начинаются с нуля в каждом пространстве пакетов.
Конечные точки ДОЛЖНЫ явно согласовать протоком приложения. Это позволит избежать разногласия по поводу используемого протокола.

7.1 Пример рукопожатия.
Подробная информация о том как ЕДЫ интегрирован в QUIC представвлена в [QUIC-TLS], но некоторые примеры приведены здесь. Расширение этого обмена для поддержки проверки адреса клиента показано в разделе 8.1.1.
После завершения любой проверки адресов, криптографическое подтверждение используется для согласования риптографических ключей. Криптографическое рукопожатие передается в пакетах Initial (Раздел 17.2.2) и Handshake (раздел 17.2.4).
На рисунке 3 представлен обзор рукопожатия 1-RTT. Каждая строка показывает пакет QUIC с типом и номером от начала, и сопровождаемыми кадрами которые обычно содержаться в этом пакете. Например, первый кадр имеет тип Initial с номером 0 и содержит кадр CRYPTO переносящий ClientHello.
Обратите внимание, что несколько пакетов, даже с разными уровнями шифрования, могут быть обьеденены в одну дейтаграмму UDP (Раздел 12.2). Поэтому, рукопожатие может состоять всего из 4 дейтаграмм UDP или любого другого числа. Например, первый ответ сервера содержит пакеты с начального уровня шифрования(обфускации), уровня рукопожатия и уровня 1-RTT с данными "0,5-RTT".
   Client                                                  Server

   Initial[0]: CRYPTO[CH] ->

                                    Initial[0]: CRYPTO[SH] ACK[0]
                          Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                    <- 1-RTT[0]: STREAM[1, "..."]

   Initial[1]: ACK[0]
   Handshake[0]: CRYPTO[FIN], ACK[0]
   1-RTT[0]: STREAM[0, "..."], ACK[0] ->

                               1-RTT[1]: STREAM[3, "..."], ACK[0]
                                          <- Handshake[1]: ACK[0]

 Figure 3: Пример 1-RTT Handshake

На рисунке 4 представлен пример соединения с рукопожатием 0-RTT и одним пакетом данных 0-RTT. Обратите внимание, как описано в разделе 12.3, сервер подтверждает данные 0-RTT на уровне шифрования 1-RTT и клиент отправляет пакеты 1-RTT в том же пространстве номеров пакетов.
   Client                                                  Server

   Initial[0]: CRYPTO[CH]
   0-RTT[0]: STREAM[0, "..."] ->

                                    Initial[0]: CRYPTO[SH] ACK[0]
                                     Handshake[0] CRYPTO[EE, FIN]
                             <- 1-RTT[0]: STREAM[1, "..."] ACK[0]

   Initial[1]: ACK[0]
   Handshake[0]: CRYPTO[FIN], ACK[0]
   1-RTT[1]: STREAM[0, "..."] ACK[0] ->

                               1-RTT[1]: STREAM[3, "..."], ACK[1]
                                          <- Handshake[1]: ACK[0]

 Figure 4: Пример 0-RTT Handshake
					 
7.2 Согласование идентификаторов соединения.
Идентификатор соединения используется для обеспечения согласованной маршрутизации пакетов, как описано в разделе 5.1. Длинный заголовой содержит два идентификатора соединения:
Destination Connection ID(DCID) - выбирается получателем пакета и используется для согласованной маршрутизации;
Source Connection ID(SCID) - используется для установки DCID используемого удаленным узлом.
Во время рукопожатия используются пакеты с длинными заголовка для установления идентификатора соединения, который использует каждая конечная точка. Каждая конечная точка использует поле SCID для указания DCID который используется для отправки им пакетов. После получения пакета каждая конечная точка устанавливает DCID для отправки, чтобы соответствовать SCID для получения.
Когда пакет Initial отправляется клиентом, который ранее не получал пакет Initial или Retry от сервера, он заполняет поле DCID случайным значением. Это значение ДОЛЖНО быть длиной не менее 8 байт. Пока от сервера не получен пакет, клиент ДОЛЖЕН использовать одно и то же значение, если только он не откажется от попытки соединения и не наченет новое. Исходный DCID используется для выработки защитных ключей для Initial пакетов.
Клиент заполняет поле SCID значение по своему выбору и устанавливает поле SCID Len для указания длины. В первой фазе пакеты 0-RTT используют те же значения DCID и SCID что и первый Initial пакет.
При вервом получении пакета Initial или Retry от сервера клиент использует SCID предоставленный сервером в качестве DCID для последующих пакетов, включая любые последующие пакеты 0-RTT. Это означает, что клдиент может изменить DCID дважды во время установления соединения, один раз в ота=вет на Retry и один раз во время получения Initial пакета от сервера. Как только клиент получил Initial пакет от сервера, он ДОЛЖЕН отбрасывать любой пакет, который он получает с другим SCID.
Клиент ДОЛЖЕН изменить только значение отправляемое в DCID в ответ на первый пакет любого типа полученого от сервера (Retry или Initial). Сервер ДОЛЖЕН установить свое значение DCID на основе начального пакета от клиента. Любые дополнительные изменения не доспускаются, если последующие пакеты этих типов включают в себя другой SCID они ДОЛЖНЫ быть отброшены. Это позволяет избежать проблем кторые могут возникнуть в результате обработки множества Initial пакетов с разными идентификаторами соединений.
Идентификатор соединения может изменяться в течении срока жизни соединенения, особенно в ответ на миграцию (Раздел 9. Раздел 5.1.1).

7.3 Транспортные параметры.
Во время установки соединения обе конечные точки делают аутентифицированные декларации своих транспортных параметров. Эти декларации делаются каждой конечной точкой в одностороннем порядке. Конечные точки должны соответствовать ограничениям, налагаемыми этими параметрами. Описание параметра включает в себя правила его обработки.
Кордирование транспортных параметров подробно описано в Разделе 18.
QUIC включает закодированые транспортные параметры в криптографичкеское рукопожатие. Как только рукопождатие завершается, становятся доступны транспортные параметры обьявленные узлом. Каждая конечная точка проверяет предоставленные узлом транспортные параметры.
Определения для каждого определенного параметра включены в Раздел 18.1.
Конечная точка ДОЛЖНА трактовать получение транспортного параметра с недопустимым значением как ошибку соединения типа TRANSPORT_PARAMETER_ERROR.
Сервер ДОЛЖЕН включить транспортный параметр original_connection_id (Раздел 18.1), если он отправляет пакет Retry, чтобы включить проверку Retry, как описано в Разделе 17.2.5.

7.3.1 Значения транспортного параметра для 0-RTT.
Обе конечные точки хранят значения транспорных параметров сервера из соединения и применяют их ко всем 0-RTT пакетам которые отправляются этому узлу, за исключением явно исключенных параметров. Сохраненные транспорные параметры применяются к номуму соединению до тех пор, пока рукопожатие не завершится, и кнлиент не начнет отправлять 1-RTT пакеты. Как только рукопожатие завершается, клиент использует транспорные параметры установленные в рукопожатии.
Определение новых транспортных параметров (Раздел 7.3.2) ДОЛЖНО указывать ДОЛЖНЫ, МОГУТ или НЕ ДОЛЖНЫ сохранятся для 0-RTT. Клиенты не нужно хранить транспортный параметр который он не может обработать.
Клиент НЕ ДОЛЖЕН использовать сохранение значений для следующих параметров: original_connection_id, preferred_address, stateless_reset_token, ack_delay_exponent и active_connection_id_limit. Вместо этого клиент ДОЛЖЕН использовать новые серверные значения в рукопожатии, а если они отсутствуют, то значения по умолчанию.
Клиент который пытается отправить значения 0-RTT ДОЛЖЕН помнить все други транспортные параметры используемые сервером. Сервер может запомнить эти транспортные параметры или сохранить integrity-protected копию значений в ticket и востановить информацию при приеме пакета 0-RTT. Сервер использует транспортные параметры при определении принимать или нет 0-RTT данные.
Если сервер принимает данные 0-RTT он НЕ ДОЛЖЕН цуменьшать какие либо лимиты или изменять другие значения, которые могут быть не согласованы с клиентскими данными 0-RTT. В частности, сервер котрые принимает данные 0-RTT НЕ ДОЛЖЕН устанавливать значения меньше чем запомненые для следующих параметров (Раздел 18.1):
initial_max_data
initial_max_stream_data_bidi_local
initial_max_stream_data_bidi_remote
initial_max_stream_data_uni
initial_max_streams_bidi
initial_max_streams_uni
Пропуск или установка нулевого значения транспортных параметром может привести к тому, что данные 0-RTT будут включены, но не будут использоваться. Подмножество транспортных параметров разрешающих отправку данных приложеня ДОЛЖНЫ быть установлены в ненулевое значение для 0-RTT. Включая параметры initial_max_data и initial_max_streams_bidi и initial_max_stream_data_bidi_remote или initial_max_streams_uni и initial_max_stream_data_uni.
Сервер ДОЛЖЕН отклонить данные 0-RTT или прервать квитирование, если не поддерживаются подразумеваемые значения для транспортных параметров.
При отправке кадров в 0-RTT пакетах клиент ДОЛЖЕН использовать только запомненные транспортные параметры. Важно, клиент НЕ ДОЛЖЕН использовать обновленные значения параметров, изволекаемые из обновленных транспортных параметров сервера или кадров 1-RTT. Обновленные транспорные параметры полученые в ходе рукопожатия применяются только к пакетам 1-RTT. Например, лимиты усправления потоком применяются из запомненых транспортных параметров применяются ко всем пакетам 0-RTT, даже если эти значения увеличины при рукопожатии или в пакетах 1-RTT. Сервер МОЖЕТ рассматривать использование обновленных параметров в пакетах 0-RTT как ошибку соединения типа PROTOCOL_VIOLATION.

7.3.2 Новые транспортные параметры.
Новые транспортные параметры могут использоваться для согласования нового поведения протокола. Конечная точка ДОЛЖНА игнорировать неподдерживаемые транспортные параметры. Отсутствие транспортноо параметра отключает необязательную функцию протокола использующую этот параметр.
Новые транспортные параметры могут быть зарегистрированы в соответствии с правилами описаными в Разделе 22.1

7.4 Буферизация криптографических сообщений
Реализации должны поддерживать буферизацию полученых не попорядку данных CRYPTO. Поскольку отсутствует управление потоком кадров CRYPTO конечная точка может заставить своего партнера буферизировать неограниченое количество данных.
Реализации ДОЛЖНЫ поддерживать буферизацию не менее 4096 байт данных CRYPTO полученых не по порядку. Конечные точки МОГУТ разрешить буферизациюдополнительных данных во време рукопожатия. Большой лимит во время рукопожатия может позволить обменяться большими ключами или учетными данными. Размер буфера конечной точки не должен оставаться постоянным в течении всего соединения.
Невозможность буферизировать кадры CRYPTO во время рукопожатия может привести к сбою соединения. Если во время рукопожатия превышен буфер конечной точки, этот буфер может быть расширен до конца рукопожатия. Если конечная точка не расширила свой буфер, она ДОЛЖНА закрыть соединене с кодом ошибки CRYPTO_BUFFER_EXCEEDED.
Как только рукопожатие завершается, если конечная токчка не может буферизировать данныев кадре CRYPTO, она МОЖЕТ отбросить кадр CRYPTO и все кадры полученые в будущем, или МОЖЕТ закрыть соединение с кодом ошибки CRYPTO_BUFFER_EXCEEDED. Пакеты, содержащие отброшеные кадры CRYPTO, должны быть подтверждены, поскольку пакет был принят и обработан транспортом.

8. Проверка адресов.
Проверка адресов испольуется QUIC, чтобы избежать использование протокола для атаки усиления трафика. При этой атаке пакет отправляется на сервер с поддельной инфомрацией об адресе источника. Если сервер генерирует большое количество трафика или пакетов в ответ на этот пакет, злоумышленник может использовать сервер, чтобы отпрвлять жертве больше данных, чем он мог отправить самостоятельно.
Основой защитой от атак на силение трафика является проверка того, что конечная точка способна принимать пакеты по требуемому транспортному адресу. Проверка адреса выполняется вов ремя установки соединения (Раздел 8.1), так и во время миграции соединения (Раздел 8.2)

8.1 Проверка адреса во время установки соединения
Установление соединения неявно обеспечивает проверку адреса обеих конечных точек. В часности, получения пакета защищенного ключами рукопожатия, подтверждает, что клиент получил начальный пакет с сервера. Как только сервер успешно обработая пакет от клиент, он может считать, что адрес клиент проверен.
Для проверки клиентского адреса сервера НЕ ДОЛЖНЫ  отправлять более чем в три раза больше байт, чем количество полученых ими байт от клиента. Это ограничивает масштаб любой атаки на усиление с использованием поддельных адресов источников.  При определении этого предела сервер учитывает только размер успешно обработаных пакетов.
Клиенты ДОЛЖНЫ гарантировать, что UDP-датаграммы, содержащие начальные пакеты, имеют размер не менее 1200 байт, добавляя заполнение к пакетам по мере необходимости. Отправка дополненых датаграм гарантирует, что сервер не будет чрезмерно стеснен ограничением усиления.
Потеря пакета, в частности пакета рукопожатия от сервера, может вызвать ситуацию, когда сервер не может отправить данные в ситуации когда у клиенты нет данных для передачи и достугнут предел ограничения усиления. Чтобы избежать взаимоблокировки рукопожатия, клиенты ДОЛЖНЫ отправить пакет по истечению времени повторной передачи, как описано в [QUIC-RECOVERY]. Если клиент не имеет данных для повторной передачи и не имет ключей рукопожатия, он ДОЛЖЕН послать исходный пакет в дейтаграмме размеров не менее 1200 байт. Если у клиента есть ключи рукопожатя, он ДОЛЖЕН отправить пакет рукопожатия.
Сервер может захотеть проверить адрес клиента перед началом криптографического подтверждения связи. QUIC использует токен в исходной пакете для проверки адреса перед завершением рукопожатия. Этот токет доставляется клиенты во время установки соединения с пакетом Retry (Раздел 8.1.1) или в предыдущем соединении с использование кадра NEW_TOKEN (Разде 8.1.2)
Серверы помимо ограничений устанавливаемых проверкой адресов, также ограничены контролея перегрузки. Клиенты ограничен только механизмами контроля перегрузки.

8.1.1 Проверка адреса с использование пакета Retry.
После получения пакета Initial сервер может запросить подтверждение адреса, отправив пакет Retry(Раздел 17.2.5) содержащий токен. Этот токен ДОЛЖЕН быть повторен клиентом во всех Initial пакетах, которые от отправляет для этого соединения после получения пакета Retry. В ответ на обработку Initial пакетов сервер может прервать соединение или разрешить его продолжить.
Не представляется возможным атакующему сгенерировать действительный токен для своего собственного адреса (Раздел 8.1.3) и заставить клиента вернуть этот токет, чтобы доказать серверу его получение.
Сервер также может использовать пакет Retry отложить затраты на установку соединения. Представляя клиенты другой ID соединения, сервер может напраить подключение к другому экземпляру с большим количество ресурсов.
Использование пакета Retry паказано на рисунке 5.
   Client                                                  Server

   Initial[0]: CRYPTO[CH] ->

                                                   <- Retry+Token

   Initial+Token[1]: CRYPTO[CH] ->

                                    Initial[0]: CRYPTO[SH] ACK[1]
                          Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                    <- 1-RTT[0]: STREAM[1, "..."]

   Figure 5: Пример рукопожатия с пакетом Retry


8.1.2 Проверка адреса для будущего соединения
Сервер МОЖЕТ предоставить клиентам токен проверки адреса в текущем соединении для использования в последующих соединения. Проверка адреса особенно важна для 0-RTT, поскольку сервер потенциально отправляет большое количество данных в ответ на 0-RTT.
Сервер использует кадры NEW_TOKEN(Раздел 19.7) для предоставления клиенты токена провери адреса испольщзуемый для будущих соединений. Клиент включает этот токет в Initial пакеты для проверки адреса будущих соединений. Клиент ДОЛЖЕН включать токен во все Initial пакеты, если только Retry не заменит токен более новым. Клиент НЕ ДОЛЖЕН использовать токен, предоставленый Retry для будущих соединений. Серверы МОГУТ отбросить любой Initial пакет не содержащий ожидаемый токен.
Токен ДОЛЖЕН быть создан таким,чтобы сервер легко мог отличить его от токенов отправленых в пакетах Retry, поскольку они  переносятся в одном поле.
Токен НЕ ДОЛЖЕН содержать информацию, которая позволила бы наблюдателю связать его с соединением для которого он был создан. Например, он не может включать идентификатор соединения или информацию об адресации, если эти значения не зашифрованы.
В отличии от токена созданного для пакета Retry, этот токен может иметь некоторое время между создание и использованием. Таким образом, токен ДОЛЖЕН иметь время действия. Это может быть любая явно указанное время либо временная отметка выдачи используемая для динамического расчета время действия. Сервер может хранить время действия или включить его в зашифрованном виде в токен.
Маловероятно, что номер порта клиента будет одинаков в двух разных соединениях, поэтому проверка порта едва ли будет успешной.
Если у клиента есть токен полученный в кадре NEW_TOKEN во время предыдущего соединения с тем же сервером, он ДОЛЖЕН включить это значение в толе Token своего Initial пакета. Включение токена позволит серверу проверить адрес клиента без дополнительной обратной передачи.
Токен позволяет серверу соотнести активность между соединением, где был выдан токен и другим соединение, где он используется. Клиенты, которые желают не допустить такой идентификации, МОГУТ сбросить токены полученные с использованием кадра NEW_TOKEN. Токен полученный  в пакете Retry должен быть использован сразу во время попытки соединения и не может использоваться в последующих попытках.
Клиент НЕ ДОЛЖЕН повторно использовать токен в разных соединениях. Повторное использование токена позволяет связать сущности соединений (Раздел 9.5). Клиент НЕ ДОЛЖЕН повторно использовать токен если он считает, что его точка подключения к сети изменилась с момента последнего подключения. То есть, если изменился его локальный IP-адрес или сетевой интерфейс. Клиент должен начать процесс подключения заново, если он мигрирует до завершения рукопожатия.
Когда сервер получает Initial пакет с токена проверки адреса, он ДОЛЖЕН попытаться поверить адрес, если только он уже не завершил проверку адреса. Если токен недействительный, то сервер ДОЛЖЕН действовать так, как если бы клиента не было проверенного адреса, включая отправку Retry. Если проверка прошла успешно, сервер ДОЛЖЕН разрешить рукопожатие.
Примечание.  Обоснование того, что клиент считается не проверенным, а не отбрасываются его пакеты, заключается в том, что клиент мог получить токен в предыдущем соединении с использованием кадра NEW_TOKEN. Если сервер потерял состояние, то он не сможет проверить токен вовсе, что приведет к сбою соединения, если пакет отбрасывать. Сервер ДОЛЖЕН по-разному кодировать токены, отправляемые кадрами NEW_TOKEN и пакетами Retry и проверять последние более строго.
В схеме без сохранения состояния сервер может использовать зашифрованные и аутентифицированные токены для передачи клиентам информации, которую сервер последствии сможет восстановить и использовать для проверки адреса клиента. Токены не интегрированы в криптографическое рукопожатие и поэтому не аутентифицируются. Например, клиент может повторно использовать токен. Чтобы избежать атак использующих это свойство, сервер может ограничить использование токенов только информацией, необходимой для проверки адреса клиента.
Злоумышленники могут воспроизводить токены, для использования серверов в качестве усилителей в DDOS атаках. Для защиты от таких атак серверы ДОЛЖНЫ гарантировать, что токены отправленные в пакетах Retry будут приниматься только в течении короткого времени. Токены предоставленные в кадрах NEW_TOKEN (Раздел 19.7) должны приниматься дольше, но НЕ ДОЛЖНЫ приниматься несколько раз подряд за короткий период. Серверы должны разрешить использование токенов только один раз если это возможно.

8.1.3 Целостность токена проверки адреса.
Токен проверки адреса ДОЛЖЕН быть трудно угадываемым. Включение в токен большого случайного значения должно быть достаточно, в зависимости от того, запоминает ли сервер отправляемое значения.
Схема на основе токенов позволяет серверу разгрузить клиента от любой проверки. Чтобы такая схема работала, токен ДОЛЖЕН быть защищен от модификации и фальсификации клиентом. Без защиты целостности злоумышленник может генерировать или угадывать значения токенов, которые будут приняты сервером. Только сервер должен обладать доступом к ключу защиты целостности токенов.
Нет необходимости в одном четко определенном формате токенов, поскольку сервер использующий токен сам генерирует его. Токен может содержать информацию о заявленном клиентом адресе(IP и порт), метку времени и любую другую полезную информацию нужную серверу для проверки токена в будущем.

8.2 Проверка пути
проверка пути используется во время миграции конечной точки (Раздел 9 и Раздел 9.6), чтобы проверить доступность узла с нового локального адреса. При проверки пути конечные точки проверяют доступность между конкретным локальным адресом и узлом, где адрес двойной набор IP-адреса и порта
Проверка пути проверяет, что пакеты (PATH_CHALLENGE) могут быть отправлены и получены (PATH_RESPONSE) от узла. Важно, что проверка пути  проверяет пакеты полученные от мигрирующей точки на поддельный адрес источника.
Проверка пути может использоваться в любой время любой конечной точкой. Например, конечная точка может проверить, что узел по прежнему владеет локальным адресом после периода простоя.
Проверка пути не разработана как механизм обхода NAT. Несмотря на то, что описанный механизм эффективен для создания NAT bindings, поддерживающих обход NAT, ожидается возможность передачи пакета от узла к узлу без предварительной отправки пакета по этому пути. Для эффективного обхода NAT требуются дополнительные механизмы синхронизации, которые здесь не представлены.
Конечная точка МОЖЕТ объединить кадры PATH_CHALLENGE и PATH_RESPONSE с другими кадрами. В частности, конечная точка может дополнить пакет содержащий PATH_CHALLENGE для обнаружения PMTU или может связать PATH_RESPONSE с собственным PATH_CHALLENGE.
При поиске нового узла конечная точка может захотеть убедится, что узел имеет неиспользованный идентификатор соединения для ответа. Конечная точка может отправить кадр NEW_CONNECTION_ID и PATH_CHALLENGE в одном пакете. Это гарантирует, что неиспользованный ID соединения будет доступен узлу для отправки ответа.

8.3 Инициирование проверки пути
Чтобы инициировать проверку пути  конечная точка отправляет кадр PATH_CHALLENGE содержащий случайную полезную нагрузку по проверяемому пути.
Конечная точка МОЖЕТ отправить несколько кадров PATH_CHALLENGE для защиты от потери пакетов. Однако, конечной точке НЕ СЛЕДУЕТ отправлять несколько PATH_CHALLENGE в одном пакете. Конечной точке НЕ СЛЕДУЕТ отправлять PATH_CHALLENGE чаще, чем Initial пакет. Это гарантирует, что миграция соединения не вызывает большую загрузку пути чем установка нового соединения.
Конечная точка ДОЛЖНА использовать непредсказуемые данные в каждом кадре PATH_CHALLENGE, чтобы была возможность связать ответ сервера с конкретным PATH_CHALLENGE.

8.4 Ответ проверки пути.
Конечная точка при получении кадра PATH_CHALLENGE ДОЛЖНА немедленно ответить повторив данные содержащиеся в полученном кадре в кадре PATH_RESPONSE.
Конечная точка НЕ ДОЛЖНА отправлять более одного кадра PATH_RESPONSE в ответ на один кадр PATH_CHALLENGE (Раздел 13.2). Ожидается, что узел отправит кадр PATH_CHALLENGE по мере необходимости.

8.5 Успех проверки пути
Когда получен кадр PATH_RESPONSE содержащий данные отправленные в предыдущем PATH_CHALLENGE, новый адрес считается действительным. Получение подтверждения для кадра PATH_CHALLENGE не является адекватной проверкой, так как может быть подделано злоумышленником.
Обратите внимание, что получение по другому локальному адресу не приводит с сбою проверки пути, так как это может быть результатом пересылки пакета (Раздел 9.3.3) или сбоем маршрутизации. Возможно, что в будущем будет получен действительный PATH_RESPONSE.

8.6 Неудача проверки пути
Проверка пути завершается неудачей, когда конечная точка пытающееся проверить путь отказывается от проверки.
Конечные точки ДОЛЖНЫ отказаться от проверки пути на основании таймера. При настройке этого таймера реализацией [QUIC-RECOVERY] рекомендует, что время поиска нового пути должно быть в три раза больше текущего Probe Timeout(PTO) или больше начального тайм-аута (kinitialRtt * 2).
validation_timeout = max (3 * PTO, 6 * kInitialRtt)
Обратите внимание, что конечная точка может принимать содержимое других кадров из неподтвержденного пути, но для успешного подтверждение требуется кадр PATH_RESPONSE с соответствующими данными.
Когда конечная точка отказывается от проверки пути, она считает, что данный путь непригоден для использования. Это не означает сбой соединения - конечные точки могут посылать в зависимости от ситуации пакеты по другому пути. Если пути недоступны, конечная точка может дожидаться другого пути или закрыть соединение.
проверка пути может быть отменена и по другим причинам. Пряжде всего, если инициируется миграция соединения на новый путь во время проверки старого.

9. Миграция соединения
Использование идентификатора соединения позволяет конечным точкам пережить изменение адресов (IP-адрес и порт), например, вызванные переходом конечной точки в новую сеть. В этом разделе описывается процесс миграции конечной точки на новый адрес.
Дизайн QUIC основывается на том, что конечные точки сохраняют стабильный адрес на время рукопожатия. Коечная точка НЕ ДОЛЖНА начинать миграцию до подтверждения рукопожатия, как описано в Разделе 4.1.2 [QUIC-TLS].
Конечная точка НЕ ДОЛЖНА инициировать миграцию, если узел отправил транспортный параметр "disable_migration" во время рукопожатия. Конечная точка, отправившая данный параметр, но обнаружившая, что узел мигрировал в другую сеть МОЖЕТ закрыть соединение с ошибкой типа INVALID_MIGRATION. Конечная точка также НЕ ДОЛЖНА инициировать миграцию, если узел предоставил идентификатор соединения нулевой длинны. Поскольку пакеты без DCID не могут быть отнесены к соединению на основе набора адресов.
Не все изменения адреса узла являются преднамеренными миграциями. Узел может подвергаться NAT rebinding: изменение адреса из-за промежуточного устройства, например NAT, выделению нового исходящего порта или нового исходящего IP-адреса. Конечная точка ДОЛЖНА выполнить проверку пути (Раздел 8.2), когда она обнаруживает изменение в адресе узла, если только ранее не была выполнена проверка пути по этому адресу.
Когда конечная точка не имеет проверенного пути для отправки пакетов, она МОЖЕТ сбросить соединение. Конечная точка, способная к миграции, МОЖЕТ подождать пока новый путь не станет доступным, прежде чем сбросить соединение.
Этот документ ограничивает миграцию соединений только новыми клиентскими адресами. за исключением случаев описанных в Разделе 9.6. Клиенты несут ответственность за инициирование всех миграций. Сервер не отправляет non-probing пакеты по адресу клиенты, пока не увидят non-probing пакет с этого адреса. Клиент ДОЛЖЕН отбросить пакеты полученные с неизвестного адреса.

9.1 Зондирование нового пути
Конечная точка перед миграцией МОЖЕТ проверить доступность узла с нового локального адреса используя проверку пути(Раздел 8.2). Ошибка проверки пути означает невозможность его использования для этого соединения. Неспособность проверить путь не приводит к завершению соединения, если нет доступных альтернативных путей.
Конечная точка использует новый идентификатор соединения для "зондов" отправляемых с нового локального адреса(Раздел 9.5). Конечная точка, использующая новый локальный адрес, должна гарантированить доступность по крайней мере одного нового идентификатора соединения на узле. Это может быть достигнуто включение кадра NEW_CONNECTION_ID в "зондирующий" пакет.
Получение кадра PATH_CHALLENGE от узла указывает на проверку доступности пути. Конечная точка отправляет PATH_RESPONSE в ответ (Раздел 8.2).
Кадры PATH_CHALLENGE, PATH_RESPONSE, NEW_CONNECTION_ID, PADDING являются "зондирующими кадрами", а все остальные "не зондирующими". Пакет содержащий только зондирующие кадры, называется "зондирующим пакетом", а покет содержащий любой другой кадр "не зондирующим пакетом".

9.2 Инициализации миграции соединений
Конечная точка может мигрировать на новый локальный адрес, отправляя пакеты содержащие не зондирующие кадра с этого адреса.
Конечная точка во время установки соединения проверяет адрес узла. Поэтому, мигрирующая конечная точка может отправлять пакеты узлу, зная, что узел готов получать по данному локальному адресу. Таким образом, конечная точка может мигрировать на новый локальный адрес без предварительной проверки адреса узла.
Новый путь при миграции может не поддерживать текущую скорость отправки. Поэтому контрольная точка сбрасывает контроллер перегрузки, как описано в Разделе 9.4.
Новый путь может не иметь такой же возможности ECN. Конечная точка проверяет возможность ECN, как описано в разделе 13.3.
Получение подтверждений для данных, отправленных по новому пути, служит доказательством доступности партнера. Поскольку подтверждения могут быть получены по любому пути, обратная доступность не устанавливается. Чтобы проверить обратную доступность, конечная точка МОЖЕТ иницировать проверку пути как описано в Разделе 8.2.

9.3 Ответ на миграцию соединений
Получение пакета с нового адреса содержащий не зондирующий кадр указывает, что узел мигрировал на этот адрес.
В ответ на такой пакет конечная точка ДОЛЖНА начать отпраку последующих пакетов на новый адрес узла и ДОЛЖНА инициировать проверку пути(Раздел 8.2), чтобы подтвердить владение узлом нового адреса.
Конечная точка МОЖЕТ отправлять данные на непроверенный адрес, но она ДОЛЖНА защищаться от потенциальных атак, как описано в РАЗДЕЛЕ 9.2.1 и Разделе 9.3.2. Конечная точка МОЖЕТ пропустить проверку адреса, если адрес  был замечен недавно.
Конечная точка изменяет адрес только в ответ на не зондирующий пакет с наибольшим номером. Это гарантирует, что конечная точка не отправит пакеты на старый адрес в случае получения переупорядоченых пакетов.
После изменения адреса, на который отправляются не зондирующие пакеты, конечная точка может отказаться от проверки пути для других адресов.
Получение пакета с нового адреса может быть связано с NAT rebinding.
После проверки нового клиеннтского адреса, сервер ДОЛЖЕН отправить новые токены проверки адреса (Раздел 8.2) клиенту.

9.3.1 Подмена адреса узла
Возможно, что узел подделывает свой исходный адрес, чтобы заставить конечную точку отправить чрезмерные обьемы данных нежелательному хосту. Если конечная точко отправляет значительно больше данных, чем узел-спуфер, миграция соединения может использоваться для атаки усиления.
Как описанов в Разделе 9.3 конечная точка требует проверку адреса узла для подтверждения владения этим адресом. Пока адрес не будет считаться подтвержденным, конечная точка ДОЛЖНА ограничивать скорость передачи данных по этому адресу. Конечная точка НЕ ДОЛЖНА превышать обьемы окна перегрузки на расчетное RTT (kMinimunWindow, как определено в [QUIC-RECOVERY]). В отсутствии этого ограничения конечная точка может быть использована для атаки типа "Отказ в обслуживании". Поскольку конечная точка не будет иметь никаких измерений времени RTT по этому адресу, оценка ДОЛЖНА быть начальным значением по умолчанию(см [QUIC-RECOVERY]).
Если конечная точка пропускает проверку адреса, как описано в Разделе 9.3, ей не нужно ограничивать скорость отправки.

9.3.2 Подмена адреса пути
Злоумышеник находящийся на пути может вызвать ложную миграцию соединения, копируя и пересылая пакет с поддельным адресом, так что он пребывает до исходного пакета. Пакетс поддельным адресом будет получен из мигрирующиго соединения, а исходный пакет будет считатьсядубликатом и отброшен.  После ложной миграции проверка адреса не удасться, поскольку у обьекта с поддельным адресом нет необходимых криптографических ключей для чтения и ответа на PATH_CHALLENGE.
Чтобы защитить соединение от ложной миграции, конечная точка ДОЛЖНА вернуться к использованию последнего провереного адреса узла, если проверка нового адреса не удалась.
Если конечная точка не имеет последнего подтвержденного адреса узла, она ДОЛЖНА закрыть соединение без вывода сообщения, сбрасывая все состояния соединения. Это привдет к тому, чтоновые пакеты будут обрабатываться по общим правилам. Например, конечная точка МОЖЕТ отправить сброс без сохранения состояния в ответ на любые дальнейшие входящие пакеты.
Получение пакетов с более высокими номерами пакетов с легитимного адреса вызовет другую миграцию соединения. Это приведет к тому, что проверка ложной миграции будет прекращена.